{"version":3,"file":"957.50ce3132402d9f99.js","mappings":"qJAKM,MAAOA,EACXC,UAAUC,EAAcC,EAAeC,EAAgB,OACrDF,SAAMG,KAAK,CAACC,EAAQC,IACdD,EAAEH,GAASI,EAAEJ,GACE,QAAVC,GAAkB,EAAK,EACrBE,EAAEH,GAASI,EAAEJ,GACL,QAAVC,EAAkB,GAAI,EAEtB,GAGJF,CACR,4CAZUF,EAAe,mDAAfA,EAAeQ,4RCkBtB,MAAOC,+CAA0B,+BAA1BA,qCAVTC,KACAC,IACAC,MACAC,KACAC,MACAC,KACAC,wBCME,MAAOC,+CAAsB,+BAAtBA,qCAXTP,KACAE,MACAM,KACAC,MACAN,KACAE,KACAK,KACAJ,yKCbE,MAAOK,GAWSC,aAVbC,QAAe,CACpBC,MAAO,GACPC,YAAa,GACbC,UAAU,EACVC,OAAQ,GACRC,KAAM,OACNC,qBAAqB,EACrBC,uBAAuB,GAGzBC,YAAoBT,sBAAwD,CAE5EU,SACEC,KAAKX,aAAaY,OACnB,CAEDC,aACEF,KAAKX,aAAaY,MAAM,IACnBD,KAAKV,QACRC,MAAOS,KAAKV,QAAQC,MAAMY,OAC1BX,YAAaQ,KAAKV,QAAQE,YAAYW,QAEzC,4CAvBUf,IAAwBgB,2CAAxBhB,GAAwBiB,6vBCRrCD,sDAUEA,sBACFA,QAEAA,oBAAwDA,8BAAmCA,QAC3FA,gCAAiC,UAAjCA,CAAiC,eAElBA,+BAAsCA,QACjDA,6BAAqC,cAIjCA,mFAHFA,YAQJA,kBAAsB,gBACTA,gCAA2CA,QACtDA,6BAAqC,iBAOjCA,yFAEDA,YAGLA,kBAAoB,yBACAA,gEAChBA,gCACFA,YAIJA,mBAAoC,6BAIhCA,sCAAeE,UAAQ,GAGvBF,gCACFA,QACAA,mCAEEA,sCAAeE,cAAY,GAI3BF,gCACFA,iBAvDAA,oDALAA,qBAAiB,sBAAjBA,CAAiB,uBAUMA,6CAA+BA,8CAGzCA,wDAIPA,mEACAA,iCAA2B,8BAMpBA,uDAOPA,uEACAA,uCAAiC,qCAMnBA,6CAA8B,kCAC9CA,8DAUFA,+CAEAA,kDAKAA,6DAA8C,6BAG9CA,mXCtCJ,SAASG,GAAaC,EAAMC,EAAQC,GAChC,QAASC,KAAOF,EACZ,GAAIA,EAAOG,eAAeD,GAAM,CAC5B,MAAME,EAAQJ,EAAOE,GACjBE,EACAL,EAAKM,YAAYH,EAAKE,EAAOH,GAAqBK,IAAIJ,GAAO,YAAc,IAG3EH,EAAKQ,eAAeL,EAE3B,CAEL,OAAOH,CACV,CAOD,SAASS,EAA6BC,EAASC,GAC3C,MAAMC,EAAaD,EAAS,GAAK,OACjCZ,GAAaW,EAAQG,MAAO,CACxB,eAAgBF,EAAS,GAAK,OAC9B,oBAAqBA,EAAS,GAAK,OACnC,8BAA+BA,EAAS,GAAK,cAC7C,cAAeC,EACf,kBAAmBA,EACnB,sBAAuBA,EACvB,mBAAoBA,GAE3B,CAQD,SAASE,GAAiBJ,EAASC,EAAQT,GACvCH,GAAaW,EAAQG,MAAO,CACxBE,SAAUJ,EAAS,GAAK,QACxBK,IAAKL,EAAS,GAAK,IACnBM,QAASN,EAAS,GAAK,IACvBO,KAAMP,EAAS,GAAK,UACrBT,EACN,CAKD,SAASiB,GAAkB3D,EAAW4D,GAClC,OAAOA,GAAwC,QAApBA,EACrB5D,EAAY,IAAM4D,EAClB5D,CACT,CAUD,SAAS6D,GAAsBhB,GAE3B,MAAMiB,EAAajB,EAAMkB,cAAcC,QAAQ,OAAQ,EAAK,EAAI,IAChE,OAAOC,WAAWpB,GAASiB,CAC9B,CAmBD,SAASI,GAAsBC,EAAeC,GAE1C,OADcD,EAAcE,iBAAiBD,GAChCE,MAAM,KAAKC,IAAIC,GAAQA,EAAKrC,OAC5C,CAUD,SAASsC,GAAqBvB,GAC1B,MAAMwB,EAAaxB,EAAQyB,wBAK3B,MAAO,CACHnB,IAAKkB,EAAWlB,IAChBoB,MAAOF,EAAWE,MAClBC,OAAQH,EAAWG,OACnBnB,KAAMgB,EAAWhB,KACjBoB,MAAOJ,EAAWI,MAClBC,OAAQL,EAAWK,OACnBC,EAAGN,EAAWM,EACdC,EAAGP,EAAWO,EAErB,CAOD,SAASC,GAAmBR,EAAYM,EAAGC,GACvC,MAAQzB,MAAKqB,SAAQnB,OAAMkB,SAAUF,EACrC,OAAOO,GAAKzB,GAAOyB,GAAKJ,GAAUG,GAAKtB,GAAQsB,GAAKJ,CACvD,CAOD,SAASO,EAAiBT,EAAYlB,EAAKE,GACvCgB,EAAWlB,KAAOA,EAClBkB,EAAWG,OAASH,EAAWlB,IAAMkB,EAAWK,OAChDL,EAAWhB,MAAQA,EACnBgB,EAAWE,MAAQF,EAAWhB,KAAOgB,EAAWI,KACnD,CAQD,SAASM,GAAwBC,EAAMC,EAAWC,EAAUC,GACxD,MAAQhC,MAAKoB,QAAOC,SAAQnB,OAAMoB,QAAOC,UAAWM,EAC9CI,EAAaX,EAAQQ,EACrBI,EAAaX,EAASO,EAC5B,OAAQE,EAAWhC,EAAMkC,GACrBF,EAAWX,EAASa,GACpBH,EAAW7B,EAAO+B,GAClBF,EAAWX,EAAQa,CAC1B,CAUD,MAAME,GACF7D,YAAY8D,GACR5D,KAAK4D,UAAYA,EAEjB5D,KAAK6D,UAAY,IAAIC,GACxB,CAEDC,QACI/D,KAAK6D,UAAUE,OAClB,CAEDC,MAAMC,GACFjE,KAAK+D,QACL/D,KAAK6D,UAAUK,IAAIlE,KAAK4D,UAAW,CAC/BO,eAAgBnE,KAAKoE,8BAEzBH,EAASI,QAAQnD,IACblB,KAAK6D,UAAUK,IAAIhD,EAAS,CACxBiD,eAAgB,CAAE3C,IAAKN,EAAQoD,UAAW5C,KAAMR,EAAQqD,YACxD7B,WAAYD,GAAqBvB,IAFrC,EAKP,CAEDsD,aAAaC,GACT,MAAMC,KAASC,MAAgBF,GACzBG,EAAiB5E,KAAK6D,UAAUgB,IAAIH,GAC1C,IAAKE,EACD,OAAO,KAEX,MAAMT,EAAiBS,EAAeT,eACtC,IAAIW,EACAC,EACJ,GAAIL,IAAW1E,KAAK4D,UAAW,CAC3B,MAAMoB,EAAyBhF,KAAKoE,4BACpCU,EAASE,EAAuBxD,IAChCuD,EAAUC,EAAuBtD,IACpC,MAEGoD,EAASJ,EAAOJ,UAChBS,EAAUL,EAAOH,WAErB,MAAMU,EAAgBd,EAAe3C,IAAMsD,EACrCI,EAAiBf,EAAezC,KAAOqD,EAG7C,YAAKlB,UAAUQ,QAAQ,CAAC9C,EAAU4D,KAC1B5D,EAASmB,YAAcgC,IAAWS,GAAQT,EAAOU,SAASD,IAC1DhC,EAAiB5B,EAASmB,WAAYuC,EAAeC,EAArC,GAGxBf,EAAe3C,IAAMsD,EACrBX,EAAezC,KAAOqD,EACf,CAAEvD,IAAKyD,EAAevD,KAAMwD,EACtC,CAODd,4BACI,MAAO,CAAE5C,IAAK6D,OAAOC,QAAS5D,KAAM2D,OAAOE,QAC9C,EAWL,SAASC,GAAcL,GACnB,MAAMM,EAAQN,EAAKO,WAAU,GACvBC,EAAoBF,EAAMG,iBAAiB,QAC3CC,EAAWV,EAAKU,SAAS9D,cAE/B0D,EAAMK,gBAAgB,MACtB,QAASC,EAAI,EAAGA,EAAIJ,EAAkBK,OAAQD,IAC1CJ,EAAkBI,GAAGD,gBAAgB,MAEzC,MAAiB,WAAbD,EACAI,GAAmBd,EAAMM,IAEP,UAAbI,GAAqC,WAAbA,GAAsC,aAAbA,IACtDK,GAAkBf,EAAMM,GAE5BU,GAAa,SAAUhB,EAAMM,EAAOQ,IACpCE,GAAa,0BAA2BhB,EAAMM,EAAOS,IAC9CT,CACV,CAED,SAASU,GAAaC,EAAUjB,EAAMM,EAAOY,GACzC,MAAMC,EAAqBnB,EAAKS,iBAAiBQ,GACjD,GAAIE,EAAmBN,OAAQ,CAC3B,MAAMO,EAAgBd,EAAMG,iBAAiBQ,GAC7C,QAASL,EAAI,EAAGA,EAAIO,EAAmBN,OAAQD,IAC3CM,EAASC,EAAmBP,GAAIQ,EAAcR,GAErD,CACJ,CAED,IAAIS,GAAgB,EAEpB,SAASN,GAAkBzF,EAAQgF,GAEZ,SAAfA,EAAM9F,OACN8F,EAAM5E,MAAQJ,EAAOI,OAKN,UAAf4E,EAAM9F,MAAoB8F,EAAMrD,OAChCqD,EAAMrD,KAAQ,aAAYqD,EAAMrD,QAAQoE,OAE/C,CAED,SAASP,GAAmBxF,EAAQgF,GAChC,MAAMgB,EAAUhB,EAAMiB,WAAW,MACjC,GAAID,EAGA,IACIA,EAAQE,UAAUlG,EAAQ,EAAG,EAExB,CADR,MACQ,CAEhB,CAUD,MAAMmG,IAA8BC,QAAgC,CAAEC,SAAS,IAEzEC,IAA6BF,QAAgC,CAAEC,SAAS,IASxEE,GAA0B,IAAIC,IAAI,CAEpC,aAKJ,MAAMC,GACFpH,YAAYoB,EAASiG,EAASvD,EAAWwD,EAASC,EAAgBC,GAC9DtH,KAAKmH,QAAUA,EACfnH,KAAK4D,UAAYA,EACjB5D,KAAKoH,QAAUA,EACfpH,KAAKqH,eAAiBA,EACtBrH,KAAKsH,kBAAoBA,EAOzBtH,KAAKuH,kBAAoB,CAAEvE,EAAG,EAAGC,EAAG,GAEpCjD,KAAKwH,iBAAmB,CAAExE,EAAG,EAAGC,EAAG,GAKnCjD,KAAKyH,qBAAsB,EAE3BzH,KAAK0H,YAAc,IAAIC,IAEvB3H,KAAK4H,yBAA2BC,WAEhC7H,KAAK8H,uBAAyBD,WAE9B7H,KAAK+H,oBAAsBF,WAE3B7H,KAAKgI,oBAAsBH,WAE3B7H,KAAKiI,iBAAmB,KAExBjI,KAAKkI,4BAA6B,EAElClI,KAAKmI,SAAW,GAEhBnI,KAAKoI,iBAAmB,IAAInB,IAE5BjH,KAAKqI,WAAa,MAKlBrI,KAAKsI,eAAiB,EACtBtI,KAAKuI,WAAY,EAEjBvI,KAAKwI,cAAgB,IAAIb,IAEzB3H,KAAKyI,QAAU,IAAId,IAEnB3H,KAAK0I,SAAW,IAAIf,IAEpB3H,KAAK2I,MAAQ,IAAIhB,IAEjB3H,KAAK4I,QAAU,IAAIjB,IAEnB3H,KAAK6I,OAAS,IAAIlB,IAElB3H,KAAK8I,QAAU,IAAInB,IAKnB3H,KAAK+I,MAAQ/I,KAAK0H,YAElB1H,KAAKgJ,aAAgBvE,IAGjB,GAFAzE,KAAKwI,cAAcS,OAEfjJ,KAAKmI,SAASnC,OAAQ,CACtB,MAAMkD,EAAelJ,KAAKmJ,iBAAiB1E,GACvCyE,IAAiBlJ,KAAKoI,iBAAiBrH,IAAImI,KAAkBlJ,KAAKoJ,UAClEpJ,KAAKqJ,wBAAwBH,EAAczE,EAElD,MACSzE,KAAKoJ,UACXpJ,KAAKqJ,wBAAwBrJ,KAAKsJ,aAAc7E,EAAhD,EAIRzE,KAAKuJ,aAAgB9E,IACjB,MAAM+E,EAAkBxJ,KAAKyJ,0BAA0BhF,GACvD,IAAKzE,KAAKyH,oBAAqB,CAQ3B,GAPkBiC,KAAKC,IAAIH,EAAgBxG,EAAIhD,KAAK4J,sBAAsB5G,GACxD0G,KAAKC,IAAIH,EAAgBvG,EAAIjD,KAAK4J,sBAAsB3G,IACzBjD,KAAKmH,QAAQ0C,mBAKzC,CACjB,MAAMC,EAAiBC,KAAKC,OAAShK,KAAKiK,eAAiBjK,KAAKkK,mBAAmBzF,GAC7E0F,EAAYnK,KAAKoK,eACvB,IAAKN,EAED,YADA9J,KAAKqK,iBAAiB5F,KAMrB0F,IAAeA,EAAUG,eAAiBH,EAAUI,iBAGrD9F,EAAM+F,iBACNxK,KAAKyH,qBAAsB,EAC3BzH,KAAKoH,QAAQqD,IAAI,IAAMzK,KAAK0K,mBAAmBjG,IAEtD,CACD,MACH,CAIDA,EAAM+F,iBACN,MAAMG,EAA6B3K,KAAK4K,+BAA+BpB,GAIvE,GAHAxJ,KAAK6K,WAAY,EACjB7K,KAAK8K,0BAA4BtB,EACjCxJ,KAAK+K,6BAA6BJ,GAC9B3K,KAAKoK,eACLpK,KAAKgL,2BAA2BL,EAA4BnB,OAE3D,CAGD,MAAMyB,EAASjL,KAAKkL,kBAAoBlL,KAAKmL,mBAAqBnL,KAAK4J,sBACjEwB,EAAkBpL,KAAKwH,iBAC7B4D,EAAgBpI,EAAI2H,EAA2B3H,EAAIiI,EAAOjI,EAAIhD,KAAKuH,kBAAkBvE,EACrFoI,EAAgBnI,EAAI0H,EAA2B1H,EAAIgI,EAAOhI,EAAIjD,KAAKuH,kBAAkBtE,EACrFjD,KAAKqL,2BAA2BD,EAAgBpI,EAAGoI,EAAgBnI,EACtE,CAIGjD,KAAK0H,YAAY4D,UAAUtF,QAC3BhG,KAAKoH,QAAQqD,IAAI,KACbzK,KAAK0H,YAAYuB,KAAK,CAClBxI,OAAQT,KACRwJ,gBAAiBmB,EACjBlG,QACA8G,SAAUvL,KAAKwL,iBAAiBb,GAChCc,MAAOzL,KAAK0L,wBALhB,EADJ,EAYR1L,KAAK2L,WAAclH,IACfzE,KAAKqK,iBAAiB5F,EAAtB,EAGJzE,KAAK4L,iBAAoBnH,IACrB,GAAIzE,KAAKmI,SAASnC,OAAQ,CACtB,MAAMkD,EAAelJ,KAAKmJ,iBAAiB1E,GACvCyE,IAAiBlJ,KAAKoI,iBAAiBrH,IAAImI,KAAkBlJ,KAAKoJ,UAClE3E,EAAM+F,gBAEb,MACSxK,KAAKoJ,UAGX3E,EAAM+F,gBAAN,EAGRxK,KAAK6L,gBAAgB3K,GAAS4K,WAAW3E,EAAQ4E,eAAiB,MAClE/L,KAAKgM,iBAAmB,IAAIrI,GAAsBC,GAClD0D,EAAkB2E,iBAAiBjM,KACtC,CAEGoJ,eACA,OAAOpJ,KAAKuI,cAAgBvI,KAAKoK,iBAAkBpK,KAAKoK,eAAehB,SAC1E,CACGA,aAASvI,GACT,MAAMqL,KAAWC,MAAsBtL,GACnCqL,IAAalM,KAAKuI,YAClBvI,KAAKuI,UAAY2D,EACjBlM,KAAKoM,gCACLpM,KAAKmI,SAAS9D,QAAQgI,GAAUpL,EAA6BoL,EAAQH,IAE5E,CAKDI,wBACI,OAAOtM,KAAKuM,YACf,CAEDC,iBACI,OAAOxM,KAAKsJ,YACf,CAKDmD,oBACI,OAAOzM,KAAKsK,aAAetK,KAAKsM,wBAA0BtM,KAAKwM,gBAClE,CAEDE,YAAYC,GACR3M,KAAKmI,SAAWwE,EAAQpK,IAAI8J,MAAUO,MAAcP,IACpDrM,KAAKmI,SAAS9D,QAAQgI,GAAUpL,EAA6BoL,EAAQrM,KAAKoJ,WAC1EpJ,KAAKoM,gCAKL,MAAMS,EAAkB,IAAI5F,IAC5B,YAAKmB,iBAAiB/D,QAAQgI,IACtBrM,KAAKmI,SAASnG,QAAQqK,IAAU,GAChCQ,EAAgBC,IAAIT,EAApB,GAGRrM,KAAKoI,iBAAmByE,EACjB7M,IACV,CAKD+M,oBAAoBC,GAChB,YAAKC,iBAAmBD,EACjBhN,IACV,CAKDkN,wBAAwBF,GACpB,YAAKG,qBAAuBH,EACrBhN,IACV,CAMD6L,gBAAgBuB,GACZ,MAAMlM,KAAU0L,MAAcQ,GAC9B,OAAIlM,IAAYlB,KAAKsJ,eACbtJ,KAAKsJ,cACLtJ,KAAKqN,4BAA4BrN,KAAKsJ,cAE1CtJ,KAAKoH,QAAQkG,kBAAkB,KAC3BpM,EAAQqM,iBAAiB,YAAavN,KAAKgJ,aAAcjC,IACzD7F,EAAQqM,iBAAiB,aAAcvN,KAAKgJ,aAAcpC,IAC1D1F,EAAQqM,iBAAiB,YAAavN,KAAK4L,iBAAkB7E,GAA7D,GAEJ/G,KAAKwN,uBAAoBC,EACzBzN,KAAKsJ,aAAepI,UAEbwM,WAAe,KAAe1N,KAAKsJ,wBAAwBoE,aAClE1N,KAAK2N,iBAAmB3N,KAAKsJ,aAAasE,iBAEvC5N,IACV,CAID6N,oBAAoBC,GAChB,YAAK7F,iBAAmB6F,KAAkBlB,MAAckB,GAAmB,KAC3E9N,KAAKgI,oBAAoB+F,cACrBD,IACA9N,KAAKgI,oBAAsBhI,KAAKqH,eAC3B2G,OAAO,IACPC,UAAU,IAAMjO,KAAKkO,mCAEvBlO,IACV,CAED8L,WAAWqC,GACP,YAAKC,eAAiBD,EACfnO,IACV,CAEDqO,UACIrO,KAAKqN,4BAA4BrN,KAAKsJ,cAGlCtJ,KAAKsK,cAGLtK,KAAKsJ,cAAcgF,SAEvBtO,KAAKuO,SAASD,SACdtO,KAAKwO,kBACLxO,KAAKyO,sBACLzO,KAAKsH,kBAAkBoH,eAAe1O,MACtCA,KAAK2O,uBACL3O,KAAKwI,cAAcoG,WACnB5O,KAAKyI,QAAQmG,WACb5O,KAAK0I,SAASkG,WACd5O,KAAK2I,MAAMiG,WACX5O,KAAK4I,QAAQgG,WACb5O,KAAK6I,OAAO+F,WACZ5O,KAAK8I,QAAQ8F,WACb5O,KAAK0H,YAAYkH,WACjB5O,KAAKmI,SAAW,GAChBnI,KAAKoI,iBAAiBrE,QACtB/D,KAAKoK,oBAAiBqD,EACtBzN,KAAKgI,oBAAoB+F,cACzB/N,KAAKgM,iBAAiBjI,QACtB/D,KAAKiI,iBACDjI,KAAKsJ,aACDtJ,KAAK2N,iBACD3N,KAAKmN,qBACDnN,KAAKiN,iBACDjN,KAAKuO,QACDvO,KAAKoO,eACD,IAC/B,CAED9D,aACI,OAAOtK,KAAKyH,qBAAuBzH,KAAKsH,kBAAkBgD,WAAWtK,KACxE,CAED6O,QACI7O,KAAKsJ,aAAajI,MAAMrD,UAAYgC,KAAKwN,mBAAqB,GAC9DxN,KAAKwH,iBAAmB,CAAExE,EAAG,EAAGC,EAAG,GACnCjD,KAAKuH,kBAAoB,CAAEvE,EAAG,EAAGC,EAAG,EACvC,CAKD6L,cAAczC,IACLrM,KAAKoI,iBAAiBrH,IAAIsL,IAAWrM,KAAKmI,SAASnG,QAAQqK,IAAU,IACtErM,KAAKoI,iBAAiB0E,IAAIT,GAC1BpL,EAA6BoL,GAAQ,GAE5C,CAKD0C,aAAa1C,GACLrM,KAAKoI,iBAAiBrH,IAAIsL,KAC1BrM,KAAKoI,iBAAiB4G,OAAO3C,GAC7BpL,EAA6BoL,EAAQrM,KAAKoJ,UAEjD,CAED6F,cAAcC,GACV,YAAK7G,WAAa6G,EACXlP,IACV,CAEDmP,mBAAmBhF,GACfnK,KAAKoK,eAAiBD,CACzB,CAIDiF,sBACI,MAAM7N,EAAWvB,KAAKsK,aAAetK,KAAKwH,iBAAmBxH,KAAKuH,kBAClE,MAAO,CAAEvE,EAAGzB,EAASyB,EAAGC,EAAG1B,EAAS0B,EACvC,CAKDoM,oBAAoBxO,GAChB,YAAK2G,iBAAmB,CAAExE,EAAG,EAAGC,EAAG,GACnCjD,KAAKuH,kBAAkBvE,EAAInC,EAAMmC,EACjChD,KAAKuH,kBAAkBtE,EAAIpC,EAAMoC,EAC5BjD,KAAKoK,gBACNpK,KAAKqL,2BAA2BxK,EAAMmC,EAAGnC,EAAMoC,GAE5CjD,IACV,CAKDsP,qBAAqBzO,GACjB,YAAK0O,kBAAoB1O,EAClBb,IACV,CAEDwP,+BACI,MAAMjO,EAAWvB,KAAK8K,0BAClBvJ,GAAYvB,KAAKoK,gBACjBpK,KAAKgL,2BAA2BhL,KAAK4K,+BAA+BrJ,GAAWA,EAEtF,CAEDoN,uBACI3O,KAAK4H,yBAAyBmG,cAC9B/N,KAAK8H,uBAAuBiG,cAC5B/N,KAAK+H,oBAAoBgG,aAC5B,CAEDS,kBACIxO,KAAKyP,UAAUnB,SACftO,KAAK0P,aAAaC,UAClB3P,KAAKyP,SAAWzP,KAAK0P,YAAc,IACtC,CAEDjB,sBACIzO,KAAKuM,cAAc+B,SACnBtO,KAAK4P,iBAAiBD,UACtB3P,KAAKuM,aAAevM,KAAK4P,gBAAkB,IAC9C,CAKDvF,iBAAiB5F,GAKb,GAAKzE,KAAKsH,kBAAkBgD,WAAWtK,QAGvCA,KAAK2O,uBACL3O,KAAKsH,kBAAkBuI,aAAa7P,MACpCA,KAAKoM,gCACDpM,KAAKmI,WACLnI,KAAKsJ,aAAajI,MAAMyO,wBACpB9P,KAAK+P,0BAER/P,KAAKyH,qBAIV,GADAzH,KAAK0I,SAASO,KAAK,CAAExI,OAAQT,KAAMyE,UAC/BzE,KAAKoK,eAELpK,KAAKoK,eAAe4F,iBACpBhQ,KAAKiQ,+BAA+BC,KAAK,KACrClQ,KAAKmQ,sBAAsB1L,GAC3BzE,KAAKoQ,2BACLpQ,KAAKsH,kBAAkBuI,aAAa7P,KAApC,OAGH,CAIDA,KAAKuH,kBAAkBvE,EAAIhD,KAAKwH,iBAAiBxE,EACjD,MAAMwG,EAAkBxJ,KAAKyJ,0BAA0BhF,GACvDzE,KAAKuH,kBAAkBtE,EAAIjD,KAAKwH,iBAAiBvE,EACjDjD,KAAKoH,QAAQqD,IAAI,KACbzK,KAAK2I,MAAMM,KAAK,CACZxI,OAAQT,KACRuL,SAAUvL,KAAKwL,iBAAiBhC,GAChC6G,UAAW7G,EACX/E,SAJJ,GAOJzE,KAAKoQ,2BACLpQ,KAAKsH,kBAAkBuI,aAAa7P,KACvC,CACJ,CAED0K,mBAAmBjG,GACX6L,EAAa7L,KACbzE,KAAKuQ,oBAAsBxG,KAAKC,OAEpChK,KAAKoM,gCACL,MAAMoE,EAAgBxQ,KAAKoK,eAC3B,GAAIoG,EAAe,CACf,MAAMtP,EAAUlB,KAAKsJ,aACf6E,EAASjN,EAAQuP,WACjBC,EAAe1Q,KAAKuM,aAAevM,KAAK2Q,4BACxCC,EAAU5Q,KAAKuO,QAAUvO,KAAKuO,SAAWvO,KAAK4D,UAAUiN,cAAc,IAEtEC,EAAa9Q,KAAK+Q,iBAExB5C,EAAO6C,aAAaJ,EAAQ1P,GAG5BlB,KAAKwN,kBAAoBtM,EAAQG,MAAMrD,WAAa,GAGpDgC,KAAKyP,SAAWzP,KAAKiR,wBAIrB3P,GAAiBJ,GAAS,EAAO8F,IACjChH,KAAK4D,UAAUsN,KAAKC,YAAYhD,EAAOiD,aAAaV,EAAaxP,IACjElB,KAAKqR,0BAA0BlD,EAAQ2C,GAAYK,YAAYnR,KAAKyP,UACpEzP,KAAKyI,QAAQQ,KAAK,CAAExI,OAAQT,KAAMyE,UAClC+L,EAAcc,QACdtR,KAAKuR,kBAAoBf,EACzBxQ,KAAKwR,cAAgBhB,EAAciB,aAAazR,KACnD,MAEGA,KAAKyI,QAAQQ,KAAK,CAAExI,OAAQT,KAAMyE,UAClCzE,KAAKuR,kBAAoBvR,KAAKwR,mBAAgB/D,EAIlDzN,KAAKgM,iBAAiBhI,MAAMwM,EAAgBA,EAAckB,uBAAyB,GACtF,CAODrI,wBAAwBsI,EAAkBlN,GAGlCzE,KAAKoO,gBACL3J,EAAMmN,kBAEV,MAAMtH,EAAatK,KAAKsK,aAClBuH,EAAkBvB,EAAa7L,GAC/BqN,GAA0BD,GAAoC,IAAjBpN,EAAMsN,OACnD3E,EAAcpN,KAAKsJ,aACnB5E,KAASC,MAAgBF,GACzBuN,GAAoBH,GACtB7R,KAAKuQ,qBACLvQ,KAAKuQ,oBA3gBe,IA2gBiCxG,KAAKC,MACxDiI,EAAcJ,KACdK,OAAiCzN,IAAD,EAChC0N,OAAgC1N,GAWtC,GAJIC,GAAUA,EAAO0N,WAA4B,cAAf3N,EAAM9E,MACpC8E,EAAM+F,iBAGNF,GAAcwH,GAA0BE,GAAoBC,EAC5D,OAKJ,GAAIjS,KAAKmI,SAASnC,OAAQ,CACtB,MAAMqM,EAAajF,EAAY/L,MAC/BrB,KAAK+P,yBAA2BsC,EAAWvC,yBAA2B,GACtEuC,EAAWvC,wBAA0B,aACxC,CACD9P,KAAKyH,oBAAsBzH,KAAK6K,WAAY,EAG5C7K,KAAK2O,uBACL3O,KAAKmL,mBAAqBnL,KAAKsJ,aAAa3G,wBAC5C3C,KAAK4H,yBAA2B5H,KAAKsH,kBAAkBgL,YAAYrE,UAAUjO,KAAKuJ,cAClFvJ,KAAK8H,uBAAyB9H,KAAKsH,kBAAkBiL,UAAUtE,UAAUjO,KAAK2L,YAC9E3L,KAAK+H,oBAAsB/H,KAAKsH,kBAC3BkL,SAASxS,KAAK+Q,kBACd9C,UAAUwE,GAAezS,KAAK0S,gBAAgBD,IAC/CzS,KAAKiI,mBACLjI,KAAK2S,cAAgBlQ,GAAqBzC,KAAKiI,mBAKnD,MAAM2K,EAAkB5S,KAAKiN,iBAC7BjN,KAAK6S,yBACDD,GAAmBA,EAAgB5F,WAAa4F,EAAgBE,UAC1D,CAAE9P,EAAG,EAAGC,EAAG,GACXjD,KAAK+S,6BAA6B/S,KAAKmL,mBAAoBwG,EAAkBlN,GACvF,MAAM+E,EAAmBxJ,KAAK4J,sBAC1B5J,KAAK8K,0BACD9K,KAAKyJ,0BAA0BhF,GACvCzE,KAAK0L,uBAAyB,CAAE1I,EAAG,EAAGC,EAAG,GACzCjD,KAAKgT,sCAAwC,CAAEhQ,EAAGwG,EAAgBxG,EAAGC,EAAGuG,EAAgBvG,GACxFjD,KAAKiK,eAAiBF,KAAKC,MAC3BhK,KAAKsH,kBAAkB2L,cAAcjT,KAAMyE,EAC9C,CAED0L,sBAAsB1L,GAKlBnD,GAAiBtB,KAAKsJ,cAAc,EAAMtC,IAC1ChH,KAAKuO,QAAQkC,WAAWW,aAAapR,KAAKsJ,aAActJ,KAAKuO,SAC7DvO,KAAKwO,kBACLxO,KAAKyO,sBACLzO,KAAKmL,mBACDnL,KAAK2S,cACD3S,KAAKkT,aACDlT,KAAKwN,uBACDC,EAEhBzN,KAAKoH,QAAQqD,IAAI,KACb,MAAMN,EAAYnK,KAAKoK,eACjB+I,EAAehJ,EAAUsH,aAAazR,MACtCwJ,EAAkBxJ,KAAKyJ,0BAA0BhF,GACjD8G,EAAWvL,KAAKwL,iBAAiBhC,GACjC4J,EAAyBjJ,EAAUkJ,iBAAiB7J,EAAgBxG,EAAGwG,EAAgBvG,GAC7FjD,KAAK2I,MAAMM,KAAK,CAAExI,OAAQT,KAAMuL,WAAU8E,UAAW7G,EAAiB/E,UACtEzE,KAAK8I,QAAQG,KAAK,CACdqK,KAAMtT,KACNmT,eACAI,cAAevT,KAAKwR,cACpBrH,UAAWA,EACXqJ,kBAAmBxT,KAAKuR,kBACxB6B,yBACA7H,WACA8E,UAAW7G,EACX/E,UAEJ0F,EAAUsJ,KAAKzT,KAAMmT,EAAcnT,KAAKwR,cAAexR,KAAKuR,kBAAmB6B,EAAwB7H,EAAU/B,EAAiB/E,GAClIzE,KAAKoK,eAAiBpK,KAAKuR,mBAElC,CAKDvG,4BAA6BhI,IAAGC,MAAOD,EAAG0Q,EAAMzQ,EAAG0Q,IAE/C,IAAIC,EAAe5T,KAAKuR,kBAAkBsC,iCAAiC7T,KAAMgD,EAAGC,IAK/E2Q,GACD5T,KAAKoK,iBAAmBpK,KAAKuR,mBAC7BvR,KAAKuR,kBAAkB8B,iBAAiBrQ,EAAGC,KAC3C2Q,EAAe5T,KAAKuR,mBAEpBqC,GAAgBA,IAAiB5T,KAAKoK,gBACtCpK,KAAKoH,QAAQqD,IAAI,KAEbzK,KAAK6I,OAAOI,KAAK,CAAEqK,KAAMtT,KAAMmK,UAAWnK,KAAKoK,iBAC/CpK,KAAKoK,eAAe0J,KAAK9T,MAEzBA,KAAKoK,eAAiBwJ,EACtB5T,KAAKoK,eAAe2J,MAAM/T,KAAMgD,EAAGC,EAAG2Q,IAAiB5T,KAAKuR,mBAGxDqC,EAAaI,gBACXhU,KAAKwR,mBACL/D,GACNzN,KAAK4I,QAAQK,KAAK,CACdqK,KAAMtT,KACNmK,UAAWyJ,EACXT,aAAcS,EAAanC,aAAazR,OAH5C,GAQJA,KAAKsK,eACLtK,KAAKoK,eAAe6J,2BAA2BP,EAAMC,GACrD3T,KAAKoK,eAAe8J,UAAUlU,KAAMgD,EAAGC,EAAGjD,KAAK0L,wBAC3C1L,KAAKkL,kBACLlL,KAAKmU,uBAAuBnR,EAAGC,GAG/BjD,KAAKmU,uBAAuBnR,EAAIhD,KAAK6S,yBAAyB7P,EAAGC,EAAIjD,KAAK6S,yBAAyB5P,GAG9G,CAKDgO,wBACI,MAAMmD,EAAgBpU,KAAKiN,iBACrBoH,EAAerU,KAAKqU,aACpBzB,EAAkBwB,EAAgBA,EAAcpH,SAAW,KACjE,IAAIsH,EACJ,GAAI1B,GAAmBwB,EAAe,CAGlC,MAAMG,EAAWH,EAActB,UAAY9S,KAAKmL,mBAAqB,KAC/DqJ,EAAUJ,EAAcK,cAAcC,mBAAmB9B,EAAiBwB,EAAc3N,SAC9F+N,EAAQG,gBACRL,EAAUM,GAAYJ,EAASxU,KAAK4D,WACpC5D,KAAK0P,YAAc8E,EACfJ,EAActB,UACd+B,GAAiBP,EAASC,GAG1BD,EAAQjT,MAAMrD,UAAY8W,GAAa9U,KAAK4J,sBAAsB5G,EAAGhD,KAAK4J,sBAAsB3G,EAEvG,MAEGqR,EAAU9O,GAAcxF,KAAKsJ,cAC7BuL,GAAiBP,EAAStU,KAAKmL,oBAC3BnL,KAAKwN,oBACL8G,EAAQjT,MAAMrD,UAAYgC,KAAKwN,mBAGvCjN,UAAa+T,EAAQjT,MAAO,CAGxB,iBAAkB,OAElB0T,OAAU,IACVxT,SAAY,QACZC,IAAO,IACPE,KAAQ,IACR,UAAY,GAAE1B,KAAKmH,QAAQ6N,QAAU,OACtChO,IACH/F,EAA6BqT,GAAS,GACtCA,EAAQW,UAAUnI,IAAI,oBACtBwH,EAAQY,aAAa,MAAOlV,KAAKqI,YAC7BgM,IACIc,MAAMC,QAAQf,GACdA,EAAahQ,QAAQgR,GAAaf,EAAQW,UAAUnI,IAAIuI,IAGxDf,EAAQW,UAAUnI,IAAIuH,IAGvBC,CACV,CAKDrE,+BAEI,IAAKjQ,KAAK6K,UACN,OAAOyK,QAAQC,UAEnB,MAAMC,EAAkBxV,KAAKuM,aAAa5J,wBAE1C3C,KAAKyP,SAASwF,UAAUnI,IAAI,sBAE5B9M,KAAKmU,uBAAuBqB,EAAgB9T,KAAM8T,EAAgBhU,KAKlE,MAAMiU,EAl9Bd,SAASC,GAAmCxU,GACxC,MAAMiB,EAAgBwT,iBAAiBzU,GACjC0U,EAAyB1T,GAAsBC,EAAe,uBAC9D0T,EAAWD,EAAuBE,KAAKC,GAAiB,cAATA,GAAiC,QAATA,GAE7E,IAAKF,EACD,OAAO,EAIX,MAAMG,EAAgBJ,EAAuB5T,QAAQ6T,GAC/CI,EAAe/T,GAAsBC,EAAe,uBACpD+T,EAAYhU,GAAsBC,EAAe,oBACvD,OAAQN,GAAsBoU,EAAaD,IACvCnU,GAAsBqU,EAAUF,GACvC,CAm8BwBN,CAAmC1V,KAAKyP,UACzD,OAAiB,IAAbgG,EACOH,QAAQC,UAEZvV,KAAKoH,QAAQkG,kBAAkB,IAC3B,IAAIgI,QAAQC,IACf,MAAMY,EAAY1R,MACTA,MACAE,MAAgBF,KAAWzE,KAAKyP,UAAmC,cAAvBhL,EAAM2R,gBACnDpW,KAAKyP,UAAU4G,oBAAoB,gBAAiBF,GACpDZ,IACAe,aAAaC,GAAD,EAMdA,EAAUC,WAAWL,EAAoB,IAAXV,GACpCzV,KAAKyP,SAASlC,iBAAiB,gBAAiB4I,EAAhD,GAGX,CAEDxF,4BACI,MAAM8F,EAAoBzW,KAAKmN,qBACzBuJ,EAAsBD,EAAoBA,EAAkBzJ,SAAW,KAC7E,IAAI0D,EACJ,OAAIgG,GACA1W,KAAK4P,gBAAkB6G,EAAkBhC,cAAcC,mBAAmBgC,EAAqBD,EAAkBhQ,SACjHzG,KAAK4P,gBAAgB+E,gBACrBjE,EAAckE,GAAY5U,KAAK4P,gBAAiB5P,KAAK4D,YAGrD8M,EAAclL,GAAcxF,KAAKsJ,cAIrCoH,EAAYrP,MAAMsV,cAAgB,OAClCjG,EAAYuE,UAAUnI,IAAI,wBACnB4D,CACV,CAMDqC,6BAA6B6D,EAAajF,EAAkBlN,GACxD,MAAMoS,EAAgBlF,IAAqB3R,KAAKsJ,aAAe,KAAOqI,EAChEmF,EAAgBD,EAAgBA,EAAclU,wBAA0BiU,EACxEG,EAAQzG,EAAa7L,GAASA,EAAMuS,cAAc,GAAKvS,EACvDN,EAAiBnE,KAAKiX,6BAG5B,MAAO,CACHjU,EAAG8T,EAAcpV,KAAOkV,EAAYlV,MAH9BqV,EAAMG,MAAQJ,EAAcpV,KAAOyC,EAAezC,MAIxDuB,EAAG6T,EAActV,IAAMoV,EAAYpV,KAH7BuV,EAAMI,MAAQL,EAActV,IAAM2C,EAAe3C,KAK9D,CAEDiI,0BAA0BhF,GACtB,MAAMN,EAAiBnE,KAAKiX,6BACtBF,EAAQzG,EAAa7L,GAQnBA,EAAM2S,QAAQ,IAAM3S,EAAM4S,eAAe,IAAM,CAAEH,MAAO,EAAGC,MAAO,GACpE1S,EACAzB,EAAI+T,EAAMG,MAAQ/S,EAAezC,KACjCuB,EAAI8T,EAAMI,MAAQhT,EAAe3C,IAGvC,GAAIxB,KAAK2N,iBAAkB,CACvB,MAAM2J,EAAYtX,KAAK2N,iBAAiB4J,eACxC,GAAID,EAAW,CACX,MAAME,EAAWxX,KAAK2N,iBAAiB8J,iBACvCD,SAASxU,EAAIA,EACbwU,EAASvU,EAAIA,EACNuU,EAASE,gBAAgBJ,EAAUK,UAC7C,CACJ,CACD,MAAO,CAAE3U,IAAGC,IACf,CAED2H,+BAA+BmM,GAC3B,MAAMa,EAAoB5X,KAAKoK,eAAiBpK,KAAKoK,eAAeyN,SAAW,KAC/E,IAAM7U,IAAGC,KAAMjD,KAAKkL,kBACdlL,KAAKkL,kBAAkB6L,EAAO/W,KAAMA,KAAKmL,mBAAoBnL,KAAK6S,0BAClEkE,EAON,GANsB,MAAlB/W,KAAK6X,UAA0C,MAAtBD,EACzB3U,EAAIjD,KAAK4J,sBAAsB3G,GAER,MAAlBjD,KAAK6X,UAA0C,MAAtBD,KAC9B5U,EAAIhD,KAAK4J,sBAAsB5G,GAE/BhD,KAAK2S,cAAe,CACpB,MAAQ3P,EAAG8U,EAAS7U,EAAG8U,GAAY/X,KAAK6S,yBAClCmF,EAAehY,KAAK2S,eAClB7P,MAAOmV,EAAclV,OAAQmV,GAAkBlY,KAAKmY,kBACtDC,EAAOJ,EAAaxW,IAAMuW,EAC1BM,EAAOL,EAAanV,QAAUqV,EAAgBH,GAGpD/U,EAAIsV,GAAQtV,EAFCgV,EAAatW,KAAOoW,EACpBE,EAAapV,OAASqV,EAAeH,IAElD7U,EAAIqV,GAAQrV,EAAGmV,EAAMC,EACxB,CACD,MAAO,CAAErV,IAAGC,IACf,CAED8H,6BAA6BwN,GACzB,MAAQvV,IAAGC,KAAMsV,EACX9M,EAAQzL,KAAK0L,uBACb8M,EAA0BxY,KAAKgT,sCAE/ByF,EAAU/O,KAAKC,IAAI3G,EAAIwV,EAAwBxV,GAC/C0V,EAAUhP,KAAKC,IAAI1G,EAAIuV,EAAwBvV,GAKrD,OAAIwV,EAAUzY,KAAKmH,QAAQwR,kCACvBlN,EAAMzI,EAAIA,EAAIwV,EAAwBxV,EAAI,GAAI,EAC9CwV,EAAwBxV,EAAIA,GAE5B0V,EAAU1Y,KAAKmH,QAAQwR,kCACvBlN,EAAMxI,EAAIA,EAAIuV,EAAwBvV,EAAI,GAAI,EAC9CuV,EAAwBvV,EAAIA,GAEzBwI,CACV,CAEDW,gCACI,IAAKpM,KAAKsJ,eAAiBtJ,KAAKmI,SAC5B,OAEJ,MAAMyQ,EAAe5Y,KAAKmI,SAASnC,OAAS,IAAMhG,KAAKsK,aACnDsO,IAAiB5Y,KAAKkI,6BACtBlI,KAAKkI,2BAA6B0Q,EAClC3X,EAA6BjB,KAAKsJ,aAAcsP,GAEvD,CAEDvL,4BAA4BnM,GACxBA,EAAQmV,oBAAoB,YAAarW,KAAKgJ,aAAcjC,IAC5D7F,EAAQmV,oBAAoB,aAAcrW,KAAKgJ,aAAcpC,IAC7D1F,EAAQmV,oBAAoB,YAAarW,KAAK4L,iBAAkB7E,GACnE,CAMDsE,2BAA2BrI,EAAGC,GAC1B,MAAMjF,EAAY8W,GAAa9R,EAAGC,GAC5B4V,EAAS7Y,KAAKsJ,aAAajI,MAIH,MAA1BrB,KAAKwN,oBACLxN,KAAKwN,kBACDqL,EAAO7a,WAAiC,QAApB6a,EAAO7a,UAAsB6a,EAAO7a,UAAY,IAK5E6a,EAAO7a,UAAY2D,GAAkB3D,EAAWgC,KAAKwN,kBACxD,CAMD2G,uBAAuBnR,EAAGC,GAGtB,MAAMrB,EAAmB5B,KAAKiN,kBAAkBD,cAAWS,EAAYzN,KAAKwN,kBACtExP,EAAY8W,GAAa9R,EAAGC,GAClCjD,KAAKyP,SAASpO,MAAMrD,UAAY2D,GAAkB3D,EAAW4D,EAChE,CAKD4J,iBAAiBsN,GACb,MAAMC,EAAiB/Y,KAAK4J,sBAC5B,OAAImP,EACO,CAAE/V,EAAG8V,EAAgB9V,EAAI+V,EAAe/V,EAAGC,EAAG6V,EAAgB7V,EAAI8V,EAAe9V,GAErF,CAAED,EAAG,EAAGC,EAAG,EACrB,CAEDmN,2BACIpQ,KAAK2S,cAAgB3S,KAAKkT,kBAAezF,EACzCzN,KAAKgM,iBAAiBjI,OACzB,CAKDmK,iCACI,IAAMlL,IAAGC,KAAMjD,KAAKuH,kBACpB,GAAW,IAANvE,GAAiB,IAANC,GAAYjD,KAAKsK,eAAiBtK,KAAKiI,iBACnD,OAGJ,MAAM2O,EAAc5W,KAAKsJ,aAAa3G,wBAChCqV,EAAehY,KAAKiI,iBAAiBtF,wBAG3C,GAA4B,IAAvBqV,EAAalV,OAAuC,IAAxBkV,EAAajV,QACnB,IAAtB6T,EAAY9T,OAAsC,IAAvB8T,EAAY7T,OACxC,OAEJ,MAAMiW,EAAehB,EAAatW,KAAOkV,EAAYlV,KAC/CuX,EAAgBrC,EAAYhU,MAAQoV,EAAapV,MACjDsW,EAAclB,EAAaxW,IAAMoV,EAAYpV,IAC7C2X,EAAiBvC,EAAY/T,OAASmV,EAAanV,OAGrDmV,EAAalV,MAAQ8T,EAAY9T,OAC7BkW,EAAe,IACfhW,GAAKgW,GAELC,EAAgB,IAChBjW,GAAKiW,IAITjW,EAAI,EAIJgV,EAAajV,OAAS6T,EAAY7T,QAC9BmW,EAAc,IACdjW,GAAKiW,GAELC,EAAiB,IACjBlW,GAAKkW,IAITlW,EAAI,GAEJD,IAAMhD,KAAKuH,kBAAkBvE,GAAKC,IAAMjD,KAAKuH,kBAAkBtE,IAC/DjD,KAAKqP,oBAAoB,CAAEpM,IAAGD,KAErC,CAEDkH,mBAAmBzF,GACf,MAAM5D,EAAQb,KAAKsI,eACnB,MAAqB,iBAAVzH,EACAA,EAEFyP,EAAa7L,GACX5D,EAAMuY,MAEVvY,EAAQA,EAAMwY,MAAQ,CAChC,CAED3G,gBAAgBjO,GACZ,MAAM6U,EAAmBtZ,KAAKgM,iBAAiBxH,aAAaC,GAC5D,GAAI6U,EAAkB,CAClB,MAAM5U,KAASC,MAAgBF,GAG3BzE,KAAK2S,eACLjO,IAAW1E,KAAKiI,kBAChBvD,EAAOU,SAASpF,KAAKiI,mBACrB9E,EAAiBnD,KAAK2S,cAAe2G,EAAiB9X,IAAK8X,EAAiB5X,MAEhF1B,KAAK4J,sBAAsB5G,GAAKsW,EAAiB5X,KACjD1B,KAAK4J,sBAAsB3G,GAAKqW,EAAiB9X,IAG5CxB,KAAKoK,iBACNpK,KAAKwH,iBAAiBxE,GAAKsW,EAAiB5X,KAC5C1B,KAAKwH,iBAAiBvE,GAAKqW,EAAiB9X,IAC5CxB,KAAKqL,2BAA2BrL,KAAKwH,iBAAiBxE,EAAGhD,KAAKwH,iBAAiBvE,GAEtF,CACJ,CAEDgU,6BACI,OAAQjX,KAAKgM,iBAAiBnI,UAAUgB,IAAI7E,KAAK4D,YAAYO,gBACzDnE,KAAKgM,iBAAiB5H,2BAC7B,CAOD2M,iBACI,YAA+BtD,IAA3BzN,KAAKuZ,oBACLvZ,KAAKuZ,qBAAoBxI,MAAe/Q,KAAKsJ,eAE1CtJ,KAAKuZ,iBACf,CAEDlI,0BAA0BmI,EAAe1I,GACrC,MAAM2I,EAAmBzZ,KAAKuP,mBAAqB,SACnD,GAAyB,WAArBkK,EACA,OAAOD,EAEX,GAAyB,WAArBC,EAA+B,CAC/B,MAAMC,EAAc1Z,KAAK4D,UAIzB,OAAQkN,GACJ4I,EAAYC,mBACZD,EAAYE,yBACZF,EAAYG,sBACZH,EAAYI,qBACZJ,EAAYxI,IACnB,CACD,SAAOtE,MAAc6M,EACxB,CAEDtB,kBAGI,QAAKnY,KAAKkT,eAAkBlT,KAAKkT,aAAapQ,QAAU9C,KAAKkT,aAAanQ,UACtE/C,KAAKkT,aAAelT,KAAKyP,SACnBzP,KAAKyP,SAAS9M,wBACd3C,KAAKmL,oBAERnL,KAAKkT,YACf,CAED/J,iBAAiB1E,GACb,OAAOzE,KAAKmI,SAAS2N,KAAKzJ,GACf5H,EAAMC,SAAWD,EAAMC,SAAW2H,GAAUA,EAAOjH,SAASX,EAAMC,SAEhF,EAOL,SAASoQ,GAAa9R,EAAGC,GAGrB,MAAQ,eAAcyG,KAAKqQ,MAAM/W,SAAS0G,KAAKqQ,MAAM9W,UACxD,CAED,SAASqV,GAAQzX,EAAOmZ,EAAKC,GACzB,OAAOvQ,KAAKuQ,IAAID,EAAKtQ,KAAKsQ,IAAIC,EAAKpZ,GACtC,CAED,SAASyP,EAAa7L,GAIlB,MAAyB,MAAlBA,EAAM9E,KAAK,EACrB,CAKD,SAASiV,GAAYJ,EAAS5Q,GAC1B,MAAMsW,EAAY1F,EAAQ0F,UAC1B,GAAyB,IAArBA,EAAUlU,QAAgBkU,EAAU,GAAGC,WAAavW,EAAUwW,aAC9D,OAAOF,EAAU,GAErB,MAAMG,EAAUzW,EAAU0W,cAAc,OACxCJ,SAAU7V,QAAQc,GAAQkV,EAAQlJ,YAAYhM,IACvCkV,CACV,CAMD,SAASxF,GAAiBnQ,EAAQ6V,GAC9B7V,EAAOrD,MAAMyB,MAAS,GAAEyX,EAAWzX,UACnC4B,EAAOrD,MAAM0B,OAAU,GAAEwX,EAAWxX,WACpC2B,EAAOrD,MAAMrD,UAAY8W,GAAayF,EAAW7Y,KAAM6Y,EAAW/Y,IACrE,CAeD,SAASgZ,GAAgBvc,EAAOwc,EAAWC,GACvC,MAAMC,EAAOC,EAAMH,EAAWxc,EAAM+H,OAAS,GACvC6U,EAAKD,EAAMF,EAASzc,EAAM+H,OAAS,GACzC,GAAI2U,IAASE,EACT,OAEJ,MAAMnW,EAASzG,EAAM0c,GACflP,EAAQoP,EAAKF,GAAO,EAAK,EAC/B,QAAS5U,EAAI4U,EAAM5U,IAAM8U,EAAI9U,GAAK0F,EAC9BxN,EAAM8H,GAAK9H,EAAM8H,EAAI0F,GAEzBxN,EAAM4c,GAAMnW,CACf,CA+BD,SAASkW,EAAM/Z,EAAOoZ,GAClB,OAAOvQ,KAAKuQ,IAAI,EAAGvQ,KAAKsQ,IAAIC,EAAKpZ,GACpC,CAcD,MAAMia,GACFhb,YAAYib,EAAUzT,GAClBtH,KAAK+a,SAAWA,EAChB/a,KAAKsH,kBAAoBA,EAEzBtH,KAAKgb,eAAiB,GAEtBhb,KAAKib,YAAc,WAMnBjb,KAAKkb,cAAgB,CACjBC,KAAM,KACN1P,MAAO,EACP2P,UAAU,EAEjB,CAKD9J,MAAM+J,GACFrb,KAAKsb,UAAUD,EAClB,CAQDjd,KAAKkV,EAAM/P,EAAUC,EAAU+X,GAC3B,MAAMC,EAAWxb,KAAKgb,eAChBS,EAAWzb,KAAK0b,iCAAiCpI,EAAM/P,EAAUC,EAAU+X,GACjF,IAAiB,IAAbE,GAAmBD,EAASxV,OAAS,EACrC,OAAO,KAEX,MAAM2V,EAAoC,eAArB3b,KAAKib,YACpB9H,EAAeqI,EAASI,UAAUC,GAAeA,EAAYV,OAAS7H,GACtEwI,EAAuBN,EAASC,GAEhCM,EAAcD,EAAqBpZ,WACnC+I,EAAQ0H,EAAesI,EAAW,GAAI,EAEtCO,EAAahc,KAAKic,iBAJAT,EAASrI,GAAczQ,WAIWqZ,EAAatQ,GAEjEyQ,EAAgBlc,KAAKmc,oBAAoBhJ,EAAcqI,EAAU/P,GAGjE2Q,EAAWZ,EAASa,QAE1B7B,UAAgBgB,EAAUrI,EAAcsI,GACxCD,EAASnX,QAAQ,CAACiY,EAASC,MAEvB,GAAIH,EAASG,MAAWD,EACpB,OAEJ,MAAME,GAAgBF,EAAQnB,OAAS7H,EACjCrI,GAASuR,GAAgBR,EAAaE,EACtCO,GAAkBD,GAClBlJ,EAAKhH,wBACLgQ,EAAQnB,KAAK3O,iBAEnB8P,EAAQrR,QAAUA,GAKd0Q,GAGAc,GAAgBpb,MAAMrD,UAAY2D,GAAmB,eAAc+H,KAAKqQ,MAAMuC,EAAQrR,mBAAoBqR,EAAQ1a,kBAClHuB,EAAiBmZ,EAAQ5Z,WAAY,EAAGuI,MAGxCwR,GAAgBpb,MAAMrD,UAAY2D,GAAmB,kBAAiB+H,KAAKqQ,MAAMuC,EAAQrR,gBAAiBqR,EAAQ1a,kBAClHuB,EAAiBmZ,EAAQ5Z,WAAYuI,GAAQ,GAA7B,GAIxBjL,KAAKkb,cAAcE,SAAWlY,GAAmB6Y,EAAaxY,EAAUC,GACxExD,KAAKkb,cAAcC,KAAOW,EAAqBX,KAC/Cnb,KAAKkb,cAAczP,MAAQkQ,EAAeJ,EAAavY,EAAIuY,EAAatY,EACjE,CAAEsQ,cAAeJ,EAAcA,aAAcsI,EACvD,CASD1H,MAAMT,EAAM/P,EAAUC,EAAU+Y,GAC5B,MAAMd,EAAoB,MAATc,GAAiBA,EAAQ,EAGlCvc,KAAK0b,iCAAiCpI,EAAM/P,EAAUC,GACxD+Y,EACAG,EAAmB1c,KAAK2c,kBACxBxJ,EAAeuJ,EAAiB1a,QAAQsR,GACxC5C,EAAc4C,EAAKhH,wBACzB,IAAIsQ,EAAuBF,EAAiBjB,GAqB5C,GAjBImB,IAAyBtJ,IACzBsJ,EAAuBF,EAAiBjB,EAAW,KAIlDmB,IACY,MAAZnB,IAAiC,IAAbA,GAAmBA,EAAWiB,EAAiB1W,OAAS,IAC7EhG,KAAK6c,yBAAyBtZ,EAAUC,KACxCoZ,EAAuBF,EAAiB,IAIxCvJ,GAAe,GACfuJ,EAAiBI,OAAO3J,EAAc,GAItCyJ,IAAyB5c,KAAKsH,kBAAkBgD,WAAWsS,GAAuB,CAClF,MAAM1b,EAAU0b,EAAqBpQ,iBACrCtL,EAAQ6b,cAAc/L,aAAaN,EAAaxP,GAChDwb,EAAiBI,OAAOrB,EAAU,EAAGnI,EACxC,MAEG1G,QAAc5M,KAAK+a,UAAU5J,YAAYT,GACzCgM,EAAiBM,KAAK1J,GAG1B5C,EAAYrP,MAAMrD,UAAY,GAI9BgC,KAAKid,qBACR,CAED3B,UAAUD,GACNrb,KAAK2c,kBAAoBtB,EAAMgB,QAC/Brc,KAAKid,qBACR,CAEDC,kBAAkBC,GACdnd,KAAKod,eAAiBD,CACzB,CAEDtO,QAEI7O,KAAK2c,kBAAkBtY,QAAQiP,IAC3B,MAAMlG,EAAckG,EAAK9G,iBACzB,GAAIY,EAAa,CACb,MAAMxL,EAAmB5B,KAAKgb,eAAelF,KAAKuH,GAAKA,EAAElC,OAAS7H,IAAO1R,iBACzEwL,EAAY/L,MAAMrD,UAAY4D,GAAoB,EACrD,IAEL5B,KAAKgb,eAAiB,GACtBhb,KAAK2c,kBAAoB,GACzB3c,KAAKkb,cAAcC,KAAO,KAC1Bnb,KAAKkb,cAAczP,MAAQ,EAC3BzL,KAAKkb,cAAcE,UAAW,CACjC,CAKDkC,yBACI,OAAOtd,KAAK2c,iBACf,CAEDlL,aAAa6B,GAOT,OAHmC,eAArBtT,KAAKib,aAAmD,QAAnBjb,KAAKkP,UAClDlP,KAAKgb,eAAeqB,QAAQkB,UAC5Bvd,KAAKgb,gBACEY,UAAUC,GAAeA,EAAYV,OAAS7H,EAC9D,CAEDkK,eAAevY,EAAeC,GAK1BlF,KAAKgb,eAAe3W,QAAQ,EAAG3B,iBAC3BS,EAAiBT,EAAYuC,EAAeC,EAA5B,GAIpBlF,KAAKgb,eAAe3W,QAAQ,EAAG8W,WACvBnb,KAAKsH,kBAAkBgD,WAAW6Q,IAGlCA,EAAK3L,8BAAL,EAGX,CAEDyN,sBACI,MAAMtB,EAAoC,eAArB3b,KAAKib,YAC1Bjb,KAAKgb,eAAiBhb,KAAK2c,kBACtBpa,IAAI4Y,IACL,MAAMsC,EAAmBtC,EAAK1O,oBAC9B,MAAO,CACH0O,OACAlQ,OAAQ,EACRrJ,iBAAkB6b,EAAiBpc,MAAMrD,WAAa,GACtD0E,WAAYD,GAAqBgb,GAJ9B,GAONrf,KAAK,CAACC,EAAGC,IACHqd,EACDtd,EAAEqE,WAAWhB,KAAOpD,EAAEoE,WAAWhB,KACjCrD,EAAEqE,WAAWlB,IAAMlD,EAAEoE,WAAWlB,IAE7C,CAODya,iBAAiBnD,EAAiBiD,EAAatQ,GAC3C,MAAMkQ,EAAoC,eAArB3b,KAAKib,YAC1B,IAAIe,EAAaL,EACXI,EAAYra,KAAOoX,EAAgBpX,KACnCqa,EAAYva,IAAMsX,EAAgBtX,IAExC,OAAc,IAAViK,IACAuQ,GAAcL,EACRI,EAAYjZ,MAAQgW,EAAgBhW,MACpCiZ,EAAYhZ,OAAS+V,EAAgB/V,QAExCiZ,CACV,CAODG,oBAAoBhJ,EAAcqI,EAAU/P,GACxC,MAAMkQ,EAAoC,eAArB3b,KAAKib,YACpBnC,EAAkB0C,EAASrI,GAAczQ,WACzCgb,EAAmBlC,EAASrI,GAAuB,EAAR1H,GACjD,IAAIyQ,EAAgBpD,EAAgB6C,EAAe,QAAU,UAAYlQ,EACzE,GAAIiS,EAAkB,CAClB,MAAMpM,EAAQqK,EAAe,OAAS,MAChCgC,EAAMhC,EAAe,QAAU,UAKvB,IAAVlQ,EACAyQ,GAAiBwB,EAAiBhb,WAAW4O,GAASwH,EAAgB6E,GAGtEzB,GAAiBpD,EAAgBxH,GAASoM,EAAiBhb,WAAWib,EAE7E,CACD,OAAOzB,CACV,CAMDW,yBAAyBtZ,EAAUC,GAC/B,IAAKxD,KAAK2c,kBAAkB3W,OACxB,OAAO,EAEX,MAAM4X,EAAgB5d,KAAKgb,eACrBW,EAAoC,eAArB3b,KAAKib,YAI1B,GADiB2C,EAAc,GAAGzC,OAASnb,KAAK2c,kBAAkB,GACpD,CACV,MAAMkB,EAAeD,EAAcA,EAAc5X,OAAS,GAAGtD,WAC7D,OAAOiZ,EAAepY,GAAYsa,EAAajb,MAAQY,GAAYqa,EAAahb,MACnF,CACI,CACD,MAAMib,EAAgBF,EAAc,GAAGlb,WACvC,OAAOiZ,EAAepY,GAAYua,EAAcpc,KAAO8B,GAAYsa,EAActc,GACpF,CACJ,CAQDka,iCAAiCpI,EAAM/P,EAAUC,EAAUiI,GACvD,MAAMkQ,EAAoC,eAArB3b,KAAKib,YACpBsB,EAAQvc,KAAKgb,eAAeY,UAAU,EAAGT,OAAMzY,iBAEjD,GAAIyY,IAAS7H,EACT,OAAO,EAEX,GAAI7H,EAAO,CACP,MAAMyD,EAAYyM,EAAelQ,EAAMzI,EAAIyI,EAAMxI,EAIjD,GAAIkY,IAASnb,KAAKkb,cAAcC,MAC5Bnb,KAAKkb,cAAcE,UACnBlM,IAAclP,KAAKkb,cAAczP,MACjC,OAAO,CAEd,CACD,OAAOkQ,EAGCpY,GAAYmG,KAAKqU,MAAMrb,EAAWhB,OAAS6B,EAAWmG,KAAKqU,MAAMrb,EAAWE,OAC9EY,GAAYkG,KAAKqU,MAAMrb,EAAWlB,MAAQgC,EAAWkG,KAAKqU,MAAMrb,EAAWG,OAAtB,GAE/D,OAAiB,IAAV0Z,GAAiBvc,KAAKod,eAAeb,EAAOjJ,GAAaiJ,GAAL,CAC9D,EAuBL,MAAMyB,GACFle,YAAYoB,EAASoG,EAAmB1D,EAAWwD,EAASC,GACxDrH,KAAKsH,kBAAoBA,EACzBtH,KAAKoH,QAAUA,EACfpH,KAAKqH,eAAiBA,EAEtBrH,KAAKoJ,UAAW,EAEhBpJ,KAAKgU,iBAAkB,EAKvBhU,KAAKie,oBAAqB,EAE1Bje,KAAKke,eAAiB,EAKtBle,KAAKme,eAAiB,KAAM,EAE5Bne,KAAKoe,cAAgB,KAAM,EAE3Bpe,KAAKwI,cAAgB,IAAIb,IAIzB3H,KAAK4I,QAAU,IAAIjB,IAKnB3H,KAAK6I,OAAS,IAAIlB,IAElB3H,KAAK8I,QAAU,IAAInB,IAEnB3H,KAAKqe,OAAS,IAAI1W,IAElB3H,KAAKse,aAAc,EAEnBte,KAAKue,YAAc,GAEnBve,KAAKwe,UAAY,GAEjBxe,KAAKye,gBAAkB,IAAIxX,IAE3BjH,KAAK0e,4BAA8B7W,WAEnC7H,KAAK2e,yBAA2B,EAEhC3e,KAAK4e,2BAA6B,EAElC5e,KAAK6e,kBAAoB,IAAIlX,IAE7B3H,KAAKuZ,kBAAoB,KAEzBvZ,KAAK8e,qBAAuB,KACxB9e,KAAKgQ,iBC14DV,SAAS+O,GAASC,EAAS,EAAGC,EAAYC,MAC7C,OAAIF,EAAS,IACTA,EAAS,MAENG,MAAMH,EAAQA,EAAQC,EAChC,CDs4DWF,CAAS,EAAGK,MACPC,QAAKC,MAAUtf,KAAK6e,oBACpB5Q,UAAU,KACX,MAAM9I,EAAOnF,KAAKuf,YACZC,EAAaxf,KAAKke,eACc,IAAlCle,KAAK2e,yBACLxZ,EAAKsa,SAAS,GAAID,GAEqB,IAAlCxf,KAAK2e,0BACVxZ,EAAKsa,SAAS,EAAGD,GAEmB,IAApCxf,KAAK4e,2BACLzZ,EAAKsa,UAAUD,EAAY,GAEc,IAApCxf,KAAK4e,4BACVzZ,EAAKsa,SAASD,EAAY,EAA1B,EAfR,EAmBJxf,KAAKkB,WAAU0L,MAAc1L,GAC7BlB,KAAK4D,UAAYA,EACjB5D,KAAK0f,sBAAsB,CAAC1f,KAAKkB,UACjCoG,EAAkBqY,sBAAsB3f,MACxCA,KAAKgM,iBAAmB,IAAIrI,GAAsBC,GAClD5D,KAAK4f,cAAgB,IAAI9E,GAAuB9a,KAAKkB,QAASoG,GAC9DtH,KAAK4f,cAAc1C,kBAAkB,CAACX,EAAOjJ,IAAStT,KAAKoe,cAAc7B,EAAOjJ,EAAMtT,MACzF,CAEDqO,UACIrO,KAAKgQ,iBACLhQ,KAAK6e,kBAAkBjQ,WACvB5O,KAAK0e,4BAA4B3Q,cACjC/N,KAAKwI,cAAcoG,WACnB5O,KAAK4I,QAAQgG,WACb5O,KAAK6I,OAAO+F,WACZ5O,KAAK8I,QAAQ8F,WACb5O,KAAKqe,OAAOzP,WACZ5O,KAAKye,gBAAgB1a,QACrB/D,KAAKuf,YAAc,KACnBvf,KAAKgM,iBAAiBjI,QACtB/D,KAAKsH,kBAAkBuY,oBAAoB7f,KAC9C,CAEDsK,aACI,OAAOtK,KAAKse,WACf,CAEDhN,QACItR,KAAK8f,mBACL9f,KAAK+f,0BACR,CASDhM,MAAMT,EAAM/P,EAAUC,EAAU+Y,GAC5Bvc,KAAK8f,mBAGQ,MAATvD,GAAiBvc,KAAKgU,kBACtBuI,EAAQvc,KAAKue,YAAYvc,QAAQsR,IAErCtT,KAAK4f,cAAc7L,MAAMT,EAAM/P,EAAUC,EAAU+Y,GAGnDvc,KAAKggB,wBAELhgB,KAAK+f,2BACL/f,KAAK4I,QAAQK,KAAK,CAAEqK,OAAMnJ,UAAWnK,KAAMmT,aAAcnT,KAAKyR,aAAa6B,IAC9E,CAKDQ,KAAKR,GACDtT,KAAKigB,SACLjgB,KAAK6I,OAAOI,KAAK,CAAEqK,OAAMnJ,UAAWnK,MACvC,CAcDyT,KAAKH,EAAMH,EAAcI,EAAeC,EAAmBJ,EAAwB7H,EAAU8E,EAAW5L,EAAQ,IAC5GzE,KAAKigB,SACLjgB,KAAK8I,QAAQG,KAAK,CACdqK,OACAH,eACAI,gBACApJ,UAAWnK,KACXwT,oBACAJ,yBACA7H,WACA8E,YACA5L,SAEP,CAKD6W,UAAUD,GACN,MAAM6E,EAAgBlgB,KAAKue,YAC3B,YAAKA,YAAclD,EACnBA,EAAMhX,QAAQiP,GAAQA,EAAKnE,mBAAmBnP,OAC1CA,KAAKsK,eACgB4V,EAAcC,OAAO7M,GAAQA,EAAKhJ,cAGtC8V,MAAM9M,IAAgC,IAAxB+H,EAAMrZ,QAAQsR,IACzCtT,KAAKigB,SAGLjgB,KAAK4f,cAActE,UAAUtb,KAAKue,cAGnCve,IACV,CAEDiP,cAAcC,GACV,YAAK0Q,cAAc1Q,UAAYA,EACxBlP,IACV,CAMDqgB,YAAYA,GACR,YAAK7B,UAAY6B,EAAYhE,QACtBrc,IACV,CAKDsgB,gBAAgBrF,GAGZ,YAAK2E,cAAc3E,YAAcA,EAC1Bjb,IACV,CAKD0f,sBAAsBzb,GAClB,MAAM/C,KAAU0L,MAAc5M,KAAKkB,SAGnC,YAAKqf,qBAC6B,IAA9Btc,EAASjC,QAAQd,GAAkB,CAACA,KAAY+C,GAAYA,EAASoY,QAClErc,IACV,CAED0R,uBACI,OAAO1R,KAAKugB,mBACf,CAKD9O,aAAa6B,GACT,OAAOtT,KAAKse,YACNte,KAAK4f,cAAcnO,aAAa6B,GAChCtT,KAAKue,YAAYvc,QAAQsR,EAClC,CAKD/I,cACI,OAAOvK,KAAKye,gBAAgB+B,KAAO,CACtC,CAQDtM,UAAUZ,EAAM/P,EAAUC,EAAU+X,GAEhC,GAAIvb,KAAKgU,kBACJhU,KAAKygB,cACLrd,GAAwBpD,KAAKygB,YAzQT,IAyQgDld,EAAUC,GAC/E,OAEJ,MAAMkd,EAAS1gB,KAAK4f,cAAcxhB,KAAKkV,EAAM/P,EAAUC,EAAU+X,GAC7DmF,GACA1gB,KAAKqe,OAAOpV,KAAK,CACbsK,cAAemN,EAAOnN,cACtBJ,aAAcuN,EAAOvN,aACrBhJ,UAAWnK,KACXsT,QAGX,CAODW,2BAA2B1Q,EAAUC,GACjC,GAAIxD,KAAKie,mBACL,OAEJ,IAAI0C,EACAC,EAA0B,EAC1BC,EAA4B,EAgBhC,GAdA7gB,KAAKgM,iBAAiBnI,UAAUQ,QAAQ,CAAC9C,EAAUL,KAG3CA,IAAYlB,KAAK4D,YAAcrC,EAASmB,YAAcie,GAGtDvd,GAAwB7B,EAASmB,WA1ShB,IA0SsDa,EAAUC,MAChFod,EAAyBC,GAkO1C,SAASC,GAA2B5f,EAASwB,EAAYa,EAAUC,GAC/D,MAAMud,EAAmBC,GAA2Bte,EAAYc,GAC1Dyd,EAAqBC,GAA6Bxe,EAAYa,GACpE,IAAIqd,EAA0B,EAC1BC,EAA4B,EAKhC,GAAIE,EAAkB,CAClB,MAAMzc,EAAYpD,EAAQoD,UACD,IAArByc,EACIzc,EAAY,IACZsc,EAA0B,GAGzB1f,EAAQigB,aAAe7c,EAAYpD,EAAQkgB,eAChDR,EAA0B,EAEjC,CACD,GAAIK,EAAoB,CACpB,MAAM1c,EAAarD,EAAQqD,WACA,IAAvB0c,EACI1c,EAAa,IACbsc,EAA4B,GAG3B3f,EAAQmgB,YAAc9c,EAAarD,EAAQogB,cAChDT,EAA4B,EAEnC,CACD,MAAO,CAACD,EAAyBC,EACpC,CAlQsEC,CAA2B5f,EAASK,EAASmB,WAAYa,EAAUC,IACtHod,GAA2BC,KAC3BF,EAAazf,OAKpB0f,IAA4BC,EAA2B,CACxD,MAAQ/d,QAAOC,UAAW/C,KAAKqH,eAAeka,kBACxC7e,EAAa,CACfI,QACAC,SACAvB,IAAK,EACLoB,MAAOE,EACPD,OAAQE,EACRrB,KAAM,GAEVkf,EAA0BI,GAA2Bte,EAAYc,GACjEqd,EAA4BK,GAA6Bxe,EAAYa,GACrEod,EAAatb,MAChB,CACGsb,IACCC,IAA4B5gB,KAAK2e,0BAC9BkC,IAA8B7gB,KAAK4e,4BACnC+B,IAAe3gB,KAAKuf,eACxBvf,KAAK2e,yBAA2BiC,EAChC5gB,KAAK4e,2BAA6BiC,EAClC7gB,KAAKuf,YAAcoB,GACdC,GAA2BC,IAA8BF,EAC1D3gB,KAAKoH,QAAQkG,kBAAkBtN,KAAK8e,sBAGpC9e,KAAKgQ,iBAGhB,CAEDA,iBACIhQ,KAAK6e,kBAAkB5V,MAC1B,CAED6W,mBACI,MAAMjH,KAASjM,MAAc5M,KAAKkB,SAASG,MAC3CrB,KAAKwI,cAAcS,OACnBjJ,KAAKse,aAAc,EAInBte,KAAKwhB,mBAAqB3I,EAAO4I,kBAAoB5I,EAAO6I,gBAAkB,GAC9E7I,EAAO6I,eAAiB7I,EAAO4I,iBAAmB,OAClDzhB,KAAK4f,cAActO,MAAMtR,KAAKue,aAC9Bve,KAAKggB,wBACLhgB,KAAK0e,4BAA4B3Q,cACjC/N,KAAK2hB,uBACR,CAED3B,wBACI,MAAM9e,KAAU0L,MAAc5M,KAAKkB,SACnClB,KAAKgM,iBAAiBhI,MAAMhE,KAAKugB,qBAGjCvgB,KAAKygB,YAAczgB,KAAKgM,iBAAiBnI,UAAUgB,IAAI3D,GAASwB,UACnE,CAEDud,SACIjgB,KAAKse,aAAc,EACnB,MAAMzF,KAASjM,MAAc5M,KAAKkB,SAASG,MAC3CwX,EAAO6I,eAAiB7I,EAAO4I,iBAAmBzhB,KAAKwhB,mBACvDxhB,KAAKwe,UAAUna,QAAQiY,GAAWA,EAAQsF,eAAe5hB,OACzDA,KAAK4f,cAAc/Q,QACnB7O,KAAKgQ,iBACLhQ,KAAK0e,4BAA4B3Q,cACjC/N,KAAKgM,iBAAiBjI,OACzB,CAMDsP,iBAAiBrQ,EAAGC,GAChB,OAA2B,MAApBjD,KAAKygB,aAAuBvd,GAAmBlD,KAAKygB,YAAazd,EAAGC,EAC9E,CAQD4Q,iCAAiCP,EAAMtQ,EAAGC,GACtC,OAAOjD,KAAKwe,UAAU1I,KAAKwG,GAAWA,EAAQuF,YAAYvO,EAAMtQ,EAAGC,GACtE,CAOD4e,YAAYvO,EAAMtQ,EAAGC,GACjB,IAAKjD,KAAKygB,cACLvd,GAAmBlD,KAAKygB,YAAazd,EAAGC,KACxCjD,KAAKme,eAAe7K,EAAMtT,MAC3B,OAAO,EAEX,MAAM8hB,EAAmB9hB,KAAK+Q,iBAAiB+Q,iBAAiB9e,EAAGC,GAGnE,IAAK6e,EACD,OAAO,EAEX,MAAMC,KAAgBnV,MAAc5M,KAAKkB,SAOzC,OAAO4gB,IAAqBC,GAAiBA,EAAc3c,SAAS0c,EACvE,CAKDE,gBAAgB1F,EAASjB,GACrB,MAAM4G,EAAiBjiB,KAAKye,iBACvBwD,EAAelhB,IAAIub,IACpBjB,EAAM+E,MAAM9M,GAKDtT,KAAKme,eAAe7K,EAAMtT,OAASA,KAAKue,YAAYvc,QAAQsR,IAAQ,KAE/E2O,EAAenV,IAAIwP,GACnBtc,KAAKggB,wBACLhgB,KAAK2hB,wBAEZ,CAKDC,eAAetF,GACXtc,KAAKye,gBAAgBzP,OAAOsN,GAC5Btc,KAAK0e,4BAA4B3Q,aACpC,CAKD4T,wBACI3hB,KAAK0e,4BAA8B1e,KAAKsH,kBACnCkL,SAASxS,KAAK+Q,kBACd9C,UAAUxJ,IACX,GAAIzE,KAAKsK,aAAc,CACnB,MAAMgP,EAAmBtZ,KAAKgM,iBAAiBxH,aAAaC,GACxD6U,GACAtZ,KAAK4f,cAAcpC,eAAelE,EAAiB9X,IAAK8X,EAAiB5X,KAEhF,MACQ1B,KAAKuK,eACVvK,KAAKggB,uBAAL,EAGX,CAODjP,iBACI,IAAK/Q,KAAKuZ,kBAAmB,CACzB,MAAMzI,KAAaC,SAAenE,MAAc5M,KAAKkB,UACrDlB,KAAKuZ,kBAAqBzI,GAAc9Q,KAAK4D,SAChD,CACD,OAAO5D,KAAKuZ,iBACf,CAEDwG,2BACI,MAAMmC,EAAeliB,KAAK4f,cACrBtC,yBACA6C,OAAO7M,GAAQA,EAAKhJ,cACzBtK,KAAKwe,UAAUna,QAAQiY,GAAWA,EAAQ0F,gBAAgBhiB,KAAMkiB,GACnE,EAOL,SAASlB,GAA2Bte,EAAYc,GAC5C,MAAQhC,MAAKqB,SAAQE,UAAWL,EAC1BgB,EAveyB,IAueZX,EACnB,OAAIS,GAAYhC,EAAMkC,GAAcF,GAAYhC,EAAMkC,EAC3C,EAEFF,GAAYX,EAASa,GAAcF,GAAYX,EAASa,EACtD,EAEJ,CACV,CAMD,SAASwd,GAA6Bxe,EAAYa,GAC9C,MAAQ7B,OAAMkB,QAAOE,SAAUJ,EACzBe,EAvfyB,IAufZX,EACnB,OAAIS,GAAY7B,EAAO+B,GAAcF,GAAY7B,EAAO+B,EAC7C,EAEFF,GAAYX,EAAQa,GAAcF,GAAYX,EAAQa,EACpD,EAEJ,CACV,CAmDD,MAAM0e,IAA8Btb,QAAgC,CAChEC,SAAS,EACTsb,SAAS,QAUPC,SAAN,MAAMA,EACFviB,YAAYsH,EAASxD,GACjB5D,KAAKoH,QAAUA,EAEfpH,KAAKsiB,eAAiB,IAAIrb,IAE1BjH,KAAKuiB,eAAiB,IAAItb,IAE1BjH,KAAKwiB,qBAAuB,GAE5BxiB,KAAKyiB,iBAAmB,IAAI3e,IAK5B9D,KAAK0iB,mBAAsBpP,GAASA,EAAKhJ,aAKzCtK,KAAKsS,YAAc,IAAI3K,IAKvB3H,KAAKuS,UAAY,IAAI5K,IAMrB3H,KAAK2iB,OAAS,IAAIhb,IAKlB3H,KAAK4iB,6BAAgCne,IAC7BzE,KAAKwiB,qBAAqBxc,OAAS,GACnCvB,EAAM+F,gBAAN,EAIRxK,KAAK6iB,6BAAgCpe,IAC7BzE,KAAKwiB,qBAAqBxc,OAAS,IAI/BhG,KAAKwiB,qBAAqBM,KAAK9iB,KAAK0iB,qBACpCje,EAAM+F,iBAEVxK,KAAKsS,YAAYrJ,KAAKxE,GAAtB,EAGRzE,KAAK4D,UAAYA,CACpB,CAED+b,sBAAsBlM,GACbzT,KAAKsiB,eAAevhB,IAAI0S,IACzBzT,KAAKsiB,eAAexV,IAAI2G,EAE/B,CAEDxH,iBAAiBkP,GACbnb,KAAKuiB,eAAezV,IAAIqO,GAIS,IAA7Bnb,KAAKuiB,eAAe/B,MACpBxgB,KAAKoH,QAAQkG,kBAAkB,KAG3BtN,KAAK4D,UAAU2J,iBAAiB,YAAavN,KAAK6iB,6BAA8BV,GAAhF,EAGX,CAEDtC,oBAAoBpM,GAChBzT,KAAKsiB,eAAetT,OAAOyE,EAC9B,CAED/E,eAAeyM,GACXnb,KAAKuiB,eAAevT,OAAOmM,GAC3Bnb,KAAK6P,aAAasL,GACe,IAA7Bnb,KAAKuiB,eAAe/B,MACpBxgB,KAAK4D,UAAUyS,oBAAoB,YAAarW,KAAK6iB,6BAA8BV,GAE1F,CAMDlP,cAAckI,EAAM1W,GAEhB,KAAIzE,KAAKwiB,qBAAqBxgB,QAAQmZ,IAAQ,KAG9Cnb,KAAKwiB,qBAAqBxF,KAAK7B,GACU,IAArCnb,KAAKwiB,qBAAqBxc,QAAc,CACxC,MAAMsK,EAAe7L,EAAM9E,KAAKojB,WAAW,SAI3C/iB,KAAKyiB,iBACAve,IAAIoM,EAAe,WAAa,UAAW,CAC5C6F,QAAU6M,GAAMhjB,KAAKuS,UAAUtJ,KAAK+Z,GACpCC,SAAS,IAER/e,IAAI,SAAU,CACfiS,QAAU6M,GAAMhjB,KAAK2iB,OAAO1Z,KAAK+Z,GAGjCC,SAAS,IAMR/e,IAAI,cAAe,CACpBiS,QAASnW,KAAK4iB,6BACdK,QAASd,KAIR7R,GACDtQ,KAAKyiB,iBAAiBve,IAAI,YAAa,CACnCiS,QAAU6M,GAAMhjB,KAAKsS,YAAYrJ,KAAK+Z,GACtCC,QAASd,KAGjBniB,KAAKoH,QAAQkG,kBAAkB,KAC3BtN,KAAKyiB,iBAAiBpe,QAAQ,CAAC6e,EAAQ9gB,KACnCpC,KAAK4D,UAAU2J,iBAAiBnL,EAAM8gB,EAAO/M,QAAS+M,EAAOD,QAA7D,EADJ,EAIP,CACJ,CAEDpT,aAAasL,GACT,MAAMoB,EAAQvc,KAAKwiB,qBAAqBxgB,QAAQmZ,GAC5CoB,GAAQ,IACRvc,KAAKwiB,qBAAqB1F,OAAOP,EAAO,GACC,IAArCvc,KAAKwiB,qBAAqBxc,QAC1BhG,KAAKmjB,wBAGhB,CAED7Y,WAAW6Q,GACP,OAAOnb,KAAKwiB,qBAAqBxgB,QAAQmZ,IAAQ,CACpD,CAQD3I,SAAS1B,GACL,MAAMsS,EAAU,CAACpjB,KAAK2iB,QACtB,OAAI7R,GAAcA,IAAe9Q,KAAK4D,WAIlCwf,EAAQpG,KAAK,IAAIqG,KAAYC,GAClBtjB,KAAKoH,QAAQkG,kBAAkB,KAElC,MAAMjH,EAAY5B,IACVzE,KAAKwiB,qBAAqBxc,QAC1Bsd,EAASra,KAAKxE,EAAd,EAGRqM,SAAWvD,iBAAiB,SAAUlH,GAAUkd,GACzC,KACHzS,EAAWuF,oBAAoB,SAAUhQ,GAAUkd,EAAnD,CACH,MAXT,EAeGC,SAASJ,EACnB,CACDK,cACIzjB,KAAKuiB,eAAele,QAAQqf,GAAY1jB,KAAK0O,eAAegV,IAC5D1jB,KAAKsiB,eAAeje,QAAQqf,GAAY1jB,KAAK6f,oBAAoB6D,IACjE1jB,KAAKmjB,wBACLnjB,KAAKsS,YAAY1D,WACjB5O,KAAKuS,UAAU3D,UAClB,CAEDuU,wBACInjB,KAAKyiB,iBAAiBpe,QAAQ,CAAC6e,EAAQ9gB,KACnCpC,KAAK4D,UAAUyS,oBAAoBjU,EAAM8gB,EAAO/M,QAAS+M,EAAOD,QAAhE,GAEJjjB,KAAKyiB,iBAAiB1e,OACzB,EAELse,SAAiBsB,UAAjB,0BAA6GtB,GAAVjiB,MAA4CA,OAA5CA,MAAkEwjB,MAArK,EACAvB,EAAiBwB,WADkFzjB,MACnG,OAAiHiiB,EAAjHyB,QAAiHzB,EAAjH,qBAA+I,SArMzIA,MAsNN,MAAM0B,GAAiB,CACnBla,mBAAoB,EACpB8O,gCAAiC,OAK/BqL,SAAN,MAAMA,EACFlkB,YAAY8D,EAAWwD,EAASC,EAAgBC,GAC5CtH,KAAK4D,UAAYA,EACjB5D,KAAKoH,QAAUA,EACfpH,KAAKqH,eAAiBA,EACtBrH,KAAKsH,kBAAoBA,CAC5B,CAMD2c,WAAW/iB,EAASgiB,EAASa,IACzB,OAAO,IAAI7c,GAAQhG,EAASgiB,EAAQljB,KAAK4D,UAAW5D,KAAKoH,QAASpH,KAAKqH,eAAgBrH,KAAKsH,kBAC/F,CAKD4c,eAAehjB,GACX,OAAO,IAAI8c,GAAY9c,EAASlB,KAAKsH,kBAAmBtH,KAAK4D,UAAW5D,KAAKoH,QAASpH,KAAKqH,eAC9F,EAEL2c,SAASL,UAAT,0BAAqGK,GAhDF5jB,MAgD4BwjB,MAhD5BxjB,MAgDiDA,OAhDjDA,MAgDuE+jB,OAhDvE/jB,MAgDoGiiB,IAAvM,EACA2B,EAASH,WAjD0FzjB,MAiDnG,OAAyG4jB,EAAzGF,QAAyGE,EAAzG,qBAA+H,SAxBzHA,MA8CN,MAAMI,GAAkB,IAAIC,MAAe,mBAsBrCC,GAAsB,IAAID,MAAe,oBAiDzCE,GAAkB,IAAIF,MAAe,mBA4B3C,IAAIG,GAAmB,EAMvB,MAAMC,GAAgB,IAAIJ,MAAe,mBAEnCK,SAAN,MAAMA,EACF5kB,YAEAoB,EAASyjB,EAAUC,EAAoBC,EAAmBC,EAAMC,EAAQ7B,GACpEljB,KAAKkB,QAAUA,EACflB,KAAK4kB,mBAAqBA,EAC1B5kB,KAAK6kB,kBAAoBA,EACzB7kB,KAAK8kB,KAAOA,EACZ9kB,KAAK+kB,OAASA,EAEd/kB,KAAKglB,WAAa,IAAIrd,IAMtB3H,KAAKqgB,YAAc,GAKnBrgB,KAAKilB,GAAM,iBAAgBT,KAK3BxkB,KAAKme,eAAiB,KAAM,EAE5Bne,KAAKoe,cAAgB,KAAM,EAE3Bpe,KAAK8I,QAAU,IAAIoc,MAInBllB,KAAK4I,QAAU,IAAIsc,MAKnBllB,KAAK6I,OAAS,IAAIqc,MAElBllB,KAAKqe,OAAS,IAAI6G,MAQlBllB,KAAKmlB,eAAiB,IAAIle,IAI1BjH,KAAKolB,aAAeT,EAAST,eAAehjB,GAC5ClB,KAAKolB,aAAaC,KAAOrlB,KACrBkjB,GACAljB,KAAKslB,gBAAgBpC,GAEzBljB,KAAKolB,aAAajH,eAAiB,CAAChD,EAAM1H,IAC/BzT,KAAKme,eAAehD,EAAKkK,KAAM5R,EAAK4R,MAE/CrlB,KAAKolB,aAAahH,cAAgB,CAAC7B,EAAOpB,EAAM1H,IACrCzT,KAAKoe,cAAc7B,EAAOpB,EAAKkK,KAAM5R,EAAK4R,MAErDrlB,KAAKulB,4BAA4BvlB,KAAKolB,cACtCplB,KAAKwlB,cAAcxlB,KAAKolB,cACxBV,EAAYe,WAAWzI,KAAKhd,MACxB+kB,GACAA,EAAOW,OAAO5Y,IAAI9M,KAEzB,CAEGoJ,eACA,OAAOpJ,KAAKuI,aAAgBvI,KAAK+kB,QAAU/kB,KAAK+kB,OAAO3b,QAC1D,CACGA,aAASvI,GAKTb,KAAKolB,aAAahc,SAAWpJ,KAAKuI,aAAY4D,MAAsBtL,EACvE,CAED8kB,QAAQrS,GACJtT,KAAKmlB,eAAerY,IAAIwG,GACpBtT,KAAKolB,aAAa9a,cAClBtK,KAAK4lB,mBAEZ,CAEDC,WAAWvS,GACPtT,KAAKmlB,eAAenW,OAAOsE,GACvBtT,KAAKolB,aAAa9a,cAClBtK,KAAK4lB,mBAEZ,CAEDE,iBACI,OAAO3Q,MAAMwF,KAAK3a,KAAKmlB,gBAAgB/mB,KAAK,CAACC,EAAGC,IACnBD,EAAE0nB,SACtBtZ,oBACAuZ,wBAAwB1nB,EAAEynB,SAAStZ,qBAIdwZ,KAAKC,6BAA8B,EAAK,EAEzE,CACDzC,cACI,MAAMlH,EAAQmI,EAAYe,WAAWzjB,QAAQhC,MACzCuc,GAAQ,GACRmI,EAAYe,WAAW3I,OAAOP,EAAO,GAErCvc,KAAK+kB,QACL/kB,KAAK+kB,OAAOW,OAAO1W,OAAOhP,MAE9BA,KAAKmlB,eAAephB,QACpB/D,KAAKolB,aAAa/W,UAClBrO,KAAKglB,WAAW/b,OAChBjJ,KAAKglB,WAAWpW,UACnB,CAED2W,4BAA4BY,GACpBnmB,KAAK8kB,MACL9kB,KAAK8kB,KAAK9W,OACLqR,QAAK+G,MAAUpmB,KAAK8kB,KAAKjkB,QAAX,EAAmBye,MAAUtf,KAAKglB,aAChD/W,UAAUpN,GAASslB,EAAIlX,cAAcpO,IAE9CslB,EAAI3d,cAAcyF,UAAU,KACxB,MAAMuN,KAAW6K,MAAYrmB,KAAKqgB,aAAa9d,IAAIkR,GAC3B,iBAATA,EACuBiR,EAAYe,WAAW3P,KAAKwQ,GAAQA,EAAKrB,KAAOxR,GAM3EA,GAWX,GATIzT,KAAK+kB,QACL/kB,KAAK+kB,OAAOW,OAAOrhB,QAAQoP,KACQ,IAA3B+H,EAASxZ,QAAQyR,IACjB+H,EAASwB,KAAKvJ,EAAd,IAMPzT,KAAKumB,2BAA4B,CAClC,MAAMC,EAAoBxmB,KAAK6kB,kBAC1B4B,4BAA4BzmB,KAAKkB,SACjCqB,IAAImkB,GAAcA,EAAWC,gBAAgB5E,eAClD/hB,KAAKolB,aAAa1F,sBAAsB8G,GAGxCxmB,KAAKumB,4BAA6B,CACrC,CACDJ,EAAI/c,SAAWpJ,KAAKoJ,SACpB+c,EAAItO,SAAW7X,KAAK6X,SACpBsO,EAAInS,mBAAkB7H,MAAsBnM,KAAKgU,iBACjDmS,EAAIlI,sBAAqB9R,MAAsBnM,KAAKie,oBACpDkI,EAAIjI,kBAAiB0I,MAAqB5mB,KAAKke,eAAgB,GAC/DiI,EACK9F,YAAY7E,EAAS2E,OAAO1M,GAAQA,GAAQA,IAASzT,MAAMuC,IAAI+jB,GAAQA,EAAKlB,eAC5E9E,gBAAgBtgB,KAAKib,YAF1B,EAIP,CAEDuK,cAAcW,GACVA,EAAI3d,cAAcyF,UAAU,KACxBjO,KAAK4lB,oBACL5lB,KAAK4kB,mBAAmBiC,cAAxB,GAEJV,EAAIvd,QAAQqF,UAAUxJ,IAClBzE,KAAK4I,QAAQke,KAAK,CACd3c,UAAWnK,KACXsT,KAAM7O,EAAM6O,KAAK+R,KACjBlS,aAAc1O,EAAM0O,cAHxB,GAMJgT,EAAItd,OAAOoF,UAAUxJ,IACjBzE,KAAK6I,OAAOie,KAAK,CACb3c,UAAWnK,KACXsT,KAAM7O,EAAM6O,KAAK+R,OAErBrlB,KAAK4kB,mBAAmBiC,cAAxB,GAEJV,EAAI9H,OAAOpQ,UAAUxJ,IACjBzE,KAAKqe,OAAOyI,KAAK,CACbvT,cAAe9O,EAAM8O,cACrBJ,aAAc1O,EAAM0O,aACpBhJ,UAAWnK,KACXsT,KAAM7O,EAAM6O,KAAK+R,MAJrB,GAOJc,EAAIrd,QAAQmF,UAAU8Y,IAClB/mB,KAAK8I,QAAQge,KAAK,CACdvT,cAAewT,EAAUxT,cACzBJ,aAAc4T,EAAU5T,aACxBK,kBAAmBuT,EAAUvT,kBAAkB6R,KAC/Clb,UAAW4c,EAAU5c,UAAUkb,KAC/B/R,KAAMyT,EAAUzT,KAAK+R,KACrBjS,uBAAwB2T,EAAU3T,uBAClC7H,SAAUwb,EAAUxb,SACpB8E,UAAW0W,EAAU1W,UACrB5L,MAAOsiB,EAAUtiB,QAIrBzE,KAAK4kB,mBAAmBiC,cAAxB,EAEP,CAEDvB,gBAAgBpC,GACZ,MAAQrL,WAAUmP,mBAAkBhT,kBAAiBiT,yBAAwBC,mBAAoBhE,EACjGljB,KAAKoJ,SAAW4d,IAA2B,EAC3ChnB,KAAKgU,gBAAkBA,IAA0B,EACjDhU,KAAKie,mBAAqBgJ,IAAiC,EAC3DjnB,KAAKib,YAAciM,GAAmB,WAClCrP,IACA7X,KAAK6X,SAAWA,EAEvB,CAED+N,oBACI5lB,KAAKolB,aAAa9J,UAAUtb,KAAK8lB,iBAAiBvjB,IAAI+Q,GAAQA,EAAKyS,UACtE,EAGLrB,SAAYe,WAAa,GACzBf,EAAYf,UAAZ,0BAAwGe,GAxZLtkB,MAwZkCA,OAxZlCA,MAwZ4D4jB,IAxZ5D5jB,MAwZiFA,OAxZjFA,MAwZkH+jB,OAxZlH/jB,MAwZkJ+mB,MAArP,GAxZmG/mB,MAwZgMkkB,GAAnS,IAxZmGlkB,MAwZgQmkB,GAAnW,KACAG,EAAY0C,UAzZuFhnB,MAyZnG,MAA4FskB,EAA5FrkB,8HAzZmGD,MAyZnG,WAzZmGA,MAyZnG,oCAzZmGA,CAyZnG,qDAzZmGA,CAyZnG,4wBAzZmGA,MAyZ4gC,CAEvmC,CAAEinB,QAAS/C,GAAqBgD,cAAU7Z,GAC1C,CAAE4Z,QAAS5C,GAAe8C,YAAa7C,QA1OzCA,MAsUN,MAAM8C,GAAkB,IAAInD,MAAe,qBAErCoD,SAAN,MAAMA,EACF3nB,YAAYoB,EAASwmB,GACjB1nB,KAAKkB,QAAUA,EAEflB,KAAK2nB,cAAgB,IAAIhgB,IACzB3H,KAAKuI,WAAY,EAIjBvI,KAAK4nB,YAAcF,CACtB,CAEGte,eACA,OAAOpJ,KAAKuI,SACf,CACGa,aAASvI,GACTb,KAAKuI,aAAY4D,MAAsBtL,GACvCb,KAAK2nB,cAAc1e,KAAKjJ,KAC3B,CACDyjB,cACIzjB,KAAK2nB,cAAc/Y,UACtB,EAEL6Y,SAAc9D,UAAd,0BAA0G8D,GAjhBPrnB,MAihBsCA,OAjhBtCA,MAihBgEgkB,GAAnK,MACAqD,EAAcL,UAlhBqFhnB,MAkhBnG,MAA8FqnB,EAA9FpnB,qIAlhBmGD,MAkhB4J,CAAC,CAAEinB,QAASG,GAAiBD,YAAaE,QAxBnSA,MA0DN,MAAMI,GAAuB,IAAIxD,MAAe,sBAkC1CyD,GAAmB,IAAIzD,MAAe,sBAyCtC0D,SAAN,MAAMA,EACFjoB,YAEAoB,EAEAsP,EAKA5M,EAAWwD,EAAS4gB,EAAmB9E,EAAQ4B,EAAMH,EAAUC,EAAoBqD,EAAaL,GAC5F5nB,KAAKkB,QAAUA,EACflB,KAAKwQ,cAAgBA,EACrBxQ,KAAKoH,QAAUA,EACfpH,KAAKgoB,kBAAoBA,EACzBhoB,KAAK8kB,KAAOA,EACZ9kB,KAAK4kB,mBAAqBA,EAC1B5kB,KAAKioB,YAAcA,EACnBjoB,KAAK4nB,YAAcA,EACnB5nB,KAAKglB,WAAa,IAAIrd,IAEtB3H,KAAKyI,QAAU,IAAIyc,MAEnBllB,KAAK0I,SAAW,IAAIwc,MAEpBllB,KAAK2I,MAAQ,IAAIuc,MAEjBllB,KAAK4I,QAAU,IAAIsc,MAEnBllB,KAAK6I,OAAS,IAAIqc,MAElBllB,KAAK8I,QAAU,IAAIoc,MAKnBllB,KAAK+I,MAAQ,IAAIsa,KAAYC,IACzB,MAAM4E,EAAeloB,KAAK+lB,SAAShd,MAC9BsW,QAAK9c,MAAI4lB,KACV1nB,OAAQT,KACRwJ,gBAAiB2e,EAAW3e,gBAC5B/E,MAAO0jB,EAAW1jB,MAClBgH,MAAO0c,EAAW1c,MAClBF,SAAU4c,EAAW5c,aAEpB0C,UAAUqV,GACf,MAAO,KACH4E,EAAana,aAAb,CACH,GAEL/N,KAAK+lB,SAAWpB,EAASV,WAAW/iB,EAAS,CACzC2I,mBAAoBqZ,GAAuC,MAA7BA,EAAOrZ,mBAA6BqZ,EAAOrZ,mBAAqB,EAC9F8O,gCAAiCuK,GAAoD,MAA1CA,EAAOvK,gCAC5CuK,EAAOvK,gCACP,EACN3D,OAAQkO,GAAQlO,SAEpBhV,KAAK+lB,SAASV,KAAOrlB,KAIrB+nB,EAAQxF,eAAevF,KAAKhd,MACxBkjB,GACAljB,KAAKslB,gBAAgBpC,GASrB1S,IACAxQ,KAAK+lB,SAAS5W,mBAAmBqB,EAAc4U,cAC/C5U,EAAcmV,QAAQ3lB,OAE1BA,KAAKooB,YAAYpoB,KAAK+lB,UACtB/lB,KAAKwlB,cAAcxlB,KAAK+lB,SAC3B,CAEG3c,eACA,OAAOpJ,KAAKuI,WAAcvI,KAAKwQ,eAAiBxQ,KAAKwQ,cAAcpH,QACtE,CACGA,aAASvI,GACTb,KAAKuI,aAAY4D,MAAsBtL,GACvCb,KAAK+lB,SAAS3c,SAAWpJ,KAAKuI,SACjC,CAKD+D,wBACI,OAAOtM,KAAK+lB,SAASzZ,uBACxB,CAEDE,iBACI,OAAOxM,KAAK+lB,SAASvZ,gBACxB,CAEDqC,QACI7O,KAAK+lB,SAASlX,OACjB,CAIDO,sBACI,OAAOpP,KAAK+lB,SAAS3W,qBACxB,CAKDC,oBAAoBxO,GAChBb,KAAK+lB,SAAS1W,oBAAoBxO,EACrC,CACDwnB,kBAGIroB,KAAKoH,QAAQkG,kBAAkB,KAK3BtN,KAAKoH,QAAQkhB,SAASjJ,QAAKkJ,MAAK,IAAD,EAAKjJ,MAAUtf,KAAKglB,aAAa/W,UAAU,KACtEjO,KAAKwoB,qBACLxoB,KAAKyoB,wBACDzoB,KAAK0oB,kBACL1oB,KAAK+lB,SAAS1W,oBAAoBrP,KAAK0oB,iBAAvC,EAJR,EAQP,CACDC,YAAYC,GACR,MAAMC,EAAqBD,EAAQE,oBAC7BC,EAAiBH,EAAQF,iBAG3BG,IAAuBA,EAAmBG,aAC1ChpB,KAAKwoB,qBAGLO,IAAmBA,EAAeC,aAAehpB,KAAK0oB,kBACtD1oB,KAAK+lB,SAAS1W,oBAAoBrP,KAAK0oB,iBAE9C,CACDjF,cACQzjB,KAAKwQ,eACLxQ,KAAKwQ,cAAcqV,WAAW7lB,MAElC,MAAMuc,EAAQwL,EAAQxF,eAAevgB,QAAQhC,MACzCuc,GAAQ,GACRwL,EAAQxF,eAAezF,OAAOP,EAAO,GAGzCvc,KAAKoH,QAAQkG,kBAAkB,KAC3BtN,KAAKglB,WAAW/b,OAChBjJ,KAAKglB,WAAWpW,WAChB5O,KAAK+lB,SAAS1X,SAAd,EAEP,CAEDma,qBACI,MAAMtnB,EAAUlB,KAAKkB,QAAQ6gB,cAC7B,IAAI3U,EAAclM,EACdlB,KAAK8oB,sBACL1b,OACwBK,IAApBvM,EAAQ+nB,QACF/nB,EAAQ+nB,QAAQjpB,KAAK8oB,qBAEnB5nB,EAAQ6b,eAAekM,QAAQjpB,KAAK8oB,sBAKpD9oB,KAAK+lB,SAASla,gBAAgBuB,GAAelM,EAChD,CAEDgoB,sBACI,MAAMC,EAAWnpB,KAAK8N,gBACtB,OAAKqb,EAGmB,iBAAbA,EACAnpB,KAAKkB,QAAQ6gB,cAAckH,QAAQE,IAAnC,EAEJvc,MAAcuc,GALV,IAMd,CAEDf,YAAYjC,GACRA,EAAI3d,cAAcyF,UAAU,KACxB,IAAKkY,EAAI7b,aAAc,CACnB,MAAM8e,EAAMppB,KAAK8kB,KACXxc,EAAiBtI,KAAKsI,eACtBoI,EAAc1Q,KAAKmN,qBACnB,CACEH,SAAUhN,KAAKmN,qBAAqBkc,YACpC5iB,QAASzG,KAAKmN,qBAAqBkY,KACnC5Q,cAAezU,KAAKgoB,mBAEtB,KACA1T,EAAUtU,KAAKiN,iBACf,CACED,SAAUhN,KAAKiN,iBAAiBoc,YAChC5iB,QAASzG,KAAKiN,iBAAiBoY,KAC/BvS,UAAW9S,KAAKiN,iBAAiB6F,UACjC2B,cAAezU,KAAKgoB,mBAEtB,KACN7B,EAAI/c,SAAWpJ,KAAKoJ,SACpB+c,EAAItO,SAAW7X,KAAK6X,SACpBsO,EAAI7d,eAC0B,iBAAnBA,GAA+BA,EAChCA,KACAse,MAAqBte,GAC/B6d,EAAIjb,kBAAoBlL,KAAKkL,kBAC7Bib,EAAI9R,aAAerU,KAAKqU,aACxB8R,EACKtY,oBAAoB7N,KAAKkpB,uBACzBhc,wBAAwBwD,GACxB3D,oBAAoBuH,GACpBhF,qBAAqBtP,KAAKyZ,kBAAoB,UAC/C2P,GACAjD,EAAIlX,cAAcma,EAAIvoB,MAE7B,IAGLslB,EAAI3d,cAAc6W,QAAKkJ,MAAK,IAAIta,UAAU,KAEtC,GAAIjO,KAAK4nB,YAEL,YADAzB,EAAIra,WAAW9L,KAAK4nB,YAAY7B,UAKpC,IAAI5X,EAASnO,KAAKkB,QAAQ6gB,cAAchF,cACxC,KAAO5O,GAAQ,CACX,GAAIA,EAAO8G,UAAU7P,SA/Ob,YA+OwC,CAC5C+gB,EAAIra,WAAWic,EAAQxF,eAAezM,KAAKqF,GAChCA,EAAKja,QAAQ6gB,gBAAkB5T,IACtC4X,UAAY,MAChB,KACH,CACD5X,EAASA,EAAO4O,aACnB,GAER,CAEDyI,cAAcW,GACVA,EAAI1d,QAAQwF,UAAUqb,IAClBtpB,KAAKyI,QAAQqe,KAAK,CAAErmB,OAAQT,KAAMyE,MAAO6kB,EAAW7kB,QAGpDzE,KAAK4kB,mBAAmBiC,cAAxB,GAEJV,EAAIzd,SAASuF,UAAUsb,IACnBvpB,KAAK0I,SAASoe,KAAK,CAAErmB,OAAQT,KAAMyE,MAAO8kB,EAAa9kB,OAAvD,GAEJ0hB,EAAIxd,MAAMsF,UAAUub,IAChBxpB,KAAK2I,MAAMme,KAAK,CACZrmB,OAAQT,KACRuL,SAAUie,EAASje,SACnB8E,UAAWmZ,EAASnZ,UACpB5L,MAAO+kB,EAAS/kB,QAIpBzE,KAAK4kB,mBAAmBiC,cAAxB,GAEJV,EAAIvd,QAAQqF,UAAUwb,IAClBzpB,KAAK4I,QAAQke,KAAK,CACd3c,UAAWsf,EAAWtf,UAAUkb,KAChC/R,KAAMtT,KACNmT,aAAcsW,EAAWtW,cAH7B,GAMJgT,EAAItd,OAAOoF,UAAUyb,IACjB1pB,KAAK6I,OAAOie,KAAK,CACb3c,UAAWuf,EAAUvf,UAAUkb,KAC/B/R,KAAMtT,MAFV,GAKJmmB,EAAIrd,QAAQmF,UAAU8Y,IAClB/mB,KAAK8I,QAAQge,KAAK,CACdvT,cAAewT,EAAUxT,cACzBJ,aAAc4T,EAAU5T,aACxBK,kBAAmBuT,EAAUvT,kBAAkB6R,KAC/Clb,UAAW4c,EAAU5c,UAAUkb,KAC/BjS,uBAAwB2T,EAAU3T,uBAClCE,KAAMtT,KACNuL,SAAUwb,EAAUxb,SACpB8E,UAAW0W,EAAU1W,UACrB5L,MAAOsiB,EAAUtiB,OATrB,EAYP,CAED6gB,gBAAgBpC,GACZ,MAAQrL,WAAUvP,iBAAgB4C,oBAAmBmJ,eAAcvG,kBAAiBkZ,mBAAkB8B,sBAAqBrP,oBAAsByJ,EACjJljB,KAAKoJ,SAAW4d,IAA2B,EAC3ChnB,KAAKsI,eAAiBA,GAAkB,EACpCuP,IACA7X,KAAK6X,SAAWA,GAEhB3M,IACAlL,KAAKkL,kBAAoBA,GAEzBmJ,IACArU,KAAKqU,aAAeA,GAEpBvG,IACA9N,KAAK8N,gBAAkBA,GAEvBgb,IACA9oB,KAAK8oB,oBAAsBA,GAE3BrP,IACAzZ,KAAKyZ,iBAAmBA,EAE/B,CAEDgP,wBAEIzoB,KAAKmI,SAASygB,QACTvJ,QAAK+G,MAAUpmB,KAAKmI,WAAN,EAEnBwhB,MAAKhd,IACD,MAAMid,EAAsBjd,EACvBwT,OAAO9T,GAAUA,EAAOub,cAAgB5nB,MACxCuC,IAAI8J,GAAUA,EAAOnL,SAItBlB,KAAKioB,aAAejoB,KAAK8oB,qBACzBc,EAAoB5M,KAAKhd,KAAKkB,SAElClB,KAAK+lB,SAASrZ,YAAYkd,EAA1B,IAVD,EAaHC,MAAWld,MACA6W,SAAS7W,EAAQpK,IAAI+Q,GACjBA,EAAKqU,cAActI,QAAK+G,MAAU9S,QAFxC,EAILgM,MAAUtf,KAAKglB,aACd/W,UAAU6b,IAEX,MAAMC,EAAU/pB,KAAK+lB,SACf1Z,EAASyd,EAAe5oB,QAAQ6gB,cACtC+H,EAAe1gB,SAAW2gB,EAAQjb,cAAczC,GAAU0d,EAAQhb,aAAa1C,EAArB,EAEjE,EAEL0b,SAAQxF,eAAiB,GACzBwF,EAAQpE,UAAR,0BAAoGoE,GAh+BD3nB,MAg+B0BA,OAh+B1BA,MAg+BoDqkB,GAAvJ,IAh+BmGrkB,MAg+B8GwjB,MAh+B9GxjB,MAg+BmIA,OAh+BnIA,MAg+ByJA,OAh+BzJA,MAg+ByLmkB,GAA5R,GAh+BmGnkB,MAg+BqO+mB,MAAxU,GAh+BmG/mB,MAg+BmR4jB,IAh+BnR5jB,MAg+BwSA,OAh+BxSA,MAg+ByUonB,GAA5a,IAh+BmGpnB,MAg+BiYgkB,GAApe,MACA2D,EAAQX,UAj+B2FhnB,MAi+BnG,MAAwF2nB,EAAxF1nB,sEAj+BmGD,MAi+BnG4pB,EAA4oClC,GAA5oC,GAj+BmG1nB,MAi+BnG4pB,EAAmvCnC,GAAnvC,GAj+BmGznB,MAi+BnG4pB,EAAq0CxC,GAAr0C,eAj+BmGpnB,MAi+BnG6pB,EAj+BmG7pB,WAi+BnGE,4BAj+BmGF,MAi+BnG6pB,EAj+BmG7pB,WAi+BnGE,gCAj+BmGF,MAi+BnG6pB,EAj+BmG7pB,WAi+BnGE,oFAj+BmGF,MAi+BnG,+BAj+BmGA,CAi+BnG,uxBAj+BmGA,MAi+B66B,CAAC,CAAEinB,QAASjD,GAAiBmD,YAAaQ,KAj+Bv9B3nB,SA+nB7F2nB,MAmdAmC,SAAN,MAAMA,GAENA,SAAevG,UAAf,0BAA2GuG,EAA3G,EACAA,EAAeC,UArlCoF/pB,MAqlCnG,MAA4G8pB,IAY5GA,EAAeE,UAjmCoFhqB,MAimCnG,WAAuI,CAAC4jB,IAAxIqG,SAA6JC,SAfvJJ,+IErpHF9pB,2BAAgF,oBAK5EA,iCAASmqB,mBAAwB,EAAjCnqB,CAAkC,gEAExBA,uCAAmC,wBAI7CA,8BACFA,gDATEA,uCAA2B,6CAA3BA,CAA2B,4CAQ3BA,uKAGJA,2BACEA,iCAASmqB,mBAAwB,GAIjCnqB,0BAIEA,iCAASmqB,mBAAwB,EAAjCnqB,CAAkC,gEAGxBA,mCAA+B,wBAGzCA,8BACFA,QACAA,2EAYEA,sBACFA,gDAtBEA,uCAA2B,sCAA3BA,CAA2B,4CAO3BA,mDAKAA,8BAAiB,iDAAjBA,CAAiB,mDAAjBA,CAAiB,yDChBnB,MAAOoqB,EACKnF,KACA3lB,OAAmB,CAAC,KAAM,QACnCmB,MACA4pB,SAAU,EACVrhB,UAAW,EACXshB,eAAgB,EAChBC,mBAAqB,IAAIC,OAAiC,GAEjEjC,YAAYC,GACNA,EAAQvD,MAASwF,cACnBrU,WAAW,KACTxW,KAAK8qB,WAAa,IAAIC,KACpB/qB,KAAKgrB,YACLhrB,KAAKirB,cACLrC,EAAQvD,KAAQwF,cAAgB,GAHhB,EAKjB,GAEN,CAEOK,aAAe,CAAC/lB,EAAWgmB,MAE/BC,aAAcjmB,EAAKkmB,UAAYlmB,EAAKkmB,SAASrlB,OAAS,EACtD5D,KAAM+C,EAAK/C,KACX6iB,GAAI9f,EAAK8f,GACTkG,MAAOA,IAIJH,YAAc,IAAIM,MACtBnmB,GAASA,EAAKgmB,MACdhmB,GAASA,EAAKimB,YAGTH,cAAgB,IAAIM,KAC1BvrB,KAAKkrB,aACJ/lB,GAASA,EAAKgmB,MACdhmB,GAASA,EAAKimB,WACdjmB,GAASA,EAAKkmB,UAEVP,WAECU,SAAYC,IAClBC,QAAQC,IAAIF,EAAZ,EAEMG,UAAY,OAEbC,SAAW,CAACC,EAAW3mB,IAA2BA,EAAKimB,WAEvDW,eACL/rB,KAAKgsB,gBACLhsB,KAAKwrB,SAASxrB,KAAKa,MACpB,CAEMorB,WAAWR,GACZA,EACFjV,WAAW,KACTxW,KAAK2qB,mBAAmBuB,YAAYlsB,KAAKgrB,YAAYmB,WACrD,MAAMC,EAAQpsB,KAAKgrB,YAAYmB,UAAUhM,OAAQhb,GAC/CsmB,EAAO3I,KAAMuJ,GAAaA,IAAQlnB,EAAK8f,KAEzCjlB,KAAK2qB,mBAAmB2B,UAAUF,EAAlC,EACC,IAEHpsB,KAAKa,MAAQ,EAEhB,CAED0rB,iBAAiBf,GACfxrB,KAAKwrB,SAAWA,CACjB,CAEDgB,kBAAkBZ,GAChB5rB,KAAK4rB,UAAYA,CAClB,CAEDI,gBACOhsB,KAAKyqB,UACRzqB,KAAK4rB,YACL5rB,KAAKyqB,SAAU,EAElB,CAEMgC,uBAAuBC,GAC5B,MAAMC,EAAc3sB,KAAKgrB,YAAY4B,eAAeF,GAIpD,OAFEC,EAAY3mB,OAAS,KACnB2mB,EAAY7W,KAAM+W,GAAU7sB,KAAK2qB,mBAAmBmC,WAAWD,GAEpE,CAEME,wBAAwB5nB,GAC7BnF,KAAK2qB,mBAAmBqC,OAAO7nB,GAC/B,MAAMwnB,EAAc3sB,KAAKgrB,YAAY4B,eAAeznB,GACpDnF,KAAK2qB,mBAAmBmC,WAAW3nB,GAC/BnF,KAAK2qB,mBAAmB2B,UAAUK,GAClC3sB,KAAK2qB,mBAAmBuB,YAAYS,GAExCA,EAAYtoB,QAASwoB,GAAU7sB,KAAK2qB,mBAAmBmC,WAAWD,IAClE7sB,KAAKitB,yBAAyB9nB,GAC9BnF,KAAKktB,oBACLltB,KAAKwrB,SAASxrB,KAAK2qB,mBAAmBwC,SAAS5qB,IAAK6qB,GAAMA,EAAEnI,IAC7D,CAEMoI,4BAA4BX,GACjC1sB,KAAK2qB,mBAAmBqC,OAAON,GAC/B1sB,KAAKitB,yBAAyBP,GAC9B1sB,KAAKktB,oBACLltB,KAAKwrB,SAASxrB,KAAK2qB,mBAAmBwC,SAAS5qB,IAAK4C,GAASA,EAAK8f,IACnE,CAEOgI,yBAAyBP,GAC/B,IAAIve,EAAkCnO,KAAKstB,cAAcZ,GACzD,KAAOve,GACLnO,KAAKutB,uBAAuBpf,GAC5BA,EAASnO,KAAKstB,cAAcnf,EAE/B,CAEOmf,cAAcZ,GACpB,MAAMc,EAAextB,KAAKytB,SAASf,GAEnC,GAAIc,EAAe,EACjB,OAAO,KAKT,QAASznB,EAFU/F,KAAKgrB,YAAYmB,UAAUnqB,QAAQ0qB,GAAU,EAEvC3mB,GAAK,EAAGA,IAAK,CACpC,MAAM2nB,EAAc1tB,KAAKgrB,YAAYmB,UAAUpmB,GAE/C,GAAI/F,KAAKytB,SAASC,GAAeF,EAC/B,OAAOE,CAEV,CACD,OAAO,IACR,CAEOD,SAAYf,GAA6BA,EAAOvB,MAEhDoC,uBAAuBb,GAC7B,MAAMC,EAAc3sB,KAAKgrB,YAAY4B,eAAeF,GAGlDC,EAAY3mB,OAAS,GACnB2mB,EAAY7W,KAAM+W,GAAU7sB,KAAK2qB,mBAAmBmC,WAAWD,IAG/D7sB,KAAK2qB,mBAAmB2B,OAAOI,GAC/B1sB,KAAK2qB,mBAAmBuB,SAASQ,EACtC,CAEMiB,kBACD3tB,KAAK0qB,cACP1qB,KAAK2qB,mBAAmB2B,UAAUtsB,KAAKgrB,YAAYmB,WAEnDnsB,KAAK2qB,mBAAmBuB,YAAYlsB,KAAKgrB,YAAYmB,WAEvDnsB,KAAKwrB,SAASxrB,KAAK2qB,mBAAmBwC,SAAS5qB,IAAK4C,GAASA,EAAK8f,IACnE,CAEOiI,oBACNltB,KAAK0qB,cACH1qB,KAAK2qB,mBAAmBwC,SAASnnB,SAAWhG,KAAKgrB,YAAYmB,UAAUnmB,MAC1E,4CArKUwkB,EAA4B,+BAA5BA,EAA4BnqB,8FAR5B,CACT,CACEgnB,QAASuG,KACTC,OAAO,EACPtG,eAAauG,OAAW,IAAMtD,MAEjCpqB,4yBD7BHA,iBAAwC,oBAIpCA,6DAA2B,2BACjBE,mBAAiB,GAI3BF,8BACFA,QAEAA,sBACEA,kCAcAA,mCAgCFA,iBAvDEA,0CAA2B,wBAK3BA,oDAGQA,0CAAyB,6BAkBFA,iiCEqDzBA,wBACEA,8BACFA,wCADEA,qFAvBJA,kBAA+E,sBAA/EA,CAA+E,cAIzEA,oEAAaA,gBACrB,EADQA,CAA0B,4DACjBA,oBAAW,wBAHtBA,QAQAA,kCAMEA,wEAAeA,wBAAe,GAG9BA,uBACFA,UAEFA,+BAGFA,8CAnBMA,uEAFAA,yBAA0B,sBAA1BA,CAA0B,8BAU1BA,8BAAiB,kCAQIA,yEAI3BA,eAMC,4BAMGA,gEAAeA,mBAAU,GAEzBA,8BACFA,QACAA,gBACEA,8BACFA,gBAJEA,0DAGAA,yGA9DNA,kBAA2D,WAA3DA,CAA2D,kBAGpDA,8BACHA,QAEAA,kCAKEA,gEAAeA,oBAAW,GAG1BA,8BACAA,uBACFA,UAGFA,yBA0BAA,0BAoBFA,iCA/DkCA,0CAC3BA,uDASDA,2CAEAA,2DAK2CA,yCA2B5CA,gUAsBHA,SACEA,qBAAWA,8BAA6CA,QACxDA,uCAEEA,mEAAaA,oCACnB,GACIA,QACFA,iCANaA,uDAETA,6CAA4B,kEAJlCA,kBACEA,iCAQFA,2CARiBA,6CAA2B,wDAU5CA,kBAAqE,8BAEjEA,mEAAaA,8CACjB,6CAIEA,mCALEA,gEAAiD,sDAAjDA,CAAiD,0BAAjDA,CAAiD,qGAUjDA,+BAEEA,mEAAaA,qCACnB,GAEMA,8BACFA,iCAJEA,8CAAwC,6BAGxCA,6EAUAA,gBAAqE,WAC5DA,8BAA4DA,iBAA5DA,gHANXA,+BAEEA,mEAAaA,8CACnB,GACMA,8BACAA,uBAGFA,iCANEA,uDAEAA,kEACwBA,0HAaxBA,gBAAkE,WACzDA,8BAAgDA,iBAAhDA,oGAPXA,+BAEEA,mEAAaA,6CACnB,GAEMA,8BACAA,uBAGFA,iCAPEA,sDAAgD,4BAGhDA,kEACwBA,uFA9B9BA,kBAAkF,YAE9EA,sCAOFA,QAEAA,kBACEA,sCASFA,QAEAA,kBACEA,sCAUFA,iCA/BKA,sCAUAA,2CAYAA,kFAgBDA,oBAGEA,mEAAaA,oCACrB,GAJMA,iCAGEA,6CAAuC,sEAKzCA,oBAGEA,mEAAaA,oCACrB,GAJMA,iCAGEA,6CAAuC,sEAIzCA,oBAGEA,mEAAaA,oCACrB,wBAJMA,iCAIEA,mEADAA,6CAAuC,0FAK3CA,6CAGEA,6CAAuC,mFA9B7CA,kBAA0D,eAC7CA,8BAAsCA,QACjDA,6BACEA,YACEA,2BAQAA,2BAOAA,2BAOFA,QACAA,8BAOFA,iCAjCWA,sDAEKA,oDAETA,qCAQAA,yCAeFA,+EAjLTA,SACEA,kBAAsB,eACTA,8BAA4BA,QACvCA,6BAAqC,cAIjCA,mEAAaA,kCACnB,wBAJIA,YAUJA,kBAAsB,eACTA,gCAAkDA,QAC7DA,4BACEA,mEAAaA,yCACjB,yBAEGA,UAIHA,4BAmEAA,0BAWAA,0BAUAA,0BAqCAA,2BAoCFA,iCAvLeA,uCAMPA,wEADAA,2CAAqC,iCAQ9BA,oEAGTA,kEADAA,kDAA4C,wCAOPA,oCAmElBA,0DAWAA,8DAUAA,6EAqCiBA,+DAtJ5CA,SACEA,mCA0LFA,0CA1LiBA,0CAAwB,8GAsNvCA,kCAOEA,sEAASA,OAAiB,SAAjBA,UAAuB2tB,iEAAoCA,iBAAkB,GAItF3tB,cAAIA,8BAA6BA,QACjCA,aAAGA,8BAAoCA,iDATvCA,mBAAgB,qGAAhBA,CAAgB,6BAQZA,mCACDA,qEAbPA,kBACEA,0CAcFA,8BARsBA,6EAmCtBA,SACEA,kBAAsB,eACTA,8BAAiDA,QAC5DA,2BACEA,mEAAaA,yCACf,wBAECA,UAEHA,kBAAsB,eAEjBA,+BAA4EA,QAE/EA,4BACEA,mEAAaA,4EACf,yBACCA,UAELA,iCAhBeA,2DAGTA,iEADAA,kDAA4C,eAO3CA,8FAIDA,kEADAA,+HArCNA,kBAAsB,eACTA,8BAA4BA,QACvCA,6BAAqC,cAIjCA,kEAAaA,kCACf,wBAJAA,YASJA,kBAAsB,eACTA,+BAAuDA,QAClEA,8BAAqC,eAIjCA,kEAAaA,qEACf,yBAJAA,YAQJA,6DAtBaA,sCAMPA,wEADAA,2CAOOA,yEAMPA,yEADAA,8EAKSA,+EAsBfA,0BClRI,MAAO4tB,EAgBuB3I,KACxBhmB,aACA4uB,UACAC,kBACAC,eACAC,oBApBFC,SACD3uB,OAASosB,cAAYwC,mBACrBC,kBACAC,UAAW,EACXC,oBACAC,WAAkB,GAClBC,iBAAiC,GACjCC,YAAa,EACbC,aAAwD,GACxDC,kBAAmB,EACnBC,aAAc,EACrBC,iBAAkB,EAClBC,mBAAqB,KAErBnvB,YACkCulB,EACxBhmB,EACA4uB,EACAC,EACAC,EACAC,GALwBpuB,YACxBA,oBACAA,iBACAA,yBACAA,sBACAA,0BACN,CAEJkvB,WACElvB,KAAKgvB,gBAAkBhvB,KAAKqlB,MAAM2J,gBAClChvB,KAAKivB,mBAAqBjvB,KAAKqlB,MAAM4J,mBACjCjvB,KAAKqlB,MAAMkJ,mBACbvuB,KAAKmvB,YAEPnvB,KAAKquB,SAAWruB,KAAKqlB,MAAMgJ,SAC3BruB,KAAKovB,eACN,CAEOD,YACNnvB,KAAKwuB,UAAW,EAEhBxuB,KAAKuuB,kBAAoBvuB,KAAKqlB,KAAKkJ,kBAEnCvuB,KAAKqvB,4BAELrvB,KAAKsvB,aAELtvB,KAAKuvB,uBAELvvB,KAAKwvB,uBAAuBxvB,KAAKuuB,kBAAkBkB,OAE/Cta,MAAMC,QAAQpV,KAAKuuB,kBAAkBmB,gBACvC1vB,KAAKuuB,kBAAkBmB,aAAe,IAGnC1vB,KAAKuuB,kBAAkBmB,aAAa1vB,KAAKivB,sBAC5CjvB,KAAKuuB,kBAAkBmB,aAAa1vB,KAAKivB,oBAAsB,CAAE1vB,MAAO,IAE3E,CAEO+vB,aAE6B,SAAjCtvB,KAAKuuB,kBAAkBkB,OACvBzvB,KAAKuuB,kBAAkBtL,SAASjd,QACa,iBAAtChG,KAAKuuB,kBAAkBtL,QAAQ,KAEtCjjB,KAAKuuB,kBAAkBtL,QAAUjjB,KAAKuuB,kBAAkBtL,QAAQ1gB,IAC7DmqB,GAAgBA,EAAOzH,IAE1BjlB,KAAK2vB,2BAER,CAEON,4BACa,CAAC,QAAS,WAAY,UAC1BO,SAAS5vB,KAAKuuB,kBAAkBkB,SAC7CzvB,KAAK6uB,aAAe7uB,KAAKqlB,MAAMkJ,kBAAkBtL,SAAS1gB,IAAKmqB,KAC7D7rB,MAAO6rB,EACPmD,MAAO,MAGZ,CAEOT,gBACN,MAAMnxB,EAAkC,GACxC+B,KAAKkuB,kBACFrpB,MACAwa,QACC9c,MAAKutB,IACH,UAAWC,KAAYD,GAAKE,QACrBD,EAASE,WACZhyB,EAAM+e,KAAK,CACTiI,GAAI8K,EAAS9K,GACb7iB,KAAM2tB,EAASG,IACf7E,SAAU0E,EAAS1E,SAAS9oB,IAAK4tB,KAE7BlL,GAAIkL,EAAIlL,GACR7iB,KAAM+tB,EAAID,SAMpB,OAAOjyB,KAGVgQ,UAAU,CACThF,KAAOmnB,IACLpwB,KAAKyuB,oBAAsB2B,GAE7BP,MAAQQ,GAAQ3E,QAAQC,IAAI0E,IAEjC,CAED7E,SAASjP,GAEPvc,KAAKuuB,kBAAkBtL,QAAQ1G,GADhBvc,KAAK6uB,aAAatS,GACc1b,MAAMV,OACrDH,KAAKswB,uBACLtwB,KAAKuwB,iBAAiBhU,EACvB,CAEDgU,iBAAiBhU,GACf,MAAMmQ,EAAS1sB,KAAK6uB,aAAatS,GAE3BiU,EAAaxwB,KAAK6uB,aAAa1O,OAAO,CAAC6C,EAAGjd,IAAMid,EAAEniB,QAAU6rB,EAAO7rB,OAASkF,IAAMwW,GACxFmQ,EAAOmD,MAAQW,EAAWxqB,OAAS,0BAA4B,EAChE,CAEMyqB,yBACL,OAAOzwB,KAAK6uB,aAAa/L,KAAM4J,KAAaA,EAAOmD,MACpD,CAEOS,uBACFtwB,KAAKuuB,kBAAkBtL,QAAQjd,SACjChG,KAAK8uB,mBAAqB9uB,KAAKuuB,kBAAkBtL,QAAQ9C,OACtDuQ,GAA6B,KAAdA,EAAGvwB,QACnB6F,OAEL,CAEG2qB,mBAEF,OADc,CAAC,OAAQ,cAAe,SACxBf,SAAS5vB,KAAKuuB,kBAAkB5uB,KAC/C,CAEGixB,qBAEF,OADc,CAAC,OAAQ,cAAe,SACxBhB,SAAS5vB,KAAKuuB,kBAAkB5uB,KAC/C,CAEGkxB,wBAEF,MADc,CAAC,SACFjB,SAAS5vB,KAAKuuB,kBAAkB5uB,KAC9C,CAEGmxB,iBAWF,OAVe,CACb,SACA,OACA,WACA,WACA,SACA,QACA,OACA,YAEalB,SAAS5vB,KAAKuuB,kBAAkBkB,MAChD,CAEOsB,uBACN/wB,KAAKmuB,eAAetpB,MAAMoJ,UAAU,CAClChF,KAAO+nB,IACLhxB,KAAK2uB,iBACHqC,EAAMhB,QAAQ7P,OAAQ8Q,GAAWA,EAAEhM,GAAGiM,aAAelxB,KAAKquB,WAAa,KAG9E,CAEO8C,UAAWC,QAAS/E,EAAK1sB,SAC/B,OAAK0sB,IACQ,YAAT1sB,EACK,oCAAoC0xB,KAAKC,OAAOjF,GAAKlsB,QAEjD,QAATR,GACK,YAAY0xB,KAAKC,OAAOjF,GAAKlsB,QAGvC,CAEMD,aACL,GAAqC,WAAjCF,KAAKuuB,kBAAkBkB,MACzB,KAAIzvB,KAAKmxB,SAASnxB,KAAKuuB,mBAIrB,YADAvuB,KAAK+uB,aAAc,GAFnB/uB,KAAK+uB,aAAc,CAIpB,EAGC/uB,KAAK4uB,YAAe5uB,KAAKuuB,kBAAkBtL,SAASjd,QAKnDhG,KAAKuuB,kBAAkBmB,eAC1B1vB,KAAKuuB,kBAAkBmB,aAAe,IAGxC1vB,KAAKX,aAAaY,MAAM,IACnBD,KAAKuuB,kBACRhvB,MAAOS,KAAKuuB,kBAAkBhvB,MAAMY,UAVpCH,KAAKouB,oBAAoBmD,UAAUvxB,KAAKiuB,UAAUuD,QAAQ,4BAY7D,CAEMC,YAAYvzB,GACjB8B,KAAKuuB,kBAAoBzC,cAAY5tB,GACrC8B,KAAKuuB,kBAAkBhvB,MAAQS,KAAKiuB,UAAUuD,QAAQxxB,KAAKuuB,kBAAkBhvB,OAC7ES,KAAKuuB,kBAAkBmD,aAAe1xB,KAAKiuB,UAAUuD,QACnDxxB,KAAKuuB,kBAAkBmD,cAEzB1xB,KAAKuvB,uBACLvvB,KAAKwvB,uBAAuBxvB,KAAKuuB,kBAAkBkB,MACpD,CAEOD,uBAAuBC,GAC7B,GACO,aADCA,EAEJ,OAAOzvB,KAAK+wB,sBAEjB,CAEMY,aAAa5rB,GAClB/F,KAAKuuB,kBAAkBtL,QAAQnG,OAAO/W,EAAG,GACzC/F,KAAK6uB,aAAa/R,OAAO/W,EAAG,GAC5B/F,KAAKswB,sBACN,CAEMsB,YACA5xB,KAAKuuB,kBAAkBtL,UAASjjB,KAAKuuB,kBAAkBtL,QAAU,IACtEjjB,KAAKuuB,kBAAkBtL,QAAQjG,KAAK,IACpChd,KAAKswB,uBACLtwB,KAAK6uB,aAAa7R,KAAK,CAAEnc,MAAO,GAAIgvB,MAAO,IAC5C,CAEMgC,WACA7xB,KAAKuuB,kBAAkBtL,UAASjjB,KAAKuuB,kBAAkBtL,QAAU,KAClEjjB,KAAKuuB,kBAAkBtL,QAAQ2M,SAAS,WAC5C5vB,KAAKuuB,kBAAkBtL,QAAQjG,KAAK,SACpChd,KAAK6uB,aAAa7R,KAAK,CAAEnc,MAAO,QAASgvB,MAAO,KACjD,CAEOF,2BACN3vB,KAAK6uB,aAAe7uB,KAAKuuB,kBAAkBtL,QAAQ1gB,IAAKuvB,KACtDjxB,MAAOixB,EACPjC,MAAO,MAET7vB,KAAK6uB,aAAaxqB,QAAQ,CAACytB,EAAK/rB,IAAM/F,KAAKuwB,iBAAiBxqB,GAC7D,CAEOwpB,uBACNvvB,KAAK4uB,WAAa,CAAC,WAAY,QAAS,UAAU9L,KAC/CzkB,GAAMA,IAAM2B,KAAKuuB,kBAAkBkB,MAEvC,CAEMsC,oBACL,OAAIzD,yBAAiCtuB,KAAKuuB,oBACjCD,sBAA8BtuB,KAAKuuB,kBAAkBtL,QAG/D,4CA1QU+K,GAAyB5tB,MAgB1B4xB,MAAe5xB,2FAhBd4tB,EAAyB3tB,sgGDrBtCD,sDAUEA,sBACFA,QAEAA,oBAAyBA,mDAEvBA,QACFA,8BACEA,iCA4LFA,QAEAA,iBAAoC,4BAOhCA,gCACFA,QACAA,kCACEA,sCAAeE,cAAY,GAS3BF,gCACFA,UAGFA,4CAmBAA,8CA6CAA,0EA9REA,oDALAA,qBAAiB,sBAAjBA,CAAiB,uBAUMA,kGAIRA,2CAAyB,cAkMtCA,sCAA0B,8BAG1BA,kDAIAA,sLAKC,2BAGDA,u0EEzNFA,kBAA8CA,8BAAgCA,eAAhCA,mFCD1C,MAAO6xB,GASSC,UARXC,OACA9D,SACT+D,SAAmB,GACnBC,gBACAC,eAAgB,EACTC,aAAc,EACdC,MAAQ,iIAEf1yB,YAAoBoyB,mBAAwB,CAE5ChD,WACMlvB,KAAKmyB,SACPnyB,KAAKoyB,SAAW,GAAG/sB,OAAOotB,SAASC,gBAAgB1yB,KAAKmyB,UAGtDnyB,KAAKquB,WACPruB,KAAKoyB,SAAW,GAAG/sB,OAAOotB,SAASC,uBAAuB1yB,KAAKquB,YAGjEruB,KAAKqyB,gBAAkBM,mBAAmB3yB,KAAKoyB,SAChD,CAEDQ,eACE,OAAO,CACR,CAEMC,gBAAgBC,GACrB9yB,KAAKuyB,YAAcvyB,KAAKkyB,UAAUa,KAAKD,GACvCtc,WAAW,IAAOxW,KAAKuyB,aAAevyB,KAAKuyB,YAAc,IAC1D,4CA9BUN,IAAkB7xB,4CAAlB6xB,GAAkB5xB,2rBDR/BD,iBAAsB,eACTA,8BAA0CA,QACrDA,4BACEA,mBACFA,UAGFA,iBAAsB,eACTA,gBAAIA,QACfA,wBACAA,6BAAuF,iBACbA,UAAWA,QACnFA,kCAOEA,sCAAeE,0BAAsB,GAErCF,uBACFA,YAIJA,kBAAsB,4BAQlBA,uBACAA,sBACFA,UAGFA,kBAAsB,4BAUlBA,wBACAA,uBACFA,iBAlDWA,oDAEkBA,mCAMFA,qCACuBA,qDACwBA,wBAKtEA,8BAAiB,0BAgBnBA,iFAaAA,oqBE5BIA,kBAAyD,eAC5CA,8BAA+DA,QAC1EA,6BAAqC,cAGjCA,mEAAaA,wDACrB,EADQA,CAAyD,6DAExCA,uBAAmB,wBAJtCA,qCAFSA,+EAIPA,0EAAyD,2FAoB/DA,kBAAyD,eAC5CA,8BAA8DA,QACzEA,6BAAqC,iBAIjCA,mEAAaA,8DACrB,wBAEMA,6DARSA,8EAKPA,gFAA+D,gGA7CvEA,SACEA,kBAAsB,eACTA,8BAAsCA,QACjDA,6BAAqC,cAGjCA,kEAAaA,qBACrB,EADQA,CAAwB,4DAGPA,uBAAmB,wBALtCA,YAUJA,yBAWAA,kBAAsB,gBACTA,gCAAmCA,QAC9CA,8BAAqC,kBAKjCA,kEAAaA,2BACrB,yBAEMA,qCAIJA,0BAYFA,gCAjDeA,uDAIPA,uCAAwB,iDAAxBA,CAAwB,yCAQPA,oDAYVA,+CAKPA,wDAAuC,6BAAvCA,CAAuC,wDAQtBA,2EAczBA,uEAUEA,kCAGEA,+DAAeA,mBAAU,GAIzBA,gBAAMA,8BAAkCA,QACxCA,uBACFA,cALEA,wCAGMA,sFAMRA,kBAIC,YAEGA,uBAKAA,mBAAyDA,SAIvDA,UAGJA,kBAAkC,4BAM9BA,0FAAeA,uBAAmB,GAGlCA,uBACFA,mDAzBFA,4BAQkCA,uCAAyBA,0JAWvDA,8BAAiB,gEAvBzBA,kBACEA,gDA+BFA,8BA7BsBA,qHAoEhBA,kCAMEA,gFAAeA,uBAAc,GAG7BA,uBACFA,0CAPEA,qBAAiB,iFAlCvBA,kBAMC,YAEGA,uBAKAA,mBAAyDA,SAIvDA,UAGJA,kBAAkC,4BAM9BA,0FAAeA,uBAAmB,GAGlCA,uBACFA,QACAA,yCAWFA,iDAtCAA,sDAA8C,sBASZA,uCAAyBA,0JAWvDA,8BAAiB,qCAYhBA,6FA1CTA,kBAGEA,uEAAsBA,gBAAY,GAGlCA,gDA4CFA,gCA1CsBA,gGA4CpBA,kBAA4BA,8BAAoCA,eAApCA,wFAG9BA,kBAA8E,4BACxCA,+DAAeA,2BAAgB,GACjEA,8BACFA,QACAA,kCAAsDA,+DAAeA,8BAAmB,GACtFA,8BACFA,gBAJEA,wDAGAA,mFAaAA,aAAyB,WAChBA,8BAAwCA,iBAAxCA,0EAOTA,aAAsC,WAC7BA,8BAAiDA,iBAAjDA,mFAOTA,aAAoC,WAC3BA,8BAAiDA,iBAAjDA,qGA1BfA,2CAMEA,kBAAoB,yBACAA,kEAAaA,wBAAqB,GAClDA,8BACAA,sBAGFA,UAEFA,kBAAoB,yBACAA,kEAAaA,qCAAkC,GAC/DA,+BACAA,uBAGFA,UAEFA,mBAAoB,0BACAA,kEAAaA,mCAAgC,GAC7DA,gCACAA,uBAGFA,oCA3BFA,8CAAwC,6BAAxCA,CAAwC,yCAMpBA,0CAChBA,sDACIA,uCAMYA,uDAChBA,gEACIA,oDAMYA,qDAChBA,gEACIA,0EAsBFA,gBACEA,8BACFA,eADEA,wFAWFA,gBACEA,8BACFA,eADEA,6IAWFA,sCAGEA,2DAAqD,6FAXzDA,kBAAsD,yBAGlDA,mEAAaA,+BACrB,GAEQA,8BACFA,QACAA,uBAMFA,iCAZIA,iDAAkC,kCAIlCA,sEAGCA,sEAcHA,gBACEA,8BACFA,eADEA,iHATJA,kBAAsD,yBAGlDA,mEAAaA,2BACrB,GAEQA,8BACFA,QACAA,uBAGFA,iCATIA,6CAA8B,8BAI9BA,kEAEEA,qEA6BFA,yBAAuE,aACxCA,SAAeA,oCADKA,sBACpBA,+CAInCA,kBACEA,uBAAuC,UAEzCA,kDAtFJA,SACEA,kBAAsB,WAAtBA,CAAsB,yBAIhBA,mEAAaA,kCACrB,GAEQA,8BACFA,QACAA,uBAGFA,QACAA,kBAAoB,yBAGhBA,mEAAaA,6BACrB,GAEQA,+BACFA,QACAA,wBAGFA,QACAA,0BAeAA,0BAYFA,QACAA,mBAAsB,gBACTA,gCAAsCA,QACjDA,mBAAyB,mCACyBA,8FAChDA,YAIJA,gCAEEA,8FAA2B,4DACVA,uBAAc,yBAEhCA,QAEDA,mBAAsB,gBACTA,gCAAsDA,QACjEA,8BAAqC,oBAIjCA,+FAA4B,+DACTA,0BAAsB,GAEzCA,iCAGFA,UAEFA,0BAIFA,QACFA,iCApFQA,wDAAyC,qCAIzCA,4DAEEA,iDAMFA,+CAAgC,gCAIhCA,sEAEEA,4CAIeA,mDAeAA,mDAcVA,kDAEkBA,qCAAoB,2BAMjDA,2DAA2C,2BAOhCA,kEAKPA,2CAG6BA,8CAKPA,kEAzFhCA,2CAMEA,mCAyFFA,8BA9FEA,6CAAwC,6BAAxCA,CAAwC,yCAKzBA,2DA0FjBA,0CACEA,6BACFA,8BAFwBA,yCAAoC,0BAC1CA,sIC7QhB,MAAO4yB,GAmCDC,QACAC,aACAC,OACAC,MACAC,gBACApF,UACAqF,eAxCDC,KACAC,OACAC,0BACAxE,mBACAyE,MACAC,OACCC,cAAgB,IAAI1O,MACpB2O,eAAiB,IAAI3O,MACrB4O,oBAAsB,IAAI5O,MAC1B6O,iBAAmB,IAAI7O,MACvB8O,iBAAmB,IAAI9O,MACvB+O,WAAa,IAAI/O,MAE3BmJ,SACA6F,cAA6C,CAC3CrzB,MAAO,WACPoiB,QAAS,IAGXkR,WACAC,mBACAC,gBACAC,QAAS,EACTC,eAAgB,EAChBC,iBACAC,UACAC,kBAAyC,GACzCC,YAA4C,GAC5CC,cACAC,iBAAmB,EACnBC,YACAC,kBAAoB,IAEpBj1B,YACUmzB,EACAC,EACAC,EACAC,EACAC,EACApF,EACAqF,GANAtzB,eACAA,oBACAA,cACAA,aACAA,uBACAA,iBACAA,qBACN,CAEJ2oB,YAAYC,GACNA,EAAQ2K,MACNpe,MAAMC,QAAQpV,KAAKuzB,KAAK7D,gBAC1B1vB,KAAKuzB,KAAK7D,aAAe,IAIzB9G,EAAQqG,qBACLjvB,KAAKuzB,KAAK7D,aAAa1vB,KAAKivB,sBAC/BjvB,KAAKuzB,KAAK7D,aAAa1vB,KAAKivB,oBAAsB,CAAE1vB,MAAO,MAI3DqpB,EAAQ8K,QACV1zB,KAAK20B,YAAc,CACjB,CACEvyB,KAAMpC,KAAKiuB,UAAUuD,QAAQ,iBAC7B3wB,MAAO,WACPm0B,KAAM,UAER,CACE5yB,KAAMpC,KAAKiuB,UAAUuD,QAAQ,sBAC7B3wB,MAAO,WACPm0B,KAAM,QACN/R,QAASjjB,KAAK0zB,MAAMnxB,IAAK0yB,KAErB7yB,KAAM6yB,EAAKC,aACXr0B,MAAOo0B,EAAK7yB,KACZ+yB,QAAuB,UAAdF,EAAK7yB,KACdgH,SAAwB,UAAd6rB,EAAK7yB,WAOrBwmB,EAAQ4K,SACVxzB,KAAKo1B,gBACLp1B,KAAK40B,cAAgB50B,KAAKwzB,OAAO6B,MAEpC,CAEDnG,WACElvB,KAAKs1B,eACLt1B,KAAKquB,SAAWruB,KAAKozB,MAAMmC,SAASC,SAAS3wB,IAAI,OAAS,GAC1D7E,KAAKm0B,WAAan0B,KAAKuzB,KAAK7zB,OAC5BM,KAAKy1B,gBAAgBz1B,KAAKm0B,YAC1Bn0B,KAAK60B,iBAAmB70B,KAAK01B,eAC7B11B,KAAKs0B,OAA4B,SAAnBt0B,KAAKuzB,KAAK5zB,KACpBK,KAAKquB,UAAYruB,KAAKs0B,QACxBt0B,KAAK21B,gBAER,CAEOL,eACN,MAAQM,mBAAoBb,GAAsB/0B,KAAKszB,eAAeuC,uBACtE71B,KAAK+0B,kBAAoB/0B,KAAKszB,eAAewC,aAAaf,EAC3D,CAEOU,gBAAgBtB,GACtB,MAAM4B,EAAyBC,GACf,UAAdA,GAAuC,gBAAdA,EAC3Bh2B,KAAKo0B,mBAAqBD,EAAWhU,OAAQjiB,GAAU63B,EAAsB73B,EAAMyB,OACnFK,KAAKq0B,gBAAkBF,EAAWhU,OAAQjiB,IAAW63B,EAAsB73B,EAAMyB,MAClF,CAEOg2B,iBACN31B,KAAKkzB,aAAa+C,SAASj2B,KAAKquB,UAAUpgB,UAAWmiB,IACnDpwB,KAAKk0B,cAAgB,CACnBrzB,MAAOb,KAAKwzB,OAAO0C,oBAAsB,WAAa,WACtDjT,QAASmN,EAAS7tB,IAAK4zB,GACdn2B,KAAK0zB,MAAM5d,KAAMmf,GAASA,EAAKhQ,KAAOkR,EAAEC,SAAUh0B,MAHxC,EAOxB,CAEDi0B,mBACE,MAAO,CACLnC,cAAel0B,KAAKk0B,cACpBoC,UAAWt2B,KAAKwzB,OAAO8C,UACvBC,cAAev2B,KAAKwzB,OAAO+C,cAC3BC,YAAax2B,KAAKwzB,OAAOgD,YACzBC,iBAAkBz2B,KAAKwzB,OAAOiD,iBAC9BpB,MAAOr1B,KAAK40B,cAEf,CAEOc,eACN,MAAMgB,EAAqB,GAC3B5K,gBAAO9rB,KAAKm0B,WAAaj2B,IACnBA,EAAMy4B,eAAgD,iBAAxBz4B,EAAMy4B,eACtCD,EAAS1Z,KAAK9e,EAAMy4B,cAAcr0B,MAAM,KAAK,GAA7C,GAGGo0B,EAAS1wB,OAAS0D,KAAKuQ,IAAI2c,MAAM,KAAMF,GAAY,CAC3D,CAEOtB,gBACNp1B,KAAK00B,kBAAoB10B,KAAKqzB,gBAAgBwD,eAE9C,MAAMC,EAAWC,aAAaC,QAAQ,GAAGC,uCAEpCj3B,KAAKwzB,OAAO0D,oBACfl3B,KAAKwzB,OAAO0D,kBAAoB,CAC9B9F,QAAS0F,EACTK,UAAW,KAGfn3B,KAAKy0B,UAAY,CACfrD,QAASpxB,KAAKwzB,OAAO0D,kBAAkB9F,QACvCgG,OAAQp3B,KAAKwzB,OAAO0D,kBAAkB9F,QACtC+F,UAAWn3B,KAAKwzB,OAAO0D,kBAAkBC,UACzCE,gBAAiB,CACfr3B,KAAKwzB,OAAO0D,kBAAkB9F,WAC3BpxB,KAAKwzB,OAAO0D,kBAAkBC,YAGrCn3B,KAAKw0B,iBAAmBx0B,KAAKwzB,OAAO0D,kBAAkB9F,OACvD,CAED3d,KAAKhP,GACH+V,GAAgBxa,KAAKq0B,gBAAiB5vB,EAAM8O,cAAe9O,EAAM0O,cAE7D1O,EAAM8O,cAAgB9O,EAAM0O,eAC9BnT,KAAKq0B,gBAAgB5vB,EAAM0O,cAAcmkB,SACvCt3B,KAAKq0B,gBAAgB5vB,EAAM0O,cAAcmkB,SAAW,GAGpD7yB,EAAM8O,cAAgB9O,EAAM0O,eAC9BnT,KAAKq0B,gBAAgB5vB,EAAM0O,cAAcmkB,SACvCt3B,KAAKq0B,gBAAgB5vB,EAAM0O,cAAcmkB,SAAW,GAExDt3B,KAAKu3B,sBACLv3B,KAAKw3B,eAAe/yB,GACpBzE,KAAKy3B,gBACN,CAEOD,eAAe/yB,GACrB,QAASsB,EAAItB,EAAM0O,aAAcpN,EAAI/F,KAAKm0B,WAAWnuB,OAAQD,IAC3D/F,KAAKm0B,WAAWpuB,GAAGuxB,SAAWvxB,EAAI,CAErC,CAED2xB,eAAejzB,GACb,MAAMkzB,EAAUlzB,EAAM5D,MACtBb,KAAK6zB,eAAe/M,KAAK6Q,GACrB33B,KAAKwzB,OAAO0D,kBAAkBC,UAAUrU,KAAM8U,GAAMA,IAAMD,GAC5D33B,KAAKu0B,eAAgB,GAErBv0B,KAAKu0B,eAAgB,EACrBv0B,KAAKy0B,UAAY,CACfrD,QAASuG,EACTP,OAAQO,EACRR,UAAWn3B,KAAKwzB,OAAO0D,kBAAkBC,WAE3Cn3B,KAAKw0B,iBAAmBmD,EACxB33B,KAAKwzB,OAAO0D,kBAAkB9F,QAAUuG,EAE3C,CAEKE,YAAYtb,GAAa,8CACLub,EAAK7E,QAAQ8E,KAAK,CACxCC,MAAOF,EAAK7J,UAAUuD,QAAQ,wCAC9BhyB,YAAa,MAAMs4B,EAAK7J,UAAUuD,QAAQ,wDAG5CsG,EAAKzD,gBAAgBvX,OAAOP,EAAO,GACnCub,EAAKP,sBACLO,EAAKL,iBARwB,IAS9B,CAEGQ,gCACF,QAASj4B,KAAKszB,eAAe4E,2BAA2B,wBAAwBC,OACjF,CAEOZ,sBACNv3B,KAAKm0B,WAAa,IAAIn0B,KAAKo0B,sBAAuBp0B,KAAKq0B,gBACxD,CAED+D,WACoBp4B,KAAKmzB,OAAO4E,KAAK/J,EAA2B,CAC5DlrB,MAAO,OACPu1B,SAAU,IACVC,SAAU,IACVC,WAAY,QACZlT,KAAM,CACJgJ,SAAUruB,KAAKquB,SACfW,iBAAkBhvB,KAAKyzB,6BAIjB+E,cAAcvqB,UAAU,CAChChF,KAAOmnB,IACDA,IACFpwB,KAAKq0B,gBAAgBrX,KAAKhd,KAAKy4B,YAAYz4B,KAAKm0B,WAAY/D,IAC5DpwB,KAAKm0B,WAAWnX,KAAKhd,KAAKy4B,YAAYz4B,KAAKm0B,WAAY/D,IAAvD,GAIP,CAEDqI,YAAYx6B,EAAiCy6B,GAC3C,MAAMC,EAAc16B,EAAM26B,OAAO,CAAC3e,EAAK4e,IAC9BA,EAAQvB,SAAWrd,EAAM4e,EAAQvB,SAAWrd,EAClD,GAEHye,SAAUpB,SAAWqB,EAAc,EAC5BD,CACR,CAEDvJ,UAAUZ,EAAwBuK,GACd94B,KAAKmzB,OAAO4E,KAAK/J,EAA2B,CAC5DlrB,MAAO,OACPu1B,SAAU,IACVC,SAAU,IACVC,WAAY,QACZlT,KAAM,CACJkJ,kBAAmBzC,cAAYyC,GAC/BF,SAAUruB,KAAKquB,SACfW,iBAAkBhvB,KAAKyzB,0BACvBxE,mBAAoBjvB,KAAKivB,sBAInBuJ,cAAcvqB,UAAU,CAChChF,KAAOmnB,IACDA,IAC6B,CAAC,EAAG,GAClBR,SAASQ,EAASkH,UACjCt3B,KAAKo0B,mBAAmB0E,GAAO1I,EAE/BpwB,KAAKq0B,gBAAgByE,GAAO1I,EAE9BpwB,KAAKu3B,sBACLv3B,KAAKy3B,iBAAL,GAIP,CAEOA,iBACNz3B,KAAKuzB,KAAK7zB,OAASM,KAAKm0B,WACxBn0B,KAAKi0B,WAAWnN,KAAK9mB,KAAKuzB,KAC3B,CAEMwF,eACL/4B,KAAK4zB,cAAc9M,KAAK9mB,KAAK40B,cAC9B,CAEMoE,WAAWzF,GAChBvzB,KAAK+zB,iBAAiBjN,KAAKyM,GAC3BvzB,KAAKg0B,iBAAiBlN,MAAK,EAC5B,CAEMmS,cAAc1F,GACnB,MAAM2F,EAAMpN,cAAYyH,GACxB2F,EAAI35B,MAAQ,GACZ25B,EAAI15B,YAAc,GAClBssB,SAAOoN,EAAIx5B,OAASxB,IACdA,WACKA,EAAM+mB,UACN/mB,EAAMi7B,WACNj7B,EAAMyC,IACbzC,EAAMy4B,cAAmB32B,KAAKo5B,eAAL,GAG7Bp5B,KAAK8zB,oBAAoBhN,KAAKoS,EAC/B,CAEOE,eACN,MAAMnU,EAAK,cAAgBjlB,KAAK60B,iBAChC,YAAKA,mBACE5P,CACR,CAEMoU,YAAYx4B,GACjBb,KAAKg0B,iBAAiBlN,KAA6B,IAAxBjmB,EAAMV,OAAO6F,OACzC,4CAlUUgtB,IAAmB5yB,mHAAnB4yB,GAAmB3yB,6yGDnChCD,iBAAuD,oBAAvDA,CAAuD,oCAGjDA,mCAqDAA,+BAEAA,iBAA6B,QAEzBA,oDAKFA,QACAA,yCAUFA,QAEAA,yBAkCAA,yBAmDAA,4CAIAA,yBAQFA,QACAA,gCA+BAA,8BAgGAA,8BAGFA,kCAlTgBA,uCAELA,uDAAwC,8BAChCA,iCAqDFA,gCAITA,+IAWCA,mDAOiCA,mEAsCnCA,mEAA0B,cAmDKA,8DAWjCA,iCA+BAA,gCA8FOA,k+GEhQJA,qBACEA,8BACFA,eADEA,oIAEFA,mDAEEA,iEAA2D,wGAOjEA,kBAAyD,eAC3CA,8BAAiEA,QAC7EA,6BAAqC,cAKjCA,4DAAUA,2CAAkC,OAAMmqB,GAAS,wBAJ7DnqB,2CAFUA,kFAIRA,8DAAgD,0HAAhDA,CAAgD,yFAyBtDA,kBAAyD,eAC3CA,8BAAiEA,QAC7EA,6BAAqC,iBAQjCA,4DAAUA,2CAAkC,cAAamqB,GAAS,wBAGpEnqB,iEAZUA,kFAORA,8DAAgD,iIAAhDA,CAAgD,gGAzE1DA,iCAMEA,+DAAcA,sBAAkB,EAAhCA,CAAiC,4DAEhBA,uBAAmB,EAFpCA,CAAiC,6DAGfA,0BAAsB,GAIxCA,YACEA,kBAAsB,eACTA,8BAAwCA,QACnDA,6BACEA,yCAMAA,gCAGAA,gCAMFA,UAGFA,0BAaAA,mBAAsB,gBACTA,gCAAsCA,QACjDA,8BAAqC,wCAWnCA,mCAIJA,0BAgBFA,QACFA,wCAhFEA,yBAAiB,gBAAjBA,CAAiB,YAAjBA,CAAiB,wBAAjBA,CAAiB,wDAAjBA,CAAiB,2CAaFA,yDAKPA,+DAAgD,yCAGtCA,gFAITA,yFAQgBA,oDAcVA,kDAOPA,gEAAgD,wBAAhDA,CAAgD,yCAS/BA,8FAsB3BA,kCAGEA,yDAASA,kBAAS,GAIlBA,gBAAMA,8BAAmCA,QACzCA,uBACFA,cALEA,gCAGMA,uFAMRA,8BAKEA,sEAAoBA,sBAAkB,EAAtCA,CAAuC,mEAChBA,yBAAqB,EAD5CA,CAAuC,gEAEnBA,6BAAyB,GAC9CA,+CANCA,gBAAa,wDAAbA,CAAa,sEAHjBA,SACEA,qCASFA,8BARqBA,oEAWnBA,kBAA4BA,8BAAmCA,eAAnCA,oEAG9BA,sGC3Gak5B,GAAmB,MAAnBA,WAA4BC,KAqBlBjG,eACAkG,kBACXC,YACAC,OACAvG,OACAC,MACAjF,eACA+E,aACAyG,aACAC,aACAvG,gBACAZ,SA/BeoH,WAClBC,aACP7K,mBACOzvB,YACA4C,KACA23B,KACAC,QAAS,EAChBtG,MAAsB,GACtBrF,SACA4L,gBAAoC,GACpCC,SACAC,aACO1F,UACA2F,gBACAC,gBACAC,gBAAiB,EACjBC,WAAY,EACnB9G,2BAA4B,EAE5B3zB,YACqBwzB,EACAkG,EACXC,EACAC,EACAvG,EACAC,EACAjF,EACA+E,EACAyG,EACAC,EACAvG,EACAZ,GAER+H,MAAMlH,EAAgBkG,GAbHx5B,sBACAA,yBACXA,mBACAA,cACAA,cACAA,aACAA,sBACAA,oBACAA,oBACAA,oBACAA,uBACAA,gBAGRA,KAAKy6B,eAELz6B,KAAK+5B,KAAO/5B,KAAKy5B,YAAYiB,MAAM,CACjCt4B,KAAM,CAAC,GAAI,CAACu4B,cAAqBC,SAAuBC,WACxDr7B,YAAa,CAAC,IACd61B,MAAO,CAAC,MACR6B,kBAAmBl3B,KAAKy5B,YAAYiB,MAAM,CACxCtJ,QAAS,CAAC,MACV+F,UAAW,CAAC,MAEd2D,MAAO,CAAC,IACRC,cAAe,CAAC,IAChBtE,iBAAkB,EAAC,GACnBP,oBAAqB,EAAC,GACtBxG,aAAc,CAAC,IACfsL,WAAY,CAAC,IACb5xB,SAAU,EAAC,GACXotB,YAAa,EAAC,GACdD,cAAe,EAAC,GAChBD,UAAW,EAAC,GACZ2E,gBAAiB,EAAC,GAClBt7B,KAAM,CAAC,KAEV,CAEDu7B,WAAmB,CAEX9F,cAAc+F,GACpBn7B,KAAKy0B,UAAYz0B,KAAKqzB,gBAAgBwD,eACtC72B,KAAKo6B,gBAAkBp6B,KAAKy0B,UAAU3e,KACnCslB,GAASA,EAAKC,KAAK/4B,MAAM,KAAK,KAAO64B,EAAiB/J,QAAQ9uB,MAAM,KAAK,IAE5EtC,KAAK85B,aAAe95B,KAAKo6B,gBACzB,MAAMkB,EAAiBH,EAAiBhE,UAClCC,EAASp3B,KAAKo6B,gBAAkB,CAACp6B,KAAKo6B,iBAAmB,GAC3DkB,EAAet1B,QACjBs1B,EAAej3B,QAASk3B,IACtBnE,EAAOpa,KACLhd,KAAKy0B,UAAU3e,KAAMslB,GAASA,EAAKC,KAAK/4B,MAAM,KAAK,KAAOi5B,EAASj5B,MAAM,KAAK,IADhF,GAKJtC,KAAKq6B,gBAAkBjD,CACxB,CAEMlI,WACLlvB,KAAKw7B,YACL,MAAMvW,EAAKjlB,KAAKozB,MAAMmC,SAASC,SAAS3wB,IAAI,MACxCogB,GACFjlB,KAAKquB,SAAWpJ,EAChBjlB,KAAKg6B,SAAW/U,EAChBjlB,KAAKmuB,eAAesN,cAAcxW,GAAIhX,UAAU,CAC9ChF,KAAOmnB,IACLpwB,KAAK07B,WAAWtL,EAAS1P,QACzB1gB,KAAKo1B,cAAchF,EAAS1P,OAAOwW,mBACnCl3B,KAAK27B,WAAL,MAIJ37B,KAAKo1B,cAAc,CAAE+B,UAAW,GAAI/F,QAAS,OAC7CpxB,KAAK27B,WAAU,GAElB,CAEOA,UAAUC,GAAQ,GAGxB,GAFA57B,KAAKm6B,aAAen6B,KAAK+5B,KAAKl5B,MAE1B+6B,EAAO,CACT,MAAMC,EAAc/P,cAAYwC,kBAChCtuB,KAAK+5B,KAAK+B,WAAW,CAAEhB,MAAO,CAACe,IAChC,CAED77B,KAAKk6B,SAAWl6B,KAAK+5B,KAClBl1B,IAAI,UACHhE,MAAMsf,OAAQ4b,GAAiC,SAAXA,EAAEp8B,MAAiB,GAC3DK,KAAKi6B,gBAAkBj6B,KAAK+5B,KACzBl1B,IAAI,UACHhE,MAAMsf,OAAQ4b,GAAiC,SAAXA,EAAEp8B,MAC1CK,KAAK+5B,KAAKiC,SAASlB,MAASmB,aAAa5c,QAAK6c,KAAel8B,OAAOiO,UAAWD,IAC7EhO,KAAKi6B,gBAAkBjsB,EAAOmS,OAAQ4b,GAAiC,SAAXA,EAAEp8B,KAAvC,EAE1B,CAED+7B,WAAWrW,GACT8W,OAAOC,KAAK/W,GAAMhhB,QAAS1D,IACrBX,KAAK+5B,KAAKiC,SAASr7B,IACrBX,KAAK+5B,KAAKiC,SAASr7B,GAAKm7B,WAAWzW,EAAK1kB,GAAxC,EAGL,CAED07B,WAAWhX,GACT,IAAIyV,EAAQ96B,KAAK+5B,KAAKiC,SAASlB,MAASj6B,MACxCi6B,EAAQA,EAAMv4B,IAAKgxB,GAAeA,EAAKtO,KAAOI,EAAKJ,GAAKI,EAAOkO,GAE/DvzB,KAAK+5B,KAAK+B,WAAW,CACnBhB,MAAOA,GAEV,CAEOwB,eAAel6B,GACrB,OAAOpC,KAAK+5B,KAAKiC,SAAS55B,EAC3B,CAEMm6B,iBACav8B,KAAKmzB,OAAO4E,KAAKyE,MAA+B,CAChE15B,MAAO,OACPu1B,SAAU,IACVE,WAAY,CAAC,QAAS,0BACtBlT,KAAM,CACJoP,UAAWz0B,KAAKy0B,UAChB4F,gBAAiBr6B,KAAKq6B,gBACtBD,gBAAiBp6B,KAAKo6B,mBAIhB5B,cAAcvqB,UAAU,CAChChF,KAAOwzB,IACL,IAAKA,EAAmB,OACxBz8B,KAAKs8B,eAAe,qBAAqBz7B,MAAMs2B,UAAYsF,EACxDtc,OAAQ2W,GAAaA,EAASuE,OAASr7B,KAAKo6B,iBAAiBiB,MAC7D94B,IAAKu0B,GAAaA,EAASuE,MAC9B,MAAM3L,EAAoB,GAC1B+M,EACGtc,OAAQ2W,GAAaA,EAASuE,OAASr7B,KAAKo6B,iBAAiBiB,MAC7D94B,IAAKu0B,IACJpH,EAAaoH,EAASuE,MAAQ,CAC5Bj5B,KAAMpC,KAAKs8B,eAAe,gBAAgBz7B,MAAMi2B,EAASuE,OAAOj5B,MAAQ,GACxE5C,YACEQ,KAAKs8B,eAAe,gBAAgBz7B,MAAMi2B,EAASuE,OAAO77B,aAAe,GAH/C,GAMlCQ,KAAKs8B,eAAe,gBAAgBI,SAAShN,GAC7C1vB,KAAK28B,kBAAkBF,EAAkBA,EAAkBz2B,OAAS,GAApE,GAGL,CAEM22B,kBAAkB7F,GACvB92B,KAAKivB,mBAAqB6H,EAASuE,KACnCr7B,KAAK85B,aAAehD,EACpB92B,KAAKoC,KAAOpC,KAAKR,YAAc,GAC/BQ,KAAKyzB,0BAA4BzzB,KAAKivB,qBAAuBjvB,KAAKo6B,iBAAiBiB,IACpF,CAEMuB,cAAcC,EAAsB3+B,EAAeuG,GACxD,MAAMirB,EAAe1vB,KAAKs8B,eAAe,gBAAgBz7B,MACzD,UAAWF,KAAO+uB,EACZ/uB,IAAQk8B,IACVnN,EAAa/uB,GAAO,IACf+uB,EAAa/uB,GAChBo7B,CAAC79B,GAAQuG,EAAMC,OAAO7D,OAExBb,KAAK+5B,KAAK+B,WAAW,CACnBpM,aAAcA,IAIrB,CAED8L,YACEx7B,KAAK25B,aAAa1D,WAAWhoB,UAAWmiB,IACtCpwB,KAAK0zB,MAAQtD,EAASJ,SAEzB,CAED8M,UAAUC,EAAgB7I,GACxB,MAAM8I,EAAah9B,KAAK0zB,MAAM5d,KAAMqgB,GAAsB,UAAXA,EAAE/zB,OAE9CpC,KAAKs8B,eAAe,uBAAuBz7B,QAC3CqzB,GAAepR,KAAMqT,GAAMA,GAAG/zB,OAAS46B,EAAM56B,OAE9C8xB,GAAelX,KAAKggB,QAEAvvB,IAAlBymB,GACFl0B,KAAKkzB,aACF+J,YACCF,EACA7I,EAAc3xB,IAAK4zB,GAAWA,GAAGlR,KAElChX,WAEN,CAED4lB,eAAepvB,GACbzE,KAAKo6B,gBAAkBp6B,KAAKy0B,UAAU3e,KACnC8hB,GAAMA,EAAEyD,KAAK/4B,MAAM,KAAK,KAAOmC,EAAM5D,MAAMyB,MAAM,IAAI,KAExDtC,KAAK85B,aAAe95B,KAAKo6B,gBACzB,MAAMkB,EAAiBt7B,KAAK+5B,KAAKiC,SAAS9E,kBAAqBr2B,MAAMs2B,UAC/DC,EAASp3B,KAAKo6B,gBAAkB,CAACp6B,KAAKo6B,iBAAmB,GAC3DkB,EAAet1B,QACjBs1B,EAAej3B,QAASk3B,IACtBnE,EAAOpa,KACLhd,KAAKy0B,UAAU3e,KAAMslB,GAASA,EAAKC,KAAK/4B,MAAM,KAAK,KAAOi5B,EAASj5B,MAAM,KAAK,IADhF,GAKJtC,KAAKq6B,gBAAkBjD,CACxB,CAEM8F,OACLl9B,KAAKu6B,WAAY,EACjB,MAAM4C,EAAqBn9B,KAAK65B,WAAWrF,iBAC3C,GAAIx0B,KAAKo9B,sCAAuC,CAC9Cp9B,KAAK+5B,KAAK+B,WAAW,CACnBf,cAAeoC,IAGjB,MAAMjJ,EAAgBl0B,KAAK65B,WAAW3F,cAAcjR,SAAS1gB,IAAK4zB,GAChEn2B,KAAK0zB,MAAM5d,KAAMmf,GAASA,EAAK7yB,OAAS+zB,IAGpCkH,EAAUlB,OAAOmB,OACrB,GACA,IACKt9B,KAAK+5B,KAAKl5B,MACbuB,KAAMpC,KAAK+5B,KAAKl5B,MAAMuB,KAAKjC,OAC3BX,YAAaQ,KAAK+5B,KAAKl5B,MAAMrB,YAAYW,OACzC+1B,qBAAsBhC,GAAeluB,QAEvChG,KAAK65B,WAAWxD,oBAElBr2B,KAAKmuB,eAAeoP,WAAWF,EAASr9B,KAAKquB,UAAUpgB,UAAU,CAC/DhF,KAAOmnB,IACLpwB,KAAK07B,WAAWtL,EAAS1P,QACzB1gB,KAAK88B,UAAU1M,EAAS1P,OAAOuE,GAAIiP,GACnCl0B,KAAK05B,OAAO8D,SAAS,CAAC,oBAAtB,EAEF3N,MAAO,EAAGA,YACR7vB,KAAKu6B,WAAY,EACW,MAAxB1K,EAAM4N,OAAOC,QACf19B,KAAK+5B,KAAKiC,SAAS55B,KAAQu7B,UAAU,CAAEC,mBAAmB,IAC1D59B,KAAK45B,aAAarI,UAAU,uDAE5BvxB,KAAK45B,aAAarI,UAAUsM,KAAKC,UAAUjO,EAAMztB,KAAK,IAAtD,GAIP,MACCpC,KAAK45B,aACFrI,UAAU,yQAGhB,CAEMxxB,SACDC,KAAK+9B,UACP/9B,KAAK05B,OAAO8D,SAAS,CAAC,qBAEtBx9B,KAAKyyB,SAASuL,MAEjB,CAEDC,UACoBj+B,KAAKmzB,OAAO4E,KAAK34B,GAA0B,CAC3D0D,MAAO,OACPu1B,SAAU,IACVC,SAAU,IACVC,WAAY,UAGJC,cAAcvqB,UAAU,CAChChF,KAAOmnB,IACL,GAAIA,EAAU,CACZ,MAAM0K,EAA0B96B,KAAKs8B,eAAe,SAASz7B,MAC7Di6B,EAAM9d,KAAKoT,GACXpwB,KAAK+5B,KAAK+B,WAAW,CAAEhB,SACxB,IAGN,CAEDsC,sCACE,MAAM9B,EAAwBt7B,KAAKs8B,eAAe,qBAAqBz7B,MAAMs2B,UACvE2D,EAA0B96B,KAAKs8B,eAAe,SAASz7B,MAC7D,OAAOy6B,EAAelb,MAAO0W,GACpBgE,EAAM1a,MAAO2b,GACXA,EAAEr8B,OAAO0gB,MAAO8d,IAEnB5P,0BAAkC4P,EAAGpH,KACrCxI,yBAAiC4P,IAE1B5P,sBAA8B6N,OAAO1Q,OAAOyS,EAAExO,aAAaoH,GAAU7T,YAOrF,CAEDkb,6BACE,MAAM7C,EAAwBt7B,KAAKs8B,eAAe,qBAAqBz7B,MAAMs2B,UACvEzH,EAAe1vB,KAAKs8B,eAAe,gBAAgBz7B,MAEzD,OAAOy6B,EAAelb,MAAO0W,GACpBpH,EAAaoH,IAAW10B,KAElC,CAEMg8B,YAAY/I,GACjBr1B,KAAK+5B,KAAK+B,WAAW,CAAEzG,SACxB,CAEM2D,WAAWzF,GAChB,MAAMuH,EAA0B96B,KAAKs8B,eAAe,SAASz7B,MACvD0b,EAAQue,EAAM94B,QAAQuxB,GAC5BuH,EAAMhe,OAAOP,EAAO,GACpBvc,KAAK+5B,KAAK+B,WAAW,CAAEhB,SACxB,CAEM7B,cAAc1F,GACnB,MAAMuH,EAA0B96B,KAAKs8B,eAAe,SAASz7B,MAC7Di6B,EAAM9d,KAAKuW,GACXvzB,KAAK+5B,KAAK+B,WAAW,CAAEhB,SACxB,CAEMuD,kBAAkB55B,GACvBzE,KAAKs6B,eAAiB71B,CACvB,4CAnWU60B,IAAmBl5B,8KAAnBk5B,GAAmBj5B,ijEDhChCD,kBAIEA,iDAA0BE,QAAM,GAKhCF,kBACAA,iCASEA,4CAAqBE,kBAAgB,EAArCF,CAAsC,wCAChBE,sBAAyB,wBAEjDF,QAEAA,sCAmFFA,QAEAA,iBAA6B,QACvBA,8BAAgCA,QACpCA,wCAUFA,QAEAA,kCAYAA,4CAIAA,yBAEAA,kBAA6D,6BAIzDA,sCAAeE,UAAQ,GAGvBF,gCACFA,QACAA,mCACEA,sCAAeE,QAAM,GAIrBF,gCACFA,UAGFA,gBAAmCA,iBAAIA,sCA7JrCA,0BAAkB,mEAShBA,wFAA8E,+EAA9EA,CAA8E,yBAA9EA,CAA8E,oBAA9EA,CAA8E,uBAA9EA,CAA8E,kCAA9EA,CAA8E,8BAA9EA,CAA8E,qCAoB7EA,kCA+ECA,2CAMDA,mDAOUA,6EAA+B,cAgBXA,oCAO/BA,mDAEAA,kDAIAA,0FAAyE,kCAGzEA,0EAICA,kuCC/HQk5B,MAAmBgF,UAN/BC,QAAY,EAMmBD,2BAqBOE,KACGC,IACjBC,KACLC,KACAC,KACDC,KACSC,KACFC,KACAC,KACAC,KACGC,KACPC,QAhCT7F,sDCZbl5B,kEAYIA,2BAGEA,iCAASmqB,mBAAwB,EAAjCnqB,CAAkC,0EACxBA,2BAA6B,GACxCA,gHAdHA,iBASEA,kCAMAA,SACFA,6CAXEA,qCAAoC,8BAApCA,CAAoC,oCAKjCA,uCAKHA,0DAhBJA,gBACEA,wBAiBFA,8BAlB0DA,+BAKnCA,8EAcvBA,qBAEEA,yDAASA,mBAAU,GAInBA,uBACAA,gBAAMA,8BAAiCA,gBAAjCA,kEAGRA,sBCpCag/B,GAAgB,MAAhBA,GAiBQjR,eACAF,UACAoR,oBACA7F,kBAnBZ8F,WACAC,QAAwB,GACxBC,gBAAgC,GAChCC,eAAgB,EAEhBC,OAAS,CACdC,KAAM,EACNxhC,MAAO,MACPyhC,MAAO,EACPC,aAAc,EACdC,UAAW,EACXC,MAAO,GAEFC,WAAY,EAEnBlgC,YACmBquB,EACAF,EACAoR,EACA7F,GAHAx5B,sBACAA,iBACAA,2BACAA,yBAEjBA,KAAKs/B,WAAat/B,KAAKw5B,kBAAkB8F,WAAWjgB,QAAK6c,KAAel8B,MACzE,CAEDkvB,WACElvB,KAAKigC,YACN,CAEOA,WAAWC,GAAQ,GACzBlgC,KAAKggC,WAAY,EACjBhgC,KAAKmuB,eACF8R,WAAW,GAAI,CACdN,KAAM3/B,KAAK0/B,OAAOC,KAClBxhC,MAAO6B,KAAK0/B,OAAOvhC,MACnByhC,MAAO5/B,KAAK0/B,OAAOE,QAEpB3xB,UAAU,CACThF,KAAO6mB,IACL9vB,KAAKu/B,QAAUW,EAAQ,IAAIlgC,KAAKu/B,WAAYzP,EAAIE,SAAWF,EAAIE,QAC/D,MAAQ6P,aAAcM,EAAaL,UAAWM,EAAUL,SAAUjQ,EAAIuQ,KACtErgC,KAAK0/B,OAAS,IAAK1/B,KAAK0/B,OAAQG,aAAcM,EAAaL,UAAWM,EAAUL,SAChF//B,KAAKggC,WAAY,GAEnBnQ,MAAQQ,IACN3E,QAAQC,IAAI0E,GACZrwB,KAAKggC,WAAY,IAGxB,CAEMM,kBAEL,GADAtgC,KAAKggC,WAAY,EACmB,IAAhChgC,KAAKw/B,gBAAgBx5B,OAAc,OAEvC,MAAMwtB,EAAqBxzB,KAAKw/B,gBAAgBe,QAC1CC,EAAkB,IAAKhN,EAAQvO,GAAI,KAAM7iB,KAAM,GAAGoxB,EAAOpxB,oBAC/DpC,KAAKmuB,eAAesS,KAAKD,GAAiBvyB,UAAU,CAClDhF,KAAM,KACJjJ,KAAKigC,YAAL,EAEFpQ,MAAQQ,IACN3E,QAAQC,IAAI0E,GACZrwB,KAAKggC,WAAY,IAGtB,CAEKU,eAAY,8CACQ5I,EAAKuH,oBAAoBtH,KAAK,CACpDC,MACEF,EAAK0H,gBAAgBx5B,OAAS,EAC1B,oDACA8xB,EAAK7J,UAAUuD,QAAQ,iCAC7BhyB,YAAa,gBAETs4B,EAAK0H,gBAAgBx5B,OAAS,EAC1B,qFACA8xB,EAAK7J,UAAUuD,QAAQ,oDAI/BmP,kBAAmB7I,EAAK7J,UAAUuD,QAAQ,kBAC1CoP,iBAAkB9I,EAAK7J,UAAUuD,QAAQ,uBAI3CsG,EAAKkI,WAAY,KACjBa,MACE/I,EAAK0H,gBAAgBj9B,IAAKixB,IACxBsE,EAAK3J,eAAe2S,kBAAkBtN,EAAOvO,IACtC6S,EAAK3J,eAAeuS,aAAalN,EAAOvO,OAGhD5F,QAAKkJ,MAAK,IACVta,UAAU,CACThF,KAAM,KACJ6uB,EAAKmI,aACLnI,EAAK0H,gBAAkB,IAEzB3P,MAAQ7M,IACN0I,QAAQC,IAAI3I,GACZ8U,EAAKkI,WAAY,KAlCP,IAqCjB,CAEMe,eAAgB5L,WAA8B3B,GAC/C2B,EACFn1B,KAAKw/B,gBAAgBxiB,KAAKwW,GAE1BxzB,KAAKw/B,gBAAkBx/B,KAAKw/B,gBAAgBrf,OAAQ8Q,GAAMA,EAAEhM,KAAOuO,EAAOvO,GAE7E,CAEM+b,YAAYv8B,GACjBzE,KAAKy/B,cAAgBh7B,CACtB,CAEMw8B,WACDjhC,KAAK0/B,OAAOG,aAAe7/B,KAAK0/B,OAAOI,YACzC9/B,KAAK0/B,OAAOC,MAAQ,EACpB3/B,KAAKigC,YAAW,GAEnB,CAEMiB,eAAe9+B,GACpB,OAAOA,EAAK++B,QAAQ,KAAM,KAAKp/B,aAChC,4CAhIUq9B,IAAgBh/B,8EAAhBg/B,GAAgB/+B,s7BDf7BD,iCAIEA,+CAAuBE,gBAAmB,EAA1CF,CAA2C,+BAC7BE,gBAAc,GAE5BF,iCAMEA,sCAAeE,mBAAiB,GAEhCF,sBACAA,kBAA0BA,8BAAiCA,YAI/DA,gCAEAA,uBAmBAA,2BAUAA,iDAlDEA,qCAA+B,uCAA/BA,CAA+B,kCAU7BA,mDAAoC,yCAKVA,4CAIAA,sDAEMA,wCAuBjCA,8EAM0BA,4rECpChBg/B,MAAgBd,UAN5BC,QAAY,EAMgBD,2BAiBQQ,KACLsC,KACUC,KACF5C,OApB3BW,ICTb,MAAMkC,GAAiB,CACrB,CAAEC,KAAM,GAAIC,UAAWpC,IACvB,CAAEmC,KAAM,SAAUC,UAAWlI,GAAqBjU,KAAM,CAAEoc,WAAY,kBACtE,CAAEF,KAAM,aAAcC,UAAWlI,GAAqBjU,KAAM,CAAEoc,WAAY,mBAOtE,MAAOC,iDAAoB,+BAApBA,sCAHDC,cAAsBL,IACtBK,QC6DN,MAAOC,iDAAa,+BAAbA,sCA7BTnjC,KACAojC,MACA3X,GACAwX,GACAI,KACAC,gBACAjjC,KACAK,KACA6iC,KACAC,KACAvjC,IACAE,KACAI,EACAkjC,KACAC,MACAC,KACAC,KACAC,KACAC,MACAC,KACAhkC,EACAikC,MACAC,KACAzjC,KACAC,MACAH,KACA4jC,SAGsB","names":["SortByFieldPipe","transform","array","field","order","sort","a","b","pure","ColorPickerComponentModule","CommonModule","MatInputModule","MatMenuModule","FormsModule","ColorPickerModule","MatButtonModule","MzimaUiModule","MultilevelSelectModule","MatTreeModule","MatListModule","MatIconModule","CreateTaskModalComponent","matDialogRef","newTask","label","description","required","fields","type","show_when_published","task_is_internal_only","constructor","cancel","this","close","addNewTask","trim","i0","selectors","ctx","extendStyles","dest","source","importantProperties","key","hasOwnProperty","value","setProperty","has","removeProperty","toggleNativeDragInteractions","element","enable","userSelect","style","toggleVisibility","position","top","opacity","left","combineTransforms","initialTransform","parseCssTimeUnitsToMs","multiplier","toLowerCase","indexOf","parseFloat","parseCssPropertyValue","computedStyle","name","getPropertyValue","split","map","part","getMutableClientRect","clientRect","getBoundingClientRect","right","bottom","width","height","x","y","isInsideClientRect","adjustClientRect","isPointerNearClientRect","rect","threshold","pointerX","pointerY","xThreshold","yThreshold","ParentPositionTracker","_document","positions","Map","clear","cache","elements","set","scrollPosition","getViewportScrollPosition","forEach","scrollTop","scrollLeft","handleScroll","event","target","_getEventTarget","cachedPosition","get","newTop","newLeft","viewportScrollPosition","topDifference","leftDifference","node","contains","window","scrollY","scrollX","deepCloneNode","clone","cloneNode","descendantsWithId","querySelectorAll","nodeName","removeAttribute","i","length","transferCanvasData","transferInputData","transferData","selector","callback","descendantElements","cloneElements","cloneUniqueId","context","getContext","drawImage","passiveEventListenerOptions","normalizePassiveListenerOptions","passive","activeEventListenerOptions","dragImportantProperties","Set","DragRef","_config","_ngZone","_viewportRuler","_dragDropRegistry","_passiveTransform","_activeTransform","_hasStartedDragging","_moveEvents","Subject","_pointerMoveSubscription","Subscription","_pointerUpSubscription","_scrollSubscription","_resizeSubscription","_boundaryElement","_nativeInteractionsEnabled","_handles","_disabledHandles","_direction","dragStartDelay","_disabled","beforeStarted","started","released","ended","entered","exited","dropped","moved","_pointerDown","next","targetHandle","_getTargetHandle","disabled","_initializeDragSequence","_rootElement","_pointerMove","pointerPosition","_getPointerPositionOnPage","Math","abs","_pickupPositionOnPage","dragStartThreshold","isDelayElapsed","Date","now","_dragStartTime","_getDragStartDelay","container","_dropContainer","_endDragSequence","isDragging","isReceiving","preventDefault","run","_startDragSequence","constrainedPointerPosition","_getConstrainedPointerPosition","_hasMoved","_lastKnownPointerPosition","_updatePointerDirectionDelta","_updateActiveDropContainer","offset","constrainPosition","_initialClientRect","activeTransform","_applyRootElementTransform","observers","distance","_getDragDistance","delta","_pointerDirectionDelta","_pointerUp","_nativeDragStart","withRootElement","withParent","parentDragRef","_parentPositions","registerDragItem","newValue","coerceBooleanProperty","_toggleNativeDragInteractions","handle","getPlaceholderElement","_placeholder","getRootElement","getVisibleElement","withHandles","handles","coerceElement","disabledHandles","add","withPreviewTemplate","template","_previewTemplate","withPlaceholderTemplate","_placeholderTemplate","rootElement","_removeRootElementListeners","runOutsideAngular","addEventListener","_initialTransform","undefined","SVGElement","_ownerSVGElement","ownerSVGElement","withBoundaryElement","boundaryElement","unsubscribe","change","subscribe","_containInsideBoundaryOnResize","parent","_parentDragRef","dispose","remove","_anchor","_destroyPreview","_destroyPlaceholder","removeDragItem","_removeSubscriptions","complete","reset","disableHandle","enableHandle","delete","withDirection","direction","_withDropContainer","getFreeDragPosition","setFreeDragPosition","withPreviewContainer","_previewContainer","_sortFromLastPointerPosition","_preview","_previewRef","destroy","_placeholderRef","stopDragging","webkitTapHighlightColor","_rootElementTapHighlight","_stopScrolling","_animatePreviewToPlaceholder","then","_cleanupDragArtifacts","_cleanupCachedDimensions","dropPoint","isTouchEvent","_lastTouchEventTime","dropContainer","parentNode","placeholder","_createPlaceholderElement","anchor","createComment","shadowRoot","_getShadowRoot","insertBefore","_createPreviewElement","body","appendChild","replaceChild","_getPreviewInsertionPoint","start","_initialContainer","_initialIndex","getItemIndex","getScrollableParents","referenceElement","stopPropagation","isTouchSequence","isAuxiliaryMouseButton","button","isSyntheticEvent","isFakeEvent","isFakeTouchstartFromScreenReader","isFakeMousedownFromScreenReader","draggable","rootStyles","pointerMove","pointerUp","scrolled","scrollEvent","_updateOnScroll","_boundaryRect","previewTemplate","_pickupPositionInElement","matchSize","_getPointerPositionInElement","_pointerPositionAtLastDirectionChange","startDragging","_previewRect","currentIndex","isPointerOverContainer","_isOverContainer","item","previousIndex","previousContainer","drop","rawX","rawY","newContainer","_getSiblingContainerFromPosition","exit","enter","sortingDisabled","_startScrollingIfNecessary","_sortItem","_applyPreviewTransform","previewConfig","previewClass","preview","rootRect","viewRef","viewContainer","createEmbeddedView","detectChanges","getRootNode","matchElementSize","getTransform","margin","zIndex","classList","setAttribute","Array","isArray","className","Promise","resolve","placeholderRect","duration","getTransformTransitionDurationInMs","getComputedStyle","transitionedProperties","property","find","prop","propertyIndex","rawDurations","rawDelays","handler","propertyName","removeEventListener","clearTimeout","timeout","setTimeout","placeholderConfig","placeholderTemplate","pointerEvents","elementRect","handleElement","referenceRect","point","targetTouches","_getViewportScrollPosition","pageX","pageY","touches","changedTouches","svgMatrix","getScreenCTM","svgPoint","createSVGPoint","matrixTransform","inverse","dropContainerLock","lockAxis","pickupX","pickupY","boundaryRect","previewWidth","previewHeight","_getPreviewRect","minY","maxY","clamp$1","pointerPositionOnPage","positionSinceLastChange","changeX","changeY","pointerDirectionChangeThreshold","shouldEnable","styles","currentPosition","pickupPosition","leftOverflow","rightOverflow","topOverflow","bottomOverflow","touch","mouse","scrollDifference","_cachedShadowRoot","initialParent","previewContainer","documentRef","fullscreenElement","webkitFullscreenElement","mozFullScreenElement","msFullscreenElement","round","min","max","rootNodes","nodeType","ELEMENT_NODE","wrapper","createElement","sourceRect","moveItemInArray","fromIndex","toIndex","from","clamp","to","SingleAxisSortStrategy","_element","_itemPositions","orientation","_previousSwap","drag","overlaps","items","withItems","pointerDelta","siblings","newIndex","_getItemIndexFromPointerPosition","isHorizontal","findIndex","currentItem","siblingAtNewPosition","newPosition","itemOffset","_getItemOffsetPx","siblingOffset","_getSiblingOffsetPx","oldOrder","slice","sibling","index","isDraggedItem","elementToOffset","activeDraggables","_activeDraggables","newPositionReference","_shouldEnterAsFirstChild","splice","parentElement","push","_cacheItemPositions","withSortPredicate","predicate","_sortPredicate","p","getActiveItemsSnapshot","reverse","updateOnScroll","elementToMeasure","immediateSibling","end","itemPositions","lastItemRect","firstItemRect","floor","DropListRef","autoScrollDisabled","autoScrollStep","enterPredicate","sortPredicate","sorted","_isDragging","_draggables","_siblings","_activeSiblings","_viewportScrollSubscription","_verticalScrollDirection","_horizontalScrollDirection","_stopScrollTimers","_startScrollInterval","interval","period","scheduler","asyncScheduler","timer","animationFrameScheduler","pipe","takeUntil","_scrollNode","scrollStep","scrollBy","withScrollableParents","registerDropContainer","_sortStrategy","removeDropContainer","_draggingStarted","_notifyReceivingSiblings","_cacheParentPositions","_reset","previousItems","filter","every","connectedTo","withOrientation","_scrollableElements","size","_clientRect","result","scrollNode","verticalScrollDirection","horizontalScrollDirection","getElementScrollDirections","computedVertical","getVerticalScrollDirection","computedHorizontal","getHorizontalScrollDirection","scrollHeight","clientHeight","scrollWidth","clientWidth","getViewportSize","_initialScrollSnap","msScrollSnapType","scrollSnapType","_listenToScrollEvents","_stopReceiving","_canReceive","elementFromPoint","nativeElement","_startReceiving","activeSiblings","draggedItems","activeCapturingEventOptions","capture","DragDropRegistry","_dropInstances","_dragInstances","_activeDragInstances","_globalListeners","_draggingPredicate","scroll","_preventDefaultWhileDragging","_persistentTouchmoveListener","some","startsWith","e","options","config","_clearGlobalListeners","streams","Observable","observer","eventOptions","merge","ngOnDestroy","instance","fac","DOCUMENT","prov","factory","DEFAULT_CONFIG","DragDrop","createDrag","createDropList","i1","CDK_DRAG_PARENT","InjectionToken","CDK_DROP_LIST_GROUP","CDK_DRAG_CONFIG","_uniqueIdCounter","CDK_DROP_LIST","CdkDropList","dragDrop","_changeDetectorRef","_scrollDispatcher","_dir","_group","_destroyed","id","EventEmitter","_unsortedItems","_dropListRef","data","_assignDefaults","_setupInputSyncSubscription","_handleEvents","_dropLists","_items","addItem","_syncItemsWithRef","removeItem","getSortedItems","_dragRef","compareDocumentPosition","Node","DOCUMENT_POSITION_FOLLOWING","ref","startWith","coerceArray","list","_scrollableParentsResolved","scrollableParents","getAncestorScrollContainers","scrollable","getElementRef","coerceNumberProperty","markForCheck","emit","dropEvent","draggingDisabled","listAutoScrollDisabled","listOrientation","i3","dir","provide","useValue","useExisting","CDK_DRAG_HANDLE","CdkDragHandle","parentDrag","_stateChanges","_parentDrag","CDK_DRAG_PLACEHOLDER","CDK_DRAG_PREVIEW","CdkDrag","_viewContainerRef","_selfHandle","subscription","movedEvent","_syncInputs","ngAfterViewInit","onStable","take","_updateRootElement","_setupHandlesListener","freeDragPosition","ngOnChanges","changes","rootSelectorChange","rootElementSelector","positionChange","firstChange","closest","_getBoundaryElement","boundary","dir","templateRef","startEvent","releaseEvent","endEvent","enterEvent","exitEvent","tap","childHandleElements","switchMap","handleInstance","dragRef","dirIndex","_t","DragDropModule","mod","inj","imports","CdkScrollableModule","$event","MultilevelSelectionComponent","touched","isAllSelected","checklistSelection","SelectionModel","currentValue","dataSource","MatTreeFlatDataSource","treeControl","treeFlattener","_transformer","level","expandable","children","FlatTreeControl","MatTreeFlattener","onChange","values","console","log","onTouched","hasChild","_","valueChanged","markAsTouched","writeValue","deselect","dataNodes","nodes","val","select","registerOnChange","registerOnTouched","descendantsHasSelected","option","descendants","getDescendants","child","isSelected","categorySelectionToggle","toggle","checkAllParentsSelection","checkAllSelection","selected","n","categoryLeafSelectionToggle","getParentNode","checkRootNodeSelection","currentLevel","getLevel","currentNode","toggleSelectAll","NG_VALUE_ACCESSOR","multi","forwardRef","ctx_r58","CreateFieldModalComponent","translate","categoriesService","surveysService","notificationService","surveyId","surveyHelper","selectedFieldType","editMode","availableCategories","categories","availableSurveys","hasOptions","fieldOptions","emptyTitleOption","numberError","isTranslateMode","selectLanguageCode","ngOnInit","editField","getCategories","updateRadioCheckboxFields","updateTags","setHasOptionValidate","checkLoadAvailableData","input","translations","setTempSelectedFieldType","includes","error","res","category","results","parent_id","tag","cat","response","err","checkForEmptyOptions","optionValidation","duplicates","checkForSpecialOptions","el","onlyOptional","canMakePrivate","canDisableCaption","canDisplay","loadAvailableSurveys","types","s","toString","isNumber","default","test","String","showError","instant","selectField","instructions","removeOption","addOption","addOther","opt","validateDuplicate","MAT_DIALOG_DATA","ShareMenuComponent","clipboard","postId","shareUrl","shareUrlEncoded","hasPermission","copySuccess","embed","location","origin","encodeURIComponent","isExportable","copyToClipboard","str","copy","SurveyTaskComponent","confirm","formsService","dialog","route","languageService","sessionService","task","survey","isDefaultLanguageSelected","roles","isMain","colorSelected","languageChange","duplicateTaskChange","deleteTaskChange","errorFieldChange","taskChange","selectedRoles","taskFields","nonDraggableFields","draggableFields","isPost","showLangError","selectedLanguage","languages","languagesToSelect","roleOptions","selectedColor","currentInterimId","selectedTab","locationPrecision","icon","role","display_name","checked","initLanguages","color","getMapConfig","snapshot","paramMap","splitTaskFields","findIntermId","getSurveyRoles","location_precision","getMapConfigurations","getPrecision","nonDraggableFieldType","fieldType","getRoles","everyone_can_create","r","role_id","getConfigOptions","hide_time","hide_location","hide_author","require_approval","stageIds","form_stage_id","apply","getLanguages","language","localStorage","getItem","generalHelpers","enabled_languages","available","active","surveyLanguages","priority","mergeTaskFieldsData","changePriority","taskChangeEmit","changeLanguage","newLang","l","deleteField","_this","open","title","anonymiseReportersEnabled","getFeatureConfigurations","enabled","addField","maxWidth","minWidth","panelClass","afterClosed","addPriority","newObject","maxPriority","reduce","current","idx","colorChanged","deleteTask","duplicateTask","dup","url","getInterimId","changeLabel","SurveyItemComponent","BaseComponent","breakpointService","formBuilder","router","rolesService","notification","configTask","selectedLang","form","isEdit","additionalTasks","mainPost","surveyObject","defaultLanguage","activeLanguages","errorTaskField","submitted","super","checkDesktop","group","Validators","noWhitespaceValidator","AlphanumericValidatorValidator","tasks","base_language","can_create","targeted_survey","loadData","enabledLanguages","lang","code","availableLangs","langCode","initRoles","getSurveyById","updateForm","initTasks","isNew","defaultTask","patchValue","t","controls","valueChanges","untilDestroyed","Object","keys","taskUpdate","getFormControl","addTranslation","SelectLanguagesModalComponent","selectedLanguages","setValue","chooseTranslation","setTranslates","languageCode","saveRoles","formId","admin","updateRoles","save","defaultLang","validateAttributeOptionTranslations","request","assign","saveSurvey","navigate","errors","status","setErrors","invalidCharacters","JSON","stringify","isDesktop","back","addTask","f","validateSurveyTranslations","setNewColor","setErrorTaskField","tslib_es6","UntilDestroy","SessionService","BreakpointService","FormBuilder","Router","MatDialog","ActivatedRoute","SurveysService","FormsService","RolesService","NotificationService","LanguageService","Location","SurveysComponent","confirmModalService","isDesktop$","surveys","selectedSurveys","isShowActions","params","page","limit","current_page","last_page","total","isLoading","getSurveys","isAdd","currentPage","lastPage","meta","duplicateSurvey","shift","surveyDuplicate","post","deleteSurvey","confirmButtonText","cancelButtonText","forkJoin","removeFromFilters","selectSurveys","showActions","loadMore","generateDataQa","replace","TranslateService","ConfirmModalService","routes","path","component","breadcrumb","SurveysRoutingModule","RouterModule","SurveysModule","MatTabsModule","MatExpansionModule","QuillModule","TranslateModule","MatDialogModule","MatSlideToggleModule","SpinnerModule","MatRippleModule","ReactiveFormsModule","SettingsHeaderModule","MatSelectModule","GroupCheckboxSelectModule","DirectiveModule","MatCheckboxModule","SortByFieldModule"],"sourceRoot":"webpack:///","sources":["./apps/web-mzima-client/src/app/core/pipes/sort-by/sort-by.pipe.ts","./apps/web-mzima-client/src/app/shared/components/color-picker/color-picker-component.module.ts","./apps/web-mzima-client/src/app/shared/components/multilevel-select/multilevel-select.module.ts","./apps/web-mzima-client/src/app/settings/surveys/create-task-modal/create-task-modal.component.ts","./apps/web-mzima-client/src/app/settings/surveys/create-task-modal/create-task-modal.component.html","./node_modules/@angular/cdk/fesm2020/drag-drop.mjs","./node_modules/rxjs/dist/esm/internal/observable/interval.js","./apps/web-mzima-client/src/app/settings/surveys/multilevel-selection/multilevel-selection.component.html","./apps/web-mzima-client/src/app/settings/surveys/multilevel-selection/multilevel-selection.component.ts","./apps/web-mzima-client/src/app/settings/surveys/create-field-modal/create-field-modal.component.html","./apps/web-mzima-client/src/app/settings/surveys/create-field-modal/create-field-modal.component.ts","./apps/web-mzima-client/src/app/settings/surveys/share-menu/share-menu.component.html","./apps/web-mzima-client/src/app/settings/surveys/share-menu/share-menu.component.ts","./apps/web-mzima-client/src/app/settings/surveys/survey-task/survey-task.component.html","./apps/web-mzima-client/src/app/settings/surveys/survey-task/survey-task.component.ts","./apps/web-mzima-client/src/app/settings/surveys/survey-item/survey-item.component.html","./apps/web-mzima-client/src/app/settings/surveys/survey-item/survey-item.component.ts","./apps/web-mzima-client/src/app/settings/surveys/surveys.component.html","./apps/web-mzima-client/src/app/settings/surveys/surveys.component.ts","./apps/web-mzima-client/src/app/settings/surveys/surveys-routing.module.ts","./apps/web-mzima-client/src/app/settings/surveys/surveys.module.ts"],"sourcesContent":["import { Pipe, PipeTransform } from '@angular/core';\n\n@Pipe({\n  name: 'sortByField',\n})\nexport class SortByFieldPipe implements PipeTransform {\n  transform(array: any[], field: string, order: string = 'asc'): any[] {\n    array.sort((a: any, b: any) => {\n      if (a[field] < b[field]) {\n        return order === 'asc' ? -1 : 1;\n      } else if (a[field] > b[field]) {\n        return order === 'asc' ? 1 : -1;\n      } else {\n        return 0;\n      }\n    });\n    return array;\n  }\n}\n","import { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { FormsModule } from '@angular/forms';\nimport { MatButtonModule } from '@angular/material/button';\nimport { MatInputModule } from '@angular/material/input';\nimport { MatMenuModule } from '@angular/material/menu';\nimport { ColorPickerModule } from 'ngx-color-picker';\nimport { ColorPickerComponent } from './color-picker.component';\nimport { MzimaUiModule } from '@mzima-client/mzima-ui';\n\n@NgModule({\n  declarations: [ColorPickerComponent],\n  imports: [\n    CommonModule,\n    MatInputModule,\n    MatMenuModule,\n    FormsModule,\n    ColorPickerModule,\n    MatButtonModule,\n    MzimaUiModule,\n  ],\n  exports: [ColorPickerComponent],\n})\nexport class ColorPickerComponentModule {}\n","import { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { FormsModule } from '@angular/forms';\nimport { MatButtonModule } from '@angular/material/button';\nimport { MatIconModule } from '@angular/material/icon';\nimport { MatListModule } from '@angular/material/list';\nimport { MatMenuModule } from '@angular/material/menu';\nimport { MatTreeModule } from '@angular/material/tree';\nimport { MultilevelSelectComponent } from './multilevel-select.component';\nimport { MzimaUiModule } from '@mzima-client/mzima-ui';\n\n@NgModule({\n  declarations: [MultilevelSelectComponent],\n  imports: [\n    CommonModule,\n    MatMenuModule,\n    MatTreeModule,\n    MatListModule,\n    FormsModule,\n    MatButtonModule,\n    MatIconModule,\n    MzimaUiModule,\n  ],\n  exports: [MultilevelSelectComponent],\n})\nexport class MultilevelSelectModule {}\n","import { Component } from '@angular/core';\nimport { MatDialogRef } from '@angular/material/dialog';\n\n@Component({\n  selector: 'app-create-task-modal',\n  templateUrl: './create-task-modal.component.html',\n  styleUrls: ['./create-task-modal.component.scss'],\n})\nexport class CreateTaskModalComponent {\n  public newTask: any = {\n    label: '',\n    description: '',\n    required: false,\n    fields: [],\n    type: 'task',\n    show_when_published: false,\n    task_is_internal_only: true,\n  };\n\n  constructor(private matDialogRef: MatDialogRef<CreateTaskModalComponent>) {}\n\n  cancel() {\n    this.matDialogRef.close();\n  }\n\n  addNewTask() {\n    this.matDialogRef.close({\n      ...this.newTask,\n      label: this.newTask.label.trim(),\n      description: this.newTask.description.trim(),\n    });\n  }\n}\n","<mzima-client-button\n  tabindex=\"-1\"\n  fill=\"outline\"\n  [iconOnly]=\"true\"\n  color=\"light-gray\"\n  [data-qa]=\"'btn-close'\"\n  class=\"modal__close-btn\"\n  [mat-dialog-close]=\"false\"\n  ariaLabel=\"{{ 'modal.button.close' | translate }}\"\n>\n  <mat-icon icon svgIcon=\"close\"></mat-icon>\n</mzima-client-button>\n\n<strong mat-dialog-title [data-qa]=\"'task-modal-title'\">{{ 'survey.add_task' | translate }}</strong>\n<mat-dialog-content class=\"post\">\n  <div class=\"form-row\">\n    <mat-label>{{ 'survey.task_name' | translate }} *</mat-label>\n    <mat-form-field appearance=\"outline\">\n      <input\n        matInput\n        placeholder=\"{{ 'survey.name_this_task' | translate }}\"\n        [(ngModel)]=\"newTask.label\"\n        [data-qa]=\"'survey-task-name'\"\n      />\n    </mat-form-field>\n  </div>\n  <div class=\"form-row\">\n    <mat-label>{{ 'survey.task_description' | translate }}</mat-label>\n    <mat-form-field appearance=\"outline\">\n      <textarea\n        matInput\n        cdkTextareaAutosize\n        cdkAutosizeMinRows=\"2\"\n        cdkAutosizeMaxRows=\"5\"\n        placeholder=\"{{ 'survey.describe_this_task' | translate }}\"\n        [(ngModel)]=\"newTask.description\"\n        [data-qa]=\"'survey-task-description'\"\n      ></textarea>\n    </mat-form-field>\n  </div>\n  <div class=\"toggle\">\n    <mat-slide-toggle [(ngModel)]=\"newTask.required\" [data-qa]=\"'task-toggle-required'\">\n      {{ 'survey.require_section' | translate }}\n    </mat-slide-toggle>\n  </div>\n</mat-dialog-content>\n\n<div mat-dialog-actions align=\"end\">\n  <mzima-client-button\n    fill=\"outline\"\n    color=\"secondary\"\n    (buttonClick)=\"cancel()\"\n    [data-qa]=\"'survey-task-cancel'\"\n  >\n    {{ 'app.cancel' | translate }}\n  </mzima-client-button>\n  <mzima-client-button\n    type=\"submit\"\n    (buttonClick)=\"addNewTask()\"\n    [disabled]=\"newTask.label.trim().length === 0\"\n    [data-qa]=\"'survey-task-add'\"\n  >\n    {{ 'app.add' | translate }}\n  </mzima-client-button>\n</div>\n","import * as i0 from '@angular/core';\nimport { Injectable, Inject, InjectionToken, Directive, Input, EventEmitter, Optional, SkipSelf, Output, Self, ContentChildren, ContentChild, NgModule } from '@angular/core';\nimport { DOCUMENT } from '@angular/common';\nimport * as i1 from '@angular/cdk/scrolling';\nimport { CdkScrollableModule } from '@angular/cdk/scrolling';\nimport { _getEventTarget, normalizePassiveListenerOptions, _getShadowRoot } from '@angular/cdk/platform';\nimport { coerceBooleanProperty, coerceElement, coerceArray, coerceNumberProperty } from '@angular/cdk/coercion';\nimport { isFakeTouchstartFromScreenReader, isFakeMousedownFromScreenReader } from '@angular/cdk/a11y';\nimport { Subject, Subscription, interval, animationFrameScheduler, Observable, merge } from 'rxjs';\nimport { takeUntil, startWith, map, take, tap, switchMap } from 'rxjs/operators';\nimport * as i3 from '@angular/cdk/bidi';\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Shallow-extends a stylesheet object with another stylesheet-like object.\n * Note that the keys in `source` have to be dash-cased.\n * @docs-private\n */\nfunction extendStyles(dest, source, importantProperties) {\n    for (let key in source) {\n        if (source.hasOwnProperty(key)) {\n            const value = source[key];\n            if (value) {\n                dest.setProperty(key, value, importantProperties?.has(key) ? 'important' : '');\n            }\n            else {\n                dest.removeProperty(key);\n            }\n        }\n    }\n    return dest;\n}\n/**\n * Toggles whether the native drag interactions should be enabled for an element.\n * @param element Element on which to toggle the drag interactions.\n * @param enable Whether the drag interactions should be enabled.\n * @docs-private\n */\nfunction toggleNativeDragInteractions(element, enable) {\n    const userSelect = enable ? '' : 'none';\n    extendStyles(element.style, {\n        'touch-action': enable ? '' : 'none',\n        '-webkit-user-drag': enable ? '' : 'none',\n        '-webkit-tap-highlight-color': enable ? '' : 'transparent',\n        'user-select': userSelect,\n        '-ms-user-select': userSelect,\n        '-webkit-user-select': userSelect,\n        '-moz-user-select': userSelect,\n    });\n}\n/**\n * Toggles whether an element is visible while preserving its dimensions.\n * @param element Element whose visibility to toggle\n * @param enable Whether the element should be visible.\n * @param importantProperties Properties to be set as `!important`.\n * @docs-private\n */\nfunction toggleVisibility(element, enable, importantProperties) {\n    extendStyles(element.style, {\n        position: enable ? '' : 'fixed',\n        top: enable ? '' : '0',\n        opacity: enable ? '' : '0',\n        left: enable ? '' : '-999em',\n    }, importantProperties);\n}\n/**\n * Combines a transform string with an optional other transform\n * that exited before the base transform was applied.\n */\nfunction combineTransforms(transform, initialTransform) {\n    return initialTransform && initialTransform != 'none'\n        ? transform + ' ' + initialTransform\n        : transform;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Parses a CSS time value to milliseconds. */\nfunction parseCssTimeUnitsToMs(value) {\n    // Some browsers will return it in seconds, whereas others will return milliseconds.\n    const multiplier = value.toLowerCase().indexOf('ms') > -1 ? 1 : 1000;\n    return parseFloat(value) * multiplier;\n}\n/** Gets the transform transition duration, including the delay, of an element in milliseconds. */\nfunction getTransformTransitionDurationInMs(element) {\n    const computedStyle = getComputedStyle(element);\n    const transitionedProperties = parseCssPropertyValue(computedStyle, 'transition-property');\n    const property = transitionedProperties.find(prop => prop === 'transform' || prop === 'all');\n    // If there's no transition for `all` or `transform`, we shouldn't do anything.\n    if (!property) {\n        return 0;\n    }\n    // Get the index of the property that we're interested in and match\n    // it up to the same index in `transition-delay` and `transition-duration`.\n    const propertyIndex = transitionedProperties.indexOf(property);\n    const rawDurations = parseCssPropertyValue(computedStyle, 'transition-duration');\n    const rawDelays = parseCssPropertyValue(computedStyle, 'transition-delay');\n    return (parseCssTimeUnitsToMs(rawDurations[propertyIndex]) +\n        parseCssTimeUnitsToMs(rawDelays[propertyIndex]));\n}\n/** Parses out multiple values from a computed style into an array. */\nfunction parseCssPropertyValue(computedStyle, name) {\n    const value = computedStyle.getPropertyValue(name);\n    return value.split(',').map(part => part.trim());\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Gets a mutable version of an element's bounding `ClientRect`. */\nfunction getMutableClientRect(element) {\n    const clientRect = element.getBoundingClientRect();\n    // We need to clone the `clientRect` here, because all the values on it are readonly\n    // and we need to be able to update them. Also we can't use a spread here, because\n    // the values on a `ClientRect` aren't own properties. See:\n    // https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect#Notes\n    return {\n        top: clientRect.top,\n        right: clientRect.right,\n        bottom: clientRect.bottom,\n        left: clientRect.left,\n        width: clientRect.width,\n        height: clientRect.height,\n        x: clientRect.x,\n        y: clientRect.y,\n    };\n}\n/**\n * Checks whether some coordinates are within a `ClientRect`.\n * @param clientRect ClientRect that is being checked.\n * @param x Coordinates along the X axis.\n * @param y Coordinates along the Y axis.\n */\nfunction isInsideClientRect(clientRect, x, y) {\n    const { top, bottom, left, right } = clientRect;\n    return y >= top && y <= bottom && x >= left && x <= right;\n}\n/**\n * Updates the top/left positions of a `ClientRect`, as well as their bottom/right counterparts.\n * @param clientRect `ClientRect` that should be updated.\n * @param top Amount to add to the `top` position.\n * @param left Amount to add to the `left` position.\n */\nfunction adjustClientRect(clientRect, top, left) {\n    clientRect.top += top;\n    clientRect.bottom = clientRect.top + clientRect.height;\n    clientRect.left += left;\n    clientRect.right = clientRect.left + clientRect.width;\n}\n/**\n * Checks whether the pointer coordinates are close to a ClientRect.\n * @param rect ClientRect to check against.\n * @param threshold Threshold around the ClientRect.\n * @param pointerX Coordinates along the X axis.\n * @param pointerY Coordinates along the Y axis.\n */\nfunction isPointerNearClientRect(rect, threshold, pointerX, pointerY) {\n    const { top, right, bottom, left, width, height } = rect;\n    const xThreshold = width * threshold;\n    const yThreshold = height * threshold;\n    return (pointerY > top - yThreshold &&\n        pointerY < bottom + yThreshold &&\n        pointerX > left - xThreshold &&\n        pointerX < right + xThreshold);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Keeps track of the scroll position and dimensions of the parents of an element. */\nclass ParentPositionTracker {\n    constructor(_document) {\n        this._document = _document;\n        /** Cached positions of the scrollable parent elements. */\n        this.positions = new Map();\n    }\n    /** Clears the cached positions. */\n    clear() {\n        this.positions.clear();\n    }\n    /** Caches the positions. Should be called at the beginning of a drag sequence. */\n    cache(elements) {\n        this.clear();\n        this.positions.set(this._document, {\n            scrollPosition: this.getViewportScrollPosition(),\n        });\n        elements.forEach(element => {\n            this.positions.set(element, {\n                scrollPosition: { top: element.scrollTop, left: element.scrollLeft },\n                clientRect: getMutableClientRect(element),\n            });\n        });\n    }\n    /** Handles scrolling while a drag is taking place. */\n    handleScroll(event) {\n        const target = _getEventTarget(event);\n        const cachedPosition = this.positions.get(target);\n        if (!cachedPosition) {\n            return null;\n        }\n        const scrollPosition = cachedPosition.scrollPosition;\n        let newTop;\n        let newLeft;\n        if (target === this._document) {\n            const viewportScrollPosition = this.getViewportScrollPosition();\n            newTop = viewportScrollPosition.top;\n            newLeft = viewportScrollPosition.left;\n        }\n        else {\n            newTop = target.scrollTop;\n            newLeft = target.scrollLeft;\n        }\n        const topDifference = scrollPosition.top - newTop;\n        const leftDifference = scrollPosition.left - newLeft;\n        // Go through and update the cached positions of the scroll\n        // parents that are inside the element that was scrolled.\n        this.positions.forEach((position, node) => {\n            if (position.clientRect && target !== node && target.contains(node)) {\n                adjustClientRect(position.clientRect, topDifference, leftDifference);\n            }\n        });\n        scrollPosition.top = newTop;\n        scrollPosition.left = newLeft;\n        return { top: topDifference, left: leftDifference };\n    }\n    /**\n     * Gets the scroll position of the viewport. Note that we use the scrollX and scrollY directly,\n     * instead of going through the `ViewportRuler`, because the first value the ruler looks at is\n     * the top/left offset of the `document.documentElement` which works for most cases, but breaks\n     * if the element is offset by something like the `BlockScrollStrategy`.\n     */\n    getViewportScrollPosition() {\n        return { top: window.scrollY, left: window.scrollX };\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Creates a deep clone of an element. */\nfunction deepCloneNode(node) {\n    const clone = node.cloneNode(true);\n    const descendantsWithId = clone.querySelectorAll('[id]');\n    const nodeName = node.nodeName.toLowerCase();\n    // Remove the `id` to avoid having multiple elements with the same id on the page.\n    clone.removeAttribute('id');\n    for (let i = 0; i < descendantsWithId.length; i++) {\n        descendantsWithId[i].removeAttribute('id');\n    }\n    if (nodeName === 'canvas') {\n        transferCanvasData(node, clone);\n    }\n    else if (nodeName === 'input' || nodeName === 'select' || nodeName === 'textarea') {\n        transferInputData(node, clone);\n    }\n    transferData('canvas', node, clone, transferCanvasData);\n    transferData('input, textarea, select', node, clone, transferInputData);\n    return clone;\n}\n/** Matches elements between an element and its clone and allows for their data to be cloned. */\nfunction transferData(selector, node, clone, callback) {\n    const descendantElements = node.querySelectorAll(selector);\n    if (descendantElements.length) {\n        const cloneElements = clone.querySelectorAll(selector);\n        for (let i = 0; i < descendantElements.length; i++) {\n            callback(descendantElements[i], cloneElements[i]);\n        }\n    }\n}\n// Counter for unique cloned radio button names.\nlet cloneUniqueId = 0;\n/** Transfers the data of one input element to another. */\nfunction transferInputData(source, clone) {\n    // Browsers throw an error when assigning the value of a file input programmatically.\n    if (clone.type !== 'file') {\n        clone.value = source.value;\n    }\n    // Radio button `name` attributes must be unique for radio button groups\n    // otherwise original radio buttons can lose their checked state\n    // once the clone is inserted in the DOM.\n    if (clone.type === 'radio' && clone.name) {\n        clone.name = `mat-clone-${clone.name}-${cloneUniqueId++}`;\n    }\n}\n/** Transfers the data of one canvas element to another. */\nfunction transferCanvasData(source, clone) {\n    const context = clone.getContext('2d');\n    if (context) {\n        // In some cases `drawImage` can throw (e.g. if the canvas size is 0x0).\n        // We can't do much about it so just ignore the error.\n        try {\n            context.drawImage(source, 0, 0);\n        }\n        catch { }\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Options that can be used to bind a passive event listener. */\nconst passiveEventListenerOptions = normalizePassiveListenerOptions({ passive: true });\n/** Options that can be used to bind an active event listener. */\nconst activeEventListenerOptions = normalizePassiveListenerOptions({ passive: false });\n/**\n * Time in milliseconds for which to ignore mouse events, after\n * receiving a touch event. Used to avoid doing double work for\n * touch devices where the browser fires fake mouse events, in\n * addition to touch events.\n */\nconst MOUSE_EVENT_IGNORE_TIME = 800;\n/** Inline styles to be set as `!important` while dragging. */\nconst dragImportantProperties = new Set([\n    // Needs to be important, because some `mat-table` sets `position: sticky !important`. See #22781.\n    'position',\n]);\n/**\n * Reference to a draggable item. Used to manipulate or dispose of the item.\n */\nclass DragRef {\n    constructor(element, _config, _document, _ngZone, _viewportRuler, _dragDropRegistry) {\n        this._config = _config;\n        this._document = _document;\n        this._ngZone = _ngZone;\n        this._viewportRuler = _viewportRuler;\n        this._dragDropRegistry = _dragDropRegistry;\n        /**\n         * CSS `transform` applied to the element when it isn't being dragged. We need a\n         * passive transform in order for the dragged element to retain its new position\n         * after the user has stopped dragging and because we need to know the relative\n         * position in case they start dragging again. This corresponds to `element.style.transform`.\n         */\n        this._passiveTransform = { x: 0, y: 0 };\n        /** CSS `transform` that is applied to the element while it's being dragged. */\n        this._activeTransform = { x: 0, y: 0 };\n        /**\n         * Whether the dragging sequence has been started. Doesn't\n         * necessarily mean that the element has been moved.\n         */\n        this._hasStartedDragging = false;\n        /** Emits when the item is being moved. */\n        this._moveEvents = new Subject();\n        /** Subscription to pointer movement events. */\n        this._pointerMoveSubscription = Subscription.EMPTY;\n        /** Subscription to the event that is dispatched when the user lifts their pointer. */\n        this._pointerUpSubscription = Subscription.EMPTY;\n        /** Subscription to the viewport being scrolled. */\n        this._scrollSubscription = Subscription.EMPTY;\n        /** Subscription to the viewport being resized. */\n        this._resizeSubscription = Subscription.EMPTY;\n        /** Cached reference to the boundary element. */\n        this._boundaryElement = null;\n        /** Whether the native dragging interactions have been enabled on the root element. */\n        this._nativeInteractionsEnabled = true;\n        /** Elements that can be used to drag the draggable item. */\n        this._handles = [];\n        /** Registered handles that are currently disabled. */\n        this._disabledHandles = new Set();\n        /** Layout direction of the item. */\n        this._direction = 'ltr';\n        /**\n         * Amount of milliseconds to wait after the user has put their\n         * pointer down before starting to drag the element.\n         */\n        this.dragStartDelay = 0;\n        this._disabled = false;\n        /** Emits as the drag sequence is being prepared. */\n        this.beforeStarted = new Subject();\n        /** Emits when the user starts dragging the item. */\n        this.started = new Subject();\n        /** Emits when the user has released a drag item, before any animations have started. */\n        this.released = new Subject();\n        /** Emits when the user stops dragging an item in the container. */\n        this.ended = new Subject();\n        /** Emits when the user has moved the item into a new container. */\n        this.entered = new Subject();\n        /** Emits when the user removes the item its container by dragging it into another container. */\n        this.exited = new Subject();\n        /** Emits when the user drops the item inside a container. */\n        this.dropped = new Subject();\n        /**\n         * Emits as the user is dragging the item. Use with caution,\n         * because this event will fire for every pixel that the user has dragged.\n         */\n        this.moved = this._moveEvents;\n        /** Handler for the `mousedown`/`touchstart` events. */\n        this._pointerDown = (event) => {\n            this.beforeStarted.next();\n            // Delegate the event based on whether it started from a handle or the element itself.\n            if (this._handles.length) {\n                const targetHandle = this._getTargetHandle(event);\n                if (targetHandle && !this._disabledHandles.has(targetHandle) && !this.disabled) {\n                    this._initializeDragSequence(targetHandle, event);\n                }\n            }\n            else if (!this.disabled) {\n                this._initializeDragSequence(this._rootElement, event);\n            }\n        };\n        /** Handler that is invoked when the user moves their pointer after they've initiated a drag. */\n        this._pointerMove = (event) => {\n            const pointerPosition = this._getPointerPositionOnPage(event);\n            if (!this._hasStartedDragging) {\n                const distanceX = Math.abs(pointerPosition.x - this._pickupPositionOnPage.x);\n                const distanceY = Math.abs(pointerPosition.y - this._pickupPositionOnPage.y);\n                const isOverThreshold = distanceX + distanceY >= this._config.dragStartThreshold;\n                // Only start dragging after the user has moved more than the minimum distance in either\n                // direction. Note that this is preferable over doing something like `skip(minimumDistance)`\n                // in the `pointerMove` subscription, because we're not guaranteed to have one move event\n                // per pixel of movement (e.g. if the user moves their pointer quickly).\n                if (isOverThreshold) {\n                    const isDelayElapsed = Date.now() >= this._dragStartTime + this._getDragStartDelay(event);\n                    const container = this._dropContainer;\n                    if (!isDelayElapsed) {\n                        this._endDragSequence(event);\n                        return;\n                    }\n                    // Prevent other drag sequences from starting while something in the container is still\n                    // being dragged. This can happen while we're waiting for the drop animation to finish\n                    // and can cause errors, because some elements might still be moving around.\n                    if (!container || (!container.isDragging() && !container.isReceiving())) {\n                        // Prevent the default action as soon as the dragging sequence is considered as\n                        // \"started\" since waiting for the next event can allow the device to begin scrolling.\n                        event.preventDefault();\n                        this._hasStartedDragging = true;\n                        this._ngZone.run(() => this._startDragSequence(event));\n                    }\n                }\n                return;\n            }\n            // We prevent the default action down here so that we know that dragging has started. This is\n            // important for touch devices where doing this too early can unnecessarily block scrolling,\n            // if there's a dragging delay.\n            event.preventDefault();\n            const constrainedPointerPosition = this._getConstrainedPointerPosition(pointerPosition);\n            this._hasMoved = true;\n            this._lastKnownPointerPosition = pointerPosition;\n            this._updatePointerDirectionDelta(constrainedPointerPosition);\n            if (this._dropContainer) {\n                this._updateActiveDropContainer(constrainedPointerPosition, pointerPosition);\n            }\n            else {\n                // If there's a position constraint function, we want the element's top/left to be at the\n                // specific position on the page. Use the initial position as a reference if that's the case.\n                const offset = this.constrainPosition ? this._initialClientRect : this._pickupPositionOnPage;\n                const activeTransform = this._activeTransform;\n                activeTransform.x = constrainedPointerPosition.x - offset.x + this._passiveTransform.x;\n                activeTransform.y = constrainedPointerPosition.y - offset.y + this._passiveTransform.y;\n                this._applyRootElementTransform(activeTransform.x, activeTransform.y);\n            }\n            // Since this event gets fired for every pixel while dragging, we only\n            // want to fire it if the consumer opted into it. Also we have to\n            // re-enter the zone because we run all of the events on the outside.\n            if (this._moveEvents.observers.length) {\n                this._ngZone.run(() => {\n                    this._moveEvents.next({\n                        source: this,\n                        pointerPosition: constrainedPointerPosition,\n                        event,\n                        distance: this._getDragDistance(constrainedPointerPosition),\n                        delta: this._pointerDirectionDelta,\n                    });\n                });\n            }\n        };\n        /** Handler that is invoked when the user lifts their pointer up, after initiating a drag. */\n        this._pointerUp = (event) => {\n            this._endDragSequence(event);\n        };\n        /** Handles a native `dragstart` event. */\n        this._nativeDragStart = (event) => {\n            if (this._handles.length) {\n                const targetHandle = this._getTargetHandle(event);\n                if (targetHandle && !this._disabledHandles.has(targetHandle) && !this.disabled) {\n                    event.preventDefault();\n                }\n            }\n            else if (!this.disabled) {\n                // Usually this isn't necessary since the we prevent the default action in `pointerDown`,\n                // but some cases like dragging of links can slip through (see #24403).\n                event.preventDefault();\n            }\n        };\n        this.withRootElement(element).withParent(_config.parentDragRef || null);\n        this._parentPositions = new ParentPositionTracker(_document);\n        _dragDropRegistry.registerDragItem(this);\n    }\n    /** Whether starting to drag this element is disabled. */\n    get disabled() {\n        return this._disabled || !!(this._dropContainer && this._dropContainer.disabled);\n    }\n    set disabled(value) {\n        const newValue = coerceBooleanProperty(value);\n        if (newValue !== this._disabled) {\n            this._disabled = newValue;\n            this._toggleNativeDragInteractions();\n            this._handles.forEach(handle => toggleNativeDragInteractions(handle, newValue));\n        }\n    }\n    /**\n     * Returns the element that is being used as a placeholder\n     * while the current element is being dragged.\n     */\n    getPlaceholderElement() {\n        return this._placeholder;\n    }\n    /** Returns the root draggable element. */\n    getRootElement() {\n        return this._rootElement;\n    }\n    /**\n     * Gets the currently-visible element that represents the drag item.\n     * While dragging this is the placeholder, otherwise it's the root element.\n     */\n    getVisibleElement() {\n        return this.isDragging() ? this.getPlaceholderElement() : this.getRootElement();\n    }\n    /** Registers the handles that can be used to drag the element. */\n    withHandles(handles) {\n        this._handles = handles.map(handle => coerceElement(handle));\n        this._handles.forEach(handle => toggleNativeDragInteractions(handle, this.disabled));\n        this._toggleNativeDragInteractions();\n        // Delete any lingering disabled handles that may have been destroyed. Note that we re-create\n        // the set, rather than iterate over it and filter out the destroyed handles, because while\n        // the ES spec allows for sets to be modified while they're being iterated over, some polyfills\n        // use an array internally which may throw an error.\n        const disabledHandles = new Set();\n        this._disabledHandles.forEach(handle => {\n            if (this._handles.indexOf(handle) > -1) {\n                disabledHandles.add(handle);\n            }\n        });\n        this._disabledHandles = disabledHandles;\n        return this;\n    }\n    /**\n     * Registers the template that should be used for the drag preview.\n     * @param template Template that from which to stamp out the preview.\n     */\n    withPreviewTemplate(template) {\n        this._previewTemplate = template;\n        return this;\n    }\n    /**\n     * Registers the template that should be used for the drag placeholder.\n     * @param template Template that from which to stamp out the placeholder.\n     */\n    withPlaceholderTemplate(template) {\n        this._placeholderTemplate = template;\n        return this;\n    }\n    /**\n     * Sets an alternate drag root element. The root element is the element that will be moved as\n     * the user is dragging. Passing an alternate root element is useful when trying to enable\n     * dragging on an element that you might not have access to.\n     */\n    withRootElement(rootElement) {\n        const element = coerceElement(rootElement);\n        if (element !== this._rootElement) {\n            if (this._rootElement) {\n                this._removeRootElementListeners(this._rootElement);\n            }\n            this._ngZone.runOutsideAngular(() => {\n                element.addEventListener('mousedown', this._pointerDown, activeEventListenerOptions);\n                element.addEventListener('touchstart', this._pointerDown, passiveEventListenerOptions);\n                element.addEventListener('dragstart', this._nativeDragStart, activeEventListenerOptions);\n            });\n            this._initialTransform = undefined;\n            this._rootElement = element;\n        }\n        if (typeof SVGElement !== 'undefined' && this._rootElement instanceof SVGElement) {\n            this._ownerSVGElement = this._rootElement.ownerSVGElement;\n        }\n        return this;\n    }\n    /**\n     * Element to which the draggable's position will be constrained.\n     */\n    withBoundaryElement(boundaryElement) {\n        this._boundaryElement = boundaryElement ? coerceElement(boundaryElement) : null;\n        this._resizeSubscription.unsubscribe();\n        if (boundaryElement) {\n            this._resizeSubscription = this._viewportRuler\n                .change(10)\n                .subscribe(() => this._containInsideBoundaryOnResize());\n        }\n        return this;\n    }\n    /** Sets the parent ref that the ref is nested in.  */\n    withParent(parent) {\n        this._parentDragRef = parent;\n        return this;\n    }\n    /** Removes the dragging functionality from the DOM element. */\n    dispose() {\n        this._removeRootElementListeners(this._rootElement);\n        // Do this check before removing from the registry since it'll\n        // stop being considered as dragged once it is removed.\n        if (this.isDragging()) {\n            // Since we move out the element to the end of the body while it's being\n            // dragged, we have to make sure that it's removed if it gets destroyed.\n            this._rootElement?.remove();\n        }\n        this._anchor?.remove();\n        this._destroyPreview();\n        this._destroyPlaceholder();\n        this._dragDropRegistry.removeDragItem(this);\n        this._removeSubscriptions();\n        this.beforeStarted.complete();\n        this.started.complete();\n        this.released.complete();\n        this.ended.complete();\n        this.entered.complete();\n        this.exited.complete();\n        this.dropped.complete();\n        this._moveEvents.complete();\n        this._handles = [];\n        this._disabledHandles.clear();\n        this._dropContainer = undefined;\n        this._resizeSubscription.unsubscribe();\n        this._parentPositions.clear();\n        this._boundaryElement =\n            this._rootElement =\n                this._ownerSVGElement =\n                    this._placeholderTemplate =\n                        this._previewTemplate =\n                            this._anchor =\n                                this._parentDragRef =\n                                    null;\n    }\n    /** Checks whether the element is currently being dragged. */\n    isDragging() {\n        return this._hasStartedDragging && this._dragDropRegistry.isDragging(this);\n    }\n    /** Resets a standalone drag item to its initial position. */\n    reset() {\n        this._rootElement.style.transform = this._initialTransform || '';\n        this._activeTransform = { x: 0, y: 0 };\n        this._passiveTransform = { x: 0, y: 0 };\n    }\n    /**\n     * Sets a handle as disabled. While a handle is disabled, it'll capture and interrupt dragging.\n     * @param handle Handle element that should be disabled.\n     */\n    disableHandle(handle) {\n        if (!this._disabledHandles.has(handle) && this._handles.indexOf(handle) > -1) {\n            this._disabledHandles.add(handle);\n            toggleNativeDragInteractions(handle, true);\n        }\n    }\n    /**\n     * Enables a handle, if it has been disabled.\n     * @param handle Handle element to be enabled.\n     */\n    enableHandle(handle) {\n        if (this._disabledHandles.has(handle)) {\n            this._disabledHandles.delete(handle);\n            toggleNativeDragInteractions(handle, this.disabled);\n        }\n    }\n    /** Sets the layout direction of the draggable item. */\n    withDirection(direction) {\n        this._direction = direction;\n        return this;\n    }\n    /** Sets the container that the item is part of. */\n    _withDropContainer(container) {\n        this._dropContainer = container;\n    }\n    /**\n     * Gets the current position in pixels the draggable outside of a drop container.\n     */\n    getFreeDragPosition() {\n        const position = this.isDragging() ? this._activeTransform : this._passiveTransform;\n        return { x: position.x, y: position.y };\n    }\n    /**\n     * Sets the current position in pixels the draggable outside of a drop container.\n     * @param value New position to be set.\n     */\n    setFreeDragPosition(value) {\n        this._activeTransform = { x: 0, y: 0 };\n        this._passiveTransform.x = value.x;\n        this._passiveTransform.y = value.y;\n        if (!this._dropContainer) {\n            this._applyRootElementTransform(value.x, value.y);\n        }\n        return this;\n    }\n    /**\n     * Sets the container into which to insert the preview element.\n     * @param value Container into which to insert the preview.\n     */\n    withPreviewContainer(value) {\n        this._previewContainer = value;\n        return this;\n    }\n    /** Updates the item's sort order based on the last-known pointer position. */\n    _sortFromLastPointerPosition() {\n        const position = this._lastKnownPointerPosition;\n        if (position && this._dropContainer) {\n            this._updateActiveDropContainer(this._getConstrainedPointerPosition(position), position);\n        }\n    }\n    /** Unsubscribes from the global subscriptions. */\n    _removeSubscriptions() {\n        this._pointerMoveSubscription.unsubscribe();\n        this._pointerUpSubscription.unsubscribe();\n        this._scrollSubscription.unsubscribe();\n    }\n    /** Destroys the preview element and its ViewRef. */\n    _destroyPreview() {\n        this._preview?.remove();\n        this._previewRef?.destroy();\n        this._preview = this._previewRef = null;\n    }\n    /** Destroys the placeholder element and its ViewRef. */\n    _destroyPlaceholder() {\n        this._placeholder?.remove();\n        this._placeholderRef?.destroy();\n        this._placeholder = this._placeholderRef = null;\n    }\n    /**\n     * Clears subscriptions and stops the dragging sequence.\n     * @param event Browser event object that ended the sequence.\n     */\n    _endDragSequence(event) {\n        // Note that here we use `isDragging` from the service, rather than from `this`.\n        // The difference is that the one from the service reflects whether a dragging sequence\n        // has been initiated, whereas the one on `this` includes whether the user has passed\n        // the minimum dragging threshold.\n        if (!this._dragDropRegistry.isDragging(this)) {\n            return;\n        }\n        this._removeSubscriptions();\n        this._dragDropRegistry.stopDragging(this);\n        this._toggleNativeDragInteractions();\n        if (this._handles) {\n            this._rootElement.style.webkitTapHighlightColor =\n                this._rootElementTapHighlight;\n        }\n        if (!this._hasStartedDragging) {\n            return;\n        }\n        this.released.next({ source: this, event });\n        if (this._dropContainer) {\n            // Stop scrolling immediately, instead of waiting for the animation to finish.\n            this._dropContainer._stopScrolling();\n            this._animatePreviewToPlaceholder().then(() => {\n                this._cleanupDragArtifacts(event);\n                this._cleanupCachedDimensions();\n                this._dragDropRegistry.stopDragging(this);\n            });\n        }\n        else {\n            // Convert the active transform into a passive one. This means that next time\n            // the user starts dragging the item, its position will be calculated relatively\n            // to the new passive transform.\n            this._passiveTransform.x = this._activeTransform.x;\n            const pointerPosition = this._getPointerPositionOnPage(event);\n            this._passiveTransform.y = this._activeTransform.y;\n            this._ngZone.run(() => {\n                this.ended.next({\n                    source: this,\n                    distance: this._getDragDistance(pointerPosition),\n                    dropPoint: pointerPosition,\n                    event,\n                });\n            });\n            this._cleanupCachedDimensions();\n            this._dragDropRegistry.stopDragging(this);\n        }\n    }\n    /** Starts the dragging sequence. */\n    _startDragSequence(event) {\n        if (isTouchEvent(event)) {\n            this._lastTouchEventTime = Date.now();\n        }\n        this._toggleNativeDragInteractions();\n        const dropContainer = this._dropContainer;\n        if (dropContainer) {\n            const element = this._rootElement;\n            const parent = element.parentNode;\n            const placeholder = (this._placeholder = this._createPlaceholderElement());\n            const anchor = (this._anchor = this._anchor || this._document.createComment(''));\n            // Needs to happen before the root element is moved.\n            const shadowRoot = this._getShadowRoot();\n            // Insert an anchor node so that we can restore the element's position in the DOM.\n            parent.insertBefore(anchor, element);\n            // There's no risk of transforms stacking when inside a drop container so\n            // we can keep the initial transform up to date any time dragging starts.\n            this._initialTransform = element.style.transform || '';\n            // Create the preview after the initial transform has\n            // been cached, because it can be affected by the transform.\n            this._preview = this._createPreviewElement();\n            // We move the element out at the end of the body and we make it hidden, because keeping it in\n            // place will throw off the consumer's `:last-child` selectors. We can't remove the element\n            // from the DOM completely, because iOS will stop firing all subsequent events in the chain.\n            toggleVisibility(element, false, dragImportantProperties);\n            this._document.body.appendChild(parent.replaceChild(placeholder, element));\n            this._getPreviewInsertionPoint(parent, shadowRoot).appendChild(this._preview);\n            this.started.next({ source: this, event }); // Emit before notifying the container.\n            dropContainer.start();\n            this._initialContainer = dropContainer;\n            this._initialIndex = dropContainer.getItemIndex(this);\n        }\n        else {\n            this.started.next({ source: this, event });\n            this._initialContainer = this._initialIndex = undefined;\n        }\n        // Important to run after we've called `start` on the parent container\n        // so that it has had time to resolve its scrollable parents.\n        this._parentPositions.cache(dropContainer ? dropContainer.getScrollableParents() : []);\n    }\n    /**\n     * Sets up the different variables and subscriptions\n     * that will be necessary for the dragging sequence.\n     * @param referenceElement Element that started the drag sequence.\n     * @param event Browser event object that started the sequence.\n     */\n    _initializeDragSequence(referenceElement, event) {\n        // Stop propagation if the item is inside another\n        // draggable so we don't start multiple drag sequences.\n        if (this._parentDragRef) {\n            event.stopPropagation();\n        }\n        const isDragging = this.isDragging();\n        const isTouchSequence = isTouchEvent(event);\n        const isAuxiliaryMouseButton = !isTouchSequence && event.button !== 0;\n        const rootElement = this._rootElement;\n        const target = _getEventTarget(event);\n        const isSyntheticEvent = !isTouchSequence &&\n            this._lastTouchEventTime &&\n            this._lastTouchEventTime + MOUSE_EVENT_IGNORE_TIME > Date.now();\n        const isFakeEvent = isTouchSequence\n            ? isFakeTouchstartFromScreenReader(event)\n            : isFakeMousedownFromScreenReader(event);\n        // If the event started from an element with the native HTML drag&drop, it'll interfere\n        // with our own dragging (e.g. `img` tags do it by default). Prevent the default action\n        // to stop it from happening. Note that preventing on `dragstart` also seems to work, but\n        // it's flaky and it fails if the user drags it away quickly. Also note that we only want\n        // to do this for `mousedown` since doing the same for `touchstart` will stop any `click`\n        // events from firing on touch devices.\n        if (target && target.draggable && event.type === 'mousedown') {\n            event.preventDefault();\n        }\n        // Abort if the user is already dragging or is using a mouse button other than the primary one.\n        if (isDragging || isAuxiliaryMouseButton || isSyntheticEvent || isFakeEvent) {\n            return;\n        }\n        // If we've got handles, we need to disable the tap highlight on the entire root element,\n        // otherwise iOS will still add it, even though all the drag interactions on the handle\n        // are disabled.\n        if (this._handles.length) {\n            const rootStyles = rootElement.style;\n            this._rootElementTapHighlight = rootStyles.webkitTapHighlightColor || '';\n            rootStyles.webkitTapHighlightColor = 'transparent';\n        }\n        this._hasStartedDragging = this._hasMoved = false;\n        // Avoid multiple subscriptions and memory leaks when multi touch\n        // (isDragging check above isn't enough because of possible temporal and/or dimensional delays)\n        this._removeSubscriptions();\n        this._initialClientRect = this._rootElement.getBoundingClientRect();\n        this._pointerMoveSubscription = this._dragDropRegistry.pointerMove.subscribe(this._pointerMove);\n        this._pointerUpSubscription = this._dragDropRegistry.pointerUp.subscribe(this._pointerUp);\n        this._scrollSubscription = this._dragDropRegistry\n            .scrolled(this._getShadowRoot())\n            .subscribe(scrollEvent => this._updateOnScroll(scrollEvent));\n        if (this._boundaryElement) {\n            this._boundaryRect = getMutableClientRect(this._boundaryElement);\n        }\n        // If we have a custom preview we can't know ahead of time how large it'll be so we position\n        // it next to the cursor. The exception is when the consumer has opted into making the preview\n        // the same size as the root element, in which case we do know the size.\n        const previewTemplate = this._previewTemplate;\n        this._pickupPositionInElement =\n            previewTemplate && previewTemplate.template && !previewTemplate.matchSize\n                ? { x: 0, y: 0 }\n                : this._getPointerPositionInElement(this._initialClientRect, referenceElement, event);\n        const pointerPosition = (this._pickupPositionOnPage =\n            this._lastKnownPointerPosition =\n                this._getPointerPositionOnPage(event));\n        this._pointerDirectionDelta = { x: 0, y: 0 };\n        this._pointerPositionAtLastDirectionChange = { x: pointerPosition.x, y: pointerPosition.y };\n        this._dragStartTime = Date.now();\n        this._dragDropRegistry.startDragging(this, event);\n    }\n    /** Cleans up the DOM artifacts that were added to facilitate the element being dragged. */\n    _cleanupDragArtifacts(event) {\n        // Restore the element's visibility and insert it at its old position in the DOM.\n        // It's important that we maintain the position, because moving the element around in the DOM\n        // can throw off `NgFor` which does smart diffing and re-creates elements only when necessary,\n        // while moving the existing elements in all other cases.\n        toggleVisibility(this._rootElement, true, dragImportantProperties);\n        this._anchor.parentNode.replaceChild(this._rootElement, this._anchor);\n        this._destroyPreview();\n        this._destroyPlaceholder();\n        this._initialClientRect =\n            this._boundaryRect =\n                this._previewRect =\n                    this._initialTransform =\n                        undefined;\n        // Re-enter the NgZone since we bound `document` events on the outside.\n        this._ngZone.run(() => {\n            const container = this._dropContainer;\n            const currentIndex = container.getItemIndex(this);\n            const pointerPosition = this._getPointerPositionOnPage(event);\n            const distance = this._getDragDistance(pointerPosition);\n            const isPointerOverContainer = container._isOverContainer(pointerPosition.x, pointerPosition.y);\n            this.ended.next({ source: this, distance, dropPoint: pointerPosition, event });\n            this.dropped.next({\n                item: this,\n                currentIndex,\n                previousIndex: this._initialIndex,\n                container: container,\n                previousContainer: this._initialContainer,\n                isPointerOverContainer,\n                distance,\n                dropPoint: pointerPosition,\n                event,\n            });\n            container.drop(this, currentIndex, this._initialIndex, this._initialContainer, isPointerOverContainer, distance, pointerPosition, event);\n            this._dropContainer = this._initialContainer;\n        });\n    }\n    /**\n     * Updates the item's position in its drop container, or moves it\n     * into a new one, depending on its current drag position.\n     */\n    _updateActiveDropContainer({ x, y }, { x: rawX, y: rawY }) {\n        // Drop container that draggable has been moved into.\n        let newContainer = this._initialContainer._getSiblingContainerFromPosition(this, x, y);\n        // If we couldn't find a new container to move the item into, and the item has left its\n        // initial container, check whether the it's over the initial container. This handles the\n        // case where two containers are connected one way and the user tries to undo dragging an\n        // item into a new container.\n        if (!newContainer &&\n            this._dropContainer !== this._initialContainer &&\n            this._initialContainer._isOverContainer(x, y)) {\n            newContainer = this._initialContainer;\n        }\n        if (newContainer && newContainer !== this._dropContainer) {\n            this._ngZone.run(() => {\n                // Notify the old container that the item has left.\n                this.exited.next({ item: this, container: this._dropContainer });\n                this._dropContainer.exit(this);\n                // Notify the new container that the item has entered.\n                this._dropContainer = newContainer;\n                this._dropContainer.enter(this, x, y, newContainer === this._initialContainer &&\n                    // If we're re-entering the initial container and sorting is disabled,\n                    // put item the into its starting index to begin with.\n                    newContainer.sortingDisabled\n                    ? this._initialIndex\n                    : undefined);\n                this.entered.next({\n                    item: this,\n                    container: newContainer,\n                    currentIndex: newContainer.getItemIndex(this),\n                });\n            });\n        }\n        // Dragging may have been interrupted as a result of the events above.\n        if (this.isDragging()) {\n            this._dropContainer._startScrollingIfNecessary(rawX, rawY);\n            this._dropContainer._sortItem(this, x, y, this._pointerDirectionDelta);\n            if (this.constrainPosition) {\n                this._applyPreviewTransform(x, y);\n            }\n            else {\n                this._applyPreviewTransform(x - this._pickupPositionInElement.x, y - this._pickupPositionInElement.y);\n            }\n        }\n    }\n    /**\n     * Creates the element that will be rendered next to the user's pointer\n     * and will be used as a preview of the element that is being dragged.\n     */\n    _createPreviewElement() {\n        const previewConfig = this._previewTemplate;\n        const previewClass = this.previewClass;\n        const previewTemplate = previewConfig ? previewConfig.template : null;\n        let preview;\n        if (previewTemplate && previewConfig) {\n            // Measure the element before we've inserted the preview\n            // since the insertion could throw off the measurement.\n            const rootRect = previewConfig.matchSize ? this._initialClientRect : null;\n            const viewRef = previewConfig.viewContainer.createEmbeddedView(previewTemplate, previewConfig.context);\n            viewRef.detectChanges();\n            preview = getRootNode(viewRef, this._document);\n            this._previewRef = viewRef;\n            if (previewConfig.matchSize) {\n                matchElementSize(preview, rootRect);\n            }\n            else {\n                preview.style.transform = getTransform(this._pickupPositionOnPage.x, this._pickupPositionOnPage.y);\n            }\n        }\n        else {\n            preview = deepCloneNode(this._rootElement);\n            matchElementSize(preview, this._initialClientRect);\n            if (this._initialTransform) {\n                preview.style.transform = this._initialTransform;\n            }\n        }\n        extendStyles(preview.style, {\n            // It's important that we disable the pointer events on the preview, because\n            // it can throw off the `document.elementFromPoint` calls in the `CdkDropList`.\n            'pointer-events': 'none',\n            // We have to reset the margin, because it can throw off positioning relative to the viewport.\n            'margin': '0',\n            'position': 'fixed',\n            'top': '0',\n            'left': '0',\n            'z-index': `${this._config.zIndex || 1000}`,\n        }, dragImportantProperties);\n        toggleNativeDragInteractions(preview, false);\n        preview.classList.add('cdk-drag-preview');\n        preview.setAttribute('dir', this._direction);\n        if (previewClass) {\n            if (Array.isArray(previewClass)) {\n                previewClass.forEach(className => preview.classList.add(className));\n            }\n            else {\n                preview.classList.add(previewClass);\n            }\n        }\n        return preview;\n    }\n    /**\n     * Animates the preview element from its current position to the location of the drop placeholder.\n     * @returns Promise that resolves when the animation completes.\n     */\n    _animatePreviewToPlaceholder() {\n        // If the user hasn't moved yet, the transitionend event won't fire.\n        if (!this._hasMoved) {\n            return Promise.resolve();\n        }\n        const placeholderRect = this._placeholder.getBoundingClientRect();\n        // Apply the class that adds a transition to the preview.\n        this._preview.classList.add('cdk-drag-animating');\n        // Move the preview to the placeholder position.\n        this._applyPreviewTransform(placeholderRect.left, placeholderRect.top);\n        // If the element doesn't have a `transition`, the `transitionend` event won't fire. Since\n        // we need to trigger a style recalculation in order for the `cdk-drag-animating` class to\n        // apply its style, we take advantage of the available info to figure out whether we need to\n        // bind the event in the first place.\n        const duration = getTransformTransitionDurationInMs(this._preview);\n        if (duration === 0) {\n            return Promise.resolve();\n        }\n        return this._ngZone.runOutsideAngular(() => {\n            return new Promise(resolve => {\n                const handler = ((event) => {\n                    if (!event ||\n                        (_getEventTarget(event) === this._preview && event.propertyName === 'transform')) {\n                        this._preview?.removeEventListener('transitionend', handler);\n                        resolve();\n                        clearTimeout(timeout);\n                    }\n                });\n                // If a transition is short enough, the browser might not fire the `transitionend` event.\n                // Since we know how long it's supposed to take, add a timeout with a 50% buffer that'll\n                // fire if the transition hasn't completed when it was supposed to.\n                const timeout = setTimeout(handler, duration * 1.5);\n                this._preview.addEventListener('transitionend', handler);\n            });\n        });\n    }\n    /** Creates an element that will be shown instead of the current element while dragging. */\n    _createPlaceholderElement() {\n        const placeholderConfig = this._placeholderTemplate;\n        const placeholderTemplate = placeholderConfig ? placeholderConfig.template : null;\n        let placeholder;\n        if (placeholderTemplate) {\n            this._placeholderRef = placeholderConfig.viewContainer.createEmbeddedView(placeholderTemplate, placeholderConfig.context);\n            this._placeholderRef.detectChanges();\n            placeholder = getRootNode(this._placeholderRef, this._document);\n        }\n        else {\n            placeholder = deepCloneNode(this._rootElement);\n        }\n        // Stop pointer events on the preview so the user can't\n        // interact with it while the preview is animating.\n        placeholder.style.pointerEvents = 'none';\n        placeholder.classList.add('cdk-drag-placeholder');\n        return placeholder;\n    }\n    /**\n     * Figures out the coordinates at which an element was picked up.\n     * @param referenceElement Element that initiated the dragging.\n     * @param event Event that initiated the dragging.\n     */\n    _getPointerPositionInElement(elementRect, referenceElement, event) {\n        const handleElement = referenceElement === this._rootElement ? null : referenceElement;\n        const referenceRect = handleElement ? handleElement.getBoundingClientRect() : elementRect;\n        const point = isTouchEvent(event) ? event.targetTouches[0] : event;\n        const scrollPosition = this._getViewportScrollPosition();\n        const x = point.pageX - referenceRect.left - scrollPosition.left;\n        const y = point.pageY - referenceRect.top - scrollPosition.top;\n        return {\n            x: referenceRect.left - elementRect.left + x,\n            y: referenceRect.top - elementRect.top + y,\n        };\n    }\n    /** Determines the point of the page that was touched by the user. */\n    _getPointerPositionOnPage(event) {\n        const scrollPosition = this._getViewportScrollPosition();\n        const point = isTouchEvent(event)\n            ? // `touches` will be empty for start/end events so we have to fall back to `changedTouches`.\n                // Also note that on real devices we're guaranteed for either `touches` or `changedTouches`\n                // to have a value, but Firefox in device emulation mode has a bug where both can be empty\n                // for `touchstart` and `touchend` so we fall back to a dummy object in order to avoid\n                // throwing an error. The value returned here will be incorrect, but since this only\n                // breaks inside a developer tool and the value is only used for secondary information,\n                // we can get away with it. See https://bugzilla.mozilla.org/show_bug.cgi?id=1615824.\n                event.touches[0] || event.changedTouches[0] || { pageX: 0, pageY: 0 }\n            : event;\n        const x = point.pageX - scrollPosition.left;\n        const y = point.pageY - scrollPosition.top;\n        // if dragging SVG element, try to convert from the screen coordinate system to the SVG\n        // coordinate system\n        if (this._ownerSVGElement) {\n            const svgMatrix = this._ownerSVGElement.getScreenCTM();\n            if (svgMatrix) {\n                const svgPoint = this._ownerSVGElement.createSVGPoint();\n                svgPoint.x = x;\n                svgPoint.y = y;\n                return svgPoint.matrixTransform(svgMatrix.inverse());\n            }\n        }\n        return { x, y };\n    }\n    /** Gets the pointer position on the page, accounting for any position constraints. */\n    _getConstrainedPointerPosition(point) {\n        const dropContainerLock = this._dropContainer ? this._dropContainer.lockAxis : null;\n        let { x, y } = this.constrainPosition\n            ? this.constrainPosition(point, this, this._initialClientRect, this._pickupPositionInElement)\n            : point;\n        if (this.lockAxis === 'x' || dropContainerLock === 'x') {\n            y = this._pickupPositionOnPage.y;\n        }\n        else if (this.lockAxis === 'y' || dropContainerLock === 'y') {\n            x = this._pickupPositionOnPage.x;\n        }\n        if (this._boundaryRect) {\n            const { x: pickupX, y: pickupY } = this._pickupPositionInElement;\n            const boundaryRect = this._boundaryRect;\n            const { width: previewWidth, height: previewHeight } = this._getPreviewRect();\n            const minY = boundaryRect.top + pickupY;\n            const maxY = boundaryRect.bottom - (previewHeight - pickupY);\n            const minX = boundaryRect.left + pickupX;\n            const maxX = boundaryRect.right - (previewWidth - pickupX);\n            x = clamp$1(x, minX, maxX);\n            y = clamp$1(y, minY, maxY);\n        }\n        return { x, y };\n    }\n    /** Updates the current drag delta, based on the user's current pointer position on the page. */\n    _updatePointerDirectionDelta(pointerPositionOnPage) {\n        const { x, y } = pointerPositionOnPage;\n        const delta = this._pointerDirectionDelta;\n        const positionSinceLastChange = this._pointerPositionAtLastDirectionChange;\n        // Amount of pixels the user has dragged since the last time the direction changed.\n        const changeX = Math.abs(x - positionSinceLastChange.x);\n        const changeY = Math.abs(y - positionSinceLastChange.y);\n        // Because we handle pointer events on a per-pixel basis, we don't want the delta\n        // to change for every pixel, otherwise anything that depends on it can look erratic.\n        // To make the delta more consistent, we track how much the user has moved since the last\n        // delta change and we only update it after it has reached a certain threshold.\n        if (changeX > this._config.pointerDirectionChangeThreshold) {\n            delta.x = x > positionSinceLastChange.x ? 1 : -1;\n            positionSinceLastChange.x = x;\n        }\n        if (changeY > this._config.pointerDirectionChangeThreshold) {\n            delta.y = y > positionSinceLastChange.y ? 1 : -1;\n            positionSinceLastChange.y = y;\n        }\n        return delta;\n    }\n    /** Toggles the native drag interactions, based on how many handles are registered. */\n    _toggleNativeDragInteractions() {\n        if (!this._rootElement || !this._handles) {\n            return;\n        }\n        const shouldEnable = this._handles.length > 0 || !this.isDragging();\n        if (shouldEnable !== this._nativeInteractionsEnabled) {\n            this._nativeInteractionsEnabled = shouldEnable;\n            toggleNativeDragInteractions(this._rootElement, shouldEnable);\n        }\n    }\n    /** Removes the manually-added event listeners from the root element. */\n    _removeRootElementListeners(element) {\n        element.removeEventListener('mousedown', this._pointerDown, activeEventListenerOptions);\n        element.removeEventListener('touchstart', this._pointerDown, passiveEventListenerOptions);\n        element.removeEventListener('dragstart', this._nativeDragStart, activeEventListenerOptions);\n    }\n    /**\n     * Applies a `transform` to the root element, taking into account any existing transforms on it.\n     * @param x New transform value along the X axis.\n     * @param y New transform value along the Y axis.\n     */\n    _applyRootElementTransform(x, y) {\n        const transform = getTransform(x, y);\n        const styles = this._rootElement.style;\n        // Cache the previous transform amount only after the first drag sequence, because\n        // we don't want our own transforms to stack on top of each other.\n        // Should be excluded none because none + translate3d(x, y, x) is invalid css\n        if (this._initialTransform == null) {\n            this._initialTransform =\n                styles.transform && styles.transform != 'none' ? styles.transform : '';\n        }\n        // Preserve the previous `transform` value, if there was one. Note that we apply our own\n        // transform before the user's, because things like rotation can affect which direction\n        // the element will be translated towards.\n        styles.transform = combineTransforms(transform, this._initialTransform);\n    }\n    /**\n     * Applies a `transform` to the preview, taking into account any existing transforms on it.\n     * @param x New transform value along the X axis.\n     * @param y New transform value along the Y axis.\n     */\n    _applyPreviewTransform(x, y) {\n        // Only apply the initial transform if the preview is a clone of the original element, otherwise\n        // it could be completely different and the transform might not make sense anymore.\n        const initialTransform = this._previewTemplate?.template ? undefined : this._initialTransform;\n        const transform = getTransform(x, y);\n        this._preview.style.transform = combineTransforms(transform, initialTransform);\n    }\n    /**\n     * Gets the distance that the user has dragged during the current drag sequence.\n     * @param currentPosition Current position of the user's pointer.\n     */\n    _getDragDistance(currentPosition) {\n        const pickupPosition = this._pickupPositionOnPage;\n        if (pickupPosition) {\n            return { x: currentPosition.x - pickupPosition.x, y: currentPosition.y - pickupPosition.y };\n        }\n        return { x: 0, y: 0 };\n    }\n    /** Cleans up any cached element dimensions that we don't need after dragging has stopped. */\n    _cleanupCachedDimensions() {\n        this._boundaryRect = this._previewRect = undefined;\n        this._parentPositions.clear();\n    }\n    /**\n     * Checks whether the element is still inside its boundary after the viewport has been resized.\n     * If not, the position is adjusted so that the element fits again.\n     */\n    _containInsideBoundaryOnResize() {\n        let { x, y } = this._passiveTransform;\n        if ((x === 0 && y === 0) || this.isDragging() || !this._boundaryElement) {\n            return;\n        }\n        // Note: don't use `_clientRectAtStart` here, because we want the latest position.\n        const elementRect = this._rootElement.getBoundingClientRect();\n        const boundaryRect = this._boundaryElement.getBoundingClientRect();\n        // It's possible that the element got hidden away after dragging (e.g. by switching to a\n        // different tab). Don't do anything in this case so we don't clear the user's position.\n        if ((boundaryRect.width === 0 && boundaryRect.height === 0) ||\n            (elementRect.width === 0 && elementRect.height === 0)) {\n            return;\n        }\n        const leftOverflow = boundaryRect.left - elementRect.left;\n        const rightOverflow = elementRect.right - boundaryRect.right;\n        const topOverflow = boundaryRect.top - elementRect.top;\n        const bottomOverflow = elementRect.bottom - boundaryRect.bottom;\n        // If the element has become wider than the boundary, we can't\n        // do much to make it fit so we just anchor it to the left.\n        if (boundaryRect.width > elementRect.width) {\n            if (leftOverflow > 0) {\n                x += leftOverflow;\n            }\n            if (rightOverflow > 0) {\n                x -= rightOverflow;\n            }\n        }\n        else {\n            x = 0;\n        }\n        // If the element has become taller than the boundary, we can't\n        // do much to make it fit so we just anchor it to the top.\n        if (boundaryRect.height > elementRect.height) {\n            if (topOverflow > 0) {\n                y += topOverflow;\n            }\n            if (bottomOverflow > 0) {\n                y -= bottomOverflow;\n            }\n        }\n        else {\n            y = 0;\n        }\n        if (x !== this._passiveTransform.x || y !== this._passiveTransform.y) {\n            this.setFreeDragPosition({ y, x });\n        }\n    }\n    /** Gets the drag start delay, based on the event type. */\n    _getDragStartDelay(event) {\n        const value = this.dragStartDelay;\n        if (typeof value === 'number') {\n            return value;\n        }\n        else if (isTouchEvent(event)) {\n            return value.touch;\n        }\n        return value ? value.mouse : 0;\n    }\n    /** Updates the internal state of the draggable element when scrolling has occurred. */\n    _updateOnScroll(event) {\n        const scrollDifference = this._parentPositions.handleScroll(event);\n        if (scrollDifference) {\n            const target = _getEventTarget(event);\n            // ClientRect dimensions are based on the scroll position of the page and its parent\n            // node so we have to update the cached boundary ClientRect if the user has scrolled.\n            if (this._boundaryRect &&\n                target !== this._boundaryElement &&\n                target.contains(this._boundaryElement)) {\n                adjustClientRect(this._boundaryRect, scrollDifference.top, scrollDifference.left);\n            }\n            this._pickupPositionOnPage.x += scrollDifference.left;\n            this._pickupPositionOnPage.y += scrollDifference.top;\n            // If we're in free drag mode, we have to update the active transform, because\n            // it isn't relative to the viewport like the preview inside a drop list.\n            if (!this._dropContainer) {\n                this._activeTransform.x -= scrollDifference.left;\n                this._activeTransform.y -= scrollDifference.top;\n                this._applyRootElementTransform(this._activeTransform.x, this._activeTransform.y);\n            }\n        }\n    }\n    /** Gets the scroll position of the viewport. */\n    _getViewportScrollPosition() {\n        return (this._parentPositions.positions.get(this._document)?.scrollPosition ||\n            this._parentPositions.getViewportScrollPosition());\n    }\n    /**\n     * Lazily resolves and returns the shadow root of the element. We do this in a function, rather\n     * than saving it in property directly on init, because we want to resolve it as late as possible\n     * in order to ensure that the element has been moved into the shadow DOM. Doing it inside the\n     * constructor might be too early if the element is inside of something like `ngFor` or `ngIf`.\n     */\n    _getShadowRoot() {\n        if (this._cachedShadowRoot === undefined) {\n            this._cachedShadowRoot = _getShadowRoot(this._rootElement);\n        }\n        return this._cachedShadowRoot;\n    }\n    /** Gets the element into which the drag preview should be inserted. */\n    _getPreviewInsertionPoint(initialParent, shadowRoot) {\n        const previewContainer = this._previewContainer || 'global';\n        if (previewContainer === 'parent') {\n            return initialParent;\n        }\n        if (previewContainer === 'global') {\n            const documentRef = this._document;\n            // We can't use the body if the user is in fullscreen mode,\n            // because the preview will render under the fullscreen element.\n            // TODO(crisbeto): dedupe this with the `FullscreenOverlayContainer` eventually.\n            return (shadowRoot ||\n                documentRef.fullscreenElement ||\n                documentRef.webkitFullscreenElement ||\n                documentRef.mozFullScreenElement ||\n                documentRef.msFullscreenElement ||\n                documentRef.body);\n        }\n        return coerceElement(previewContainer);\n    }\n    /** Lazily resolves and returns the dimensions of the preview. */\n    _getPreviewRect() {\n        // Cache the preview element rect if we haven't cached it already or if\n        // we cached it too early before the element dimensions were computed.\n        if (!this._previewRect || (!this._previewRect.width && !this._previewRect.height)) {\n            this._previewRect = this._preview\n                ? this._preview.getBoundingClientRect()\n                : this._initialClientRect;\n        }\n        return this._previewRect;\n    }\n    /** Gets a handle that is the target of an event. */\n    _getTargetHandle(event) {\n        return this._handles.find(handle => {\n            return event.target && (event.target === handle || handle.contains(event.target));\n        });\n    }\n}\n/**\n * Gets a 3d `transform` that can be applied to an element.\n * @param x Desired position of the element along the X axis.\n * @param y Desired position of the element along the Y axis.\n */\nfunction getTransform(x, y) {\n    // Round the transforms since some browsers will\n    // blur the elements for sub-pixel transforms.\n    return `translate3d(${Math.round(x)}px, ${Math.round(y)}px, 0)`;\n}\n/** Clamps a value between a minimum and a maximum. */\nfunction clamp$1(value, min, max) {\n    return Math.max(min, Math.min(max, value));\n}\n/** Determines whether an event is a touch event. */\nfunction isTouchEvent(event) {\n    // This function is called for every pixel that the user has dragged so we need it to be\n    // as fast as possible. Since we only bind mouse events and touch events, we can assume\n    // that if the event's name starts with `t`, it's a touch event.\n    return event.type[0] === 't';\n}\n/**\n * Gets the root HTML element of an embedded view.\n * If the root is not an HTML element it gets wrapped in one.\n */\nfunction getRootNode(viewRef, _document) {\n    const rootNodes = viewRef.rootNodes;\n    if (rootNodes.length === 1 && rootNodes[0].nodeType === _document.ELEMENT_NODE) {\n        return rootNodes[0];\n    }\n    const wrapper = _document.createElement('div');\n    rootNodes.forEach(node => wrapper.appendChild(node));\n    return wrapper;\n}\n/**\n * Matches the target element's size to the source's size.\n * @param target Element that needs to be resized.\n * @param sourceRect Dimensions of the source element.\n */\nfunction matchElementSize(target, sourceRect) {\n    target.style.width = `${sourceRect.width}px`;\n    target.style.height = `${sourceRect.height}px`;\n    target.style.transform = getTransform(sourceRect.left, sourceRect.top);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Moves an item one index in an array to another.\n * @param array Array in which to move the item.\n * @param fromIndex Starting index of the item.\n * @param toIndex Index to which the item should be moved.\n */\nfunction moveItemInArray(array, fromIndex, toIndex) {\n    const from = clamp(fromIndex, array.length - 1);\n    const to = clamp(toIndex, array.length - 1);\n    if (from === to) {\n        return;\n    }\n    const target = array[from];\n    const delta = to < from ? -1 : 1;\n    for (let i = from; i !== to; i += delta) {\n        array[i] = array[i + delta];\n    }\n    array[to] = target;\n}\n/**\n * Moves an item from one array to another.\n * @param currentArray Array from which to transfer the item.\n * @param targetArray Array into which to put the item.\n * @param currentIndex Index of the item in its current array.\n * @param targetIndex Index at which to insert the item.\n */\nfunction transferArrayItem(currentArray, targetArray, currentIndex, targetIndex) {\n    const from = clamp(currentIndex, currentArray.length - 1);\n    const to = clamp(targetIndex, targetArray.length);\n    if (currentArray.length) {\n        targetArray.splice(to, 0, currentArray.splice(from, 1)[0]);\n    }\n}\n/**\n * Copies an item from one array to another, leaving it in its\n * original position in current array.\n * @param currentArray Array from which to copy the item.\n * @param targetArray Array into which is copy the item.\n * @param currentIndex Index of the item in its current array.\n * @param targetIndex Index at which to insert the item.\n *\n */\nfunction copyArrayItem(currentArray, targetArray, currentIndex, targetIndex) {\n    const to = clamp(targetIndex, targetArray.length);\n    if (currentArray.length) {\n        targetArray.splice(to, 0, currentArray[currentIndex]);\n    }\n}\n/** Clamps a number between zero and a maximum. */\nfunction clamp(value, max) {\n    return Math.max(0, Math.min(max, value));\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Strategy that only supports sorting along a single axis.\n * Items are reordered using CSS transforms which allows for sorting to be animated.\n * @docs-private\n */\nclass SingleAxisSortStrategy {\n    constructor(_element, _dragDropRegistry) {\n        this._element = _element;\n        this._dragDropRegistry = _dragDropRegistry;\n        /** Cache of the dimensions of all the items inside the container. */\n        this._itemPositions = [];\n        /** Direction in which the list is oriented. */\n        this.orientation = 'vertical';\n        /**\n         * Keeps track of the item that was last swapped with the dragged item, as well as what direction\n         * the pointer was moving in when the swap occurred and whether the user's pointer continued to\n         * overlap with the swapped item after the swapping occurred.\n         */\n        this._previousSwap = {\n            drag: null,\n            delta: 0,\n            overlaps: false,\n        };\n    }\n    /**\n     * To be called when the drag sequence starts.\n     * @param items Items that are currently in the list.\n     */\n    start(items) {\n        this.withItems(items);\n    }\n    /**\n     * To be called when an item is being sorted.\n     * @param item Item to be sorted.\n     * @param pointerX Position of the item along the X axis.\n     * @param pointerY Position of the item along the Y axis.\n     * @param pointerDelta Direction in which the pointer is moving along each axis.\n     */\n    sort(item, pointerX, pointerY, pointerDelta) {\n        const siblings = this._itemPositions;\n        const newIndex = this._getItemIndexFromPointerPosition(item, pointerX, pointerY, pointerDelta);\n        if (newIndex === -1 && siblings.length > 0) {\n            return null;\n        }\n        const isHorizontal = this.orientation === 'horizontal';\n        const currentIndex = siblings.findIndex(currentItem => currentItem.drag === item);\n        const siblingAtNewPosition = siblings[newIndex];\n        const currentPosition = siblings[currentIndex].clientRect;\n        const newPosition = siblingAtNewPosition.clientRect;\n        const delta = currentIndex > newIndex ? 1 : -1;\n        // How many pixels the item's placeholder should be offset.\n        const itemOffset = this._getItemOffsetPx(currentPosition, newPosition, delta);\n        // How many pixels all the other items should be offset.\n        const siblingOffset = this._getSiblingOffsetPx(currentIndex, siblings, delta);\n        // Save the previous order of the items before moving the item to its new index.\n        // We use this to check whether an item has been moved as a result of the sorting.\n        const oldOrder = siblings.slice();\n        // Shuffle the array in place.\n        moveItemInArray(siblings, currentIndex, newIndex);\n        siblings.forEach((sibling, index) => {\n            // Don't do anything if the position hasn't changed.\n            if (oldOrder[index] === sibling) {\n                return;\n            }\n            const isDraggedItem = sibling.drag === item;\n            const offset = isDraggedItem ? itemOffset : siblingOffset;\n            const elementToOffset = isDraggedItem\n                ? item.getPlaceholderElement()\n                : sibling.drag.getRootElement();\n            // Update the offset to reflect the new position.\n            sibling.offset += offset;\n            // Since we're moving the items with a `transform`, we need to adjust their cached\n            // client rects to reflect their new position, as well as swap their positions in the cache.\n            // Note that we shouldn't use `getBoundingClientRect` here to update the cache, because the\n            // elements may be mid-animation which will give us a wrong result.\n            if (isHorizontal) {\n                // Round the transforms since some browsers will\n                // blur the elements, for sub-pixel transforms.\n                elementToOffset.style.transform = combineTransforms(`translate3d(${Math.round(sibling.offset)}px, 0, 0)`, sibling.initialTransform);\n                adjustClientRect(sibling.clientRect, 0, offset);\n            }\n            else {\n                elementToOffset.style.transform = combineTransforms(`translate3d(0, ${Math.round(sibling.offset)}px, 0)`, sibling.initialTransform);\n                adjustClientRect(sibling.clientRect, offset, 0);\n            }\n        });\n        // Note that it's important that we do this after the client rects have been adjusted.\n        this._previousSwap.overlaps = isInsideClientRect(newPosition, pointerX, pointerY);\n        this._previousSwap.drag = siblingAtNewPosition.drag;\n        this._previousSwap.delta = isHorizontal ? pointerDelta.x : pointerDelta.y;\n        return { previousIndex: currentIndex, currentIndex: newIndex };\n    }\n    /**\n     * Called when an item is being moved into the container.\n     * @param item Item that was moved into the container.\n     * @param pointerX Position of the item along the X axis.\n     * @param pointerY Position of the item along the Y axis.\n     * @param index Index at which the item entered. If omitted, the container will try to figure it\n     *   out automatically.\n     */\n    enter(item, pointerX, pointerY, index) {\n        const newIndex = index == null || index < 0\n            ? // We use the coordinates of where the item entered the drop\n                // zone to figure out at which index it should be inserted.\n                this._getItemIndexFromPointerPosition(item, pointerX, pointerY)\n            : index;\n        const activeDraggables = this._activeDraggables;\n        const currentIndex = activeDraggables.indexOf(item);\n        const placeholder = item.getPlaceholderElement();\n        let newPositionReference = activeDraggables[newIndex];\n        // If the item at the new position is the same as the item that is being dragged,\n        // it means that we're trying to restore the item to its initial position. In this\n        // case we should use the next item from the list as the reference.\n        if (newPositionReference === item) {\n            newPositionReference = activeDraggables[newIndex + 1];\n        }\n        // If we didn't find a new position reference, it means that either the item didn't start off\n        // in this container, or that the item requested to be inserted at the end of the list.\n        if (!newPositionReference &&\n            (newIndex == null || newIndex === -1 || newIndex < activeDraggables.length - 1) &&\n            this._shouldEnterAsFirstChild(pointerX, pointerY)) {\n            newPositionReference = activeDraggables[0];\n        }\n        // Since the item may be in the `activeDraggables` already (e.g. if the user dragged it\n        // into another container and back again), we have to ensure that it isn't duplicated.\n        if (currentIndex > -1) {\n            activeDraggables.splice(currentIndex, 1);\n        }\n        // Don't use items that are being dragged as a reference, because\n        // their element has been moved down to the bottom of the body.\n        if (newPositionReference && !this._dragDropRegistry.isDragging(newPositionReference)) {\n            const element = newPositionReference.getRootElement();\n            element.parentElement.insertBefore(placeholder, element);\n            activeDraggables.splice(newIndex, 0, item);\n        }\n        else {\n            coerceElement(this._element).appendChild(placeholder);\n            activeDraggables.push(item);\n        }\n        // The transform needs to be cleared so it doesn't throw off the measurements.\n        placeholder.style.transform = '';\n        // Note that usually `start` is called together with `enter` when an item goes into a new\n        // container. This will cache item positions, but we need to refresh them since the amount\n        // of items has changed.\n        this._cacheItemPositions();\n    }\n    /** Sets the items that are currently part of the list. */\n    withItems(items) {\n        this._activeDraggables = items.slice();\n        this._cacheItemPositions();\n    }\n    /** Assigns a sort predicate to the strategy. */\n    withSortPredicate(predicate) {\n        this._sortPredicate = predicate;\n    }\n    /** Resets the strategy to its initial state before dragging was started. */\n    reset() {\n        // TODO(crisbeto): may have to wait for the animations to finish.\n        this._activeDraggables.forEach(item => {\n            const rootElement = item.getRootElement();\n            if (rootElement) {\n                const initialTransform = this._itemPositions.find(p => p.drag === item)?.initialTransform;\n                rootElement.style.transform = initialTransform || '';\n            }\n        });\n        this._itemPositions = [];\n        this._activeDraggables = [];\n        this._previousSwap.drag = null;\n        this._previousSwap.delta = 0;\n        this._previousSwap.overlaps = false;\n    }\n    /**\n     * Gets a snapshot of items currently in the list.\n     * Can include items that we dragged in from another list.\n     */\n    getActiveItemsSnapshot() {\n        return this._activeDraggables;\n    }\n    /** Gets the index of a specific item. */\n    getItemIndex(item) {\n        // Items are sorted always by top/left in the cache, however they flow differently in RTL.\n        // The rest of the logic still stands no matter what orientation we're in, however\n        // we need to invert the array when determining the index.\n        const items = this.orientation === 'horizontal' && this.direction === 'rtl'\n            ? this._itemPositions.slice().reverse()\n            : this._itemPositions;\n        return items.findIndex(currentItem => currentItem.drag === item);\n    }\n    /** Used to notify the strategy that the scroll position has changed. */\n    updateOnScroll(topDifference, leftDifference) {\n        // Since we know the amount that the user has scrolled we can shift all of the\n        // client rectangles ourselves. This is cheaper than re-measuring everything and\n        // we can avoid inconsistent behavior where we might be measuring the element before\n        // its position has changed.\n        this._itemPositions.forEach(({ clientRect }) => {\n            adjustClientRect(clientRect, topDifference, leftDifference);\n        });\n        // We need two loops for this, because we want all of the cached\n        // positions to be up-to-date before we re-sort the item.\n        this._itemPositions.forEach(({ drag }) => {\n            if (this._dragDropRegistry.isDragging(drag)) {\n                // We need to re-sort the item manually, because the pointer move\n                // events won't be dispatched while the user is scrolling.\n                drag._sortFromLastPointerPosition();\n            }\n        });\n    }\n    /** Refreshes the position cache of the items and sibling containers. */\n    _cacheItemPositions() {\n        const isHorizontal = this.orientation === 'horizontal';\n        this._itemPositions = this._activeDraggables\n            .map(drag => {\n            const elementToMeasure = drag.getVisibleElement();\n            return {\n                drag,\n                offset: 0,\n                initialTransform: elementToMeasure.style.transform || '',\n                clientRect: getMutableClientRect(elementToMeasure),\n            };\n        })\n            .sort((a, b) => {\n            return isHorizontal\n                ? a.clientRect.left - b.clientRect.left\n                : a.clientRect.top - b.clientRect.top;\n        });\n    }\n    /**\n     * Gets the offset in pixels by which the item that is being dragged should be moved.\n     * @param currentPosition Current position of the item.\n     * @param newPosition Position of the item where the current item should be moved.\n     * @param delta Direction in which the user is moving.\n     */\n    _getItemOffsetPx(currentPosition, newPosition, delta) {\n        const isHorizontal = this.orientation === 'horizontal';\n        let itemOffset = isHorizontal\n            ? newPosition.left - currentPosition.left\n            : newPosition.top - currentPosition.top;\n        // Account for differences in the item width/height.\n        if (delta === -1) {\n            itemOffset += isHorizontal\n                ? newPosition.width - currentPosition.width\n                : newPosition.height - currentPosition.height;\n        }\n        return itemOffset;\n    }\n    /**\n     * Gets the offset in pixels by which the items that aren't being dragged should be moved.\n     * @param currentIndex Index of the item currently being dragged.\n     * @param siblings All of the items in the list.\n     * @param delta Direction in which the user is moving.\n     */\n    _getSiblingOffsetPx(currentIndex, siblings, delta) {\n        const isHorizontal = this.orientation === 'horizontal';\n        const currentPosition = siblings[currentIndex].clientRect;\n        const immediateSibling = siblings[currentIndex + delta * -1];\n        let siblingOffset = currentPosition[isHorizontal ? 'width' : 'height'] * delta;\n        if (immediateSibling) {\n            const start = isHorizontal ? 'left' : 'top';\n            const end = isHorizontal ? 'right' : 'bottom';\n            // Get the spacing between the start of the current item and the end of the one immediately\n            // after it in the direction in which the user is dragging, or vice versa. We add it to the\n            // offset in order to push the element to where it will be when it's inline and is influenced\n            // by the `margin` of its siblings.\n            if (delta === -1) {\n                siblingOffset -= immediateSibling.clientRect[start] - currentPosition[end];\n            }\n            else {\n                siblingOffset += currentPosition[start] - immediateSibling.clientRect[end];\n            }\n        }\n        return siblingOffset;\n    }\n    /**\n     * Checks if pointer is entering in the first position\n     * @param pointerX Position of the user's pointer along the X axis.\n     * @param pointerY Position of the user's pointer along the Y axis.\n     */\n    _shouldEnterAsFirstChild(pointerX, pointerY) {\n        if (!this._activeDraggables.length) {\n            return false;\n        }\n        const itemPositions = this._itemPositions;\n        const isHorizontal = this.orientation === 'horizontal';\n        // `itemPositions` are sorted by position while `activeDraggables` are sorted by child index\n        // check if container is using some sort of \"reverse\" ordering (eg: flex-direction: row-reverse)\n        const reversed = itemPositions[0].drag !== this._activeDraggables[0];\n        if (reversed) {\n            const lastItemRect = itemPositions[itemPositions.length - 1].clientRect;\n            return isHorizontal ? pointerX >= lastItemRect.right : pointerY >= lastItemRect.bottom;\n        }\n        else {\n            const firstItemRect = itemPositions[0].clientRect;\n            return isHorizontal ? pointerX <= firstItemRect.left : pointerY <= firstItemRect.top;\n        }\n    }\n    /**\n     * Gets the index of an item in the drop container, based on the position of the user's pointer.\n     * @param item Item that is being sorted.\n     * @param pointerX Position of the user's pointer along the X axis.\n     * @param pointerY Position of the user's pointer along the Y axis.\n     * @param delta Direction in which the user is moving their pointer.\n     */\n    _getItemIndexFromPointerPosition(item, pointerX, pointerY, delta) {\n        const isHorizontal = this.orientation === 'horizontal';\n        const index = this._itemPositions.findIndex(({ drag, clientRect }) => {\n            // Skip the item itself.\n            if (drag === item) {\n                return false;\n            }\n            if (delta) {\n                const direction = isHorizontal ? delta.x : delta.y;\n                // If the user is still hovering over the same item as last time, their cursor hasn't left\n                // the item after we made the swap, and they didn't change the direction in which they're\n                // dragging, we don't consider it a direction swap.\n                if (drag === this._previousSwap.drag &&\n                    this._previousSwap.overlaps &&\n                    direction === this._previousSwap.delta) {\n                    return false;\n                }\n            }\n            return isHorizontal\n                ? // Round these down since most browsers report client rects with\n                    // sub-pixel precision, whereas the pointer coordinates are rounded to pixels.\n                    pointerX >= Math.floor(clientRect.left) && pointerX < Math.floor(clientRect.right)\n                : pointerY >= Math.floor(clientRect.top) && pointerY < Math.floor(clientRect.bottom);\n        });\n        return index === -1 || !this._sortPredicate(index, item) ? -1 : index;\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Proximity, as a ratio to width/height, at which a\n * dragged item will affect the drop container.\n */\nconst DROP_PROXIMITY_THRESHOLD = 0.05;\n/**\n * Proximity, as a ratio to width/height at which to start auto-scrolling the drop list or the\n * viewport. The value comes from trying it out manually until it feels right.\n */\nconst SCROLL_PROXIMITY_THRESHOLD = 0.05;\n/**\n * Reference to a drop list. Used to manipulate or dispose of the container.\n */\nclass DropListRef {\n    constructor(element, _dragDropRegistry, _document, _ngZone, _viewportRuler) {\n        this._dragDropRegistry = _dragDropRegistry;\n        this._ngZone = _ngZone;\n        this._viewportRuler = _viewportRuler;\n        /** Whether starting a dragging sequence from this container is disabled. */\n        this.disabled = false;\n        /** Whether sorting items within the list is disabled. */\n        this.sortingDisabled = false;\n        /**\n         * Whether auto-scrolling the view when the user\n         * moves their pointer close to the edges is disabled.\n         */\n        this.autoScrollDisabled = false;\n        /** Number of pixels to scroll for each frame when auto-scrolling an element. */\n        this.autoScrollStep = 2;\n        /**\n         * Function that is used to determine whether an item\n         * is allowed to be moved into a drop container.\n         */\n        this.enterPredicate = () => true;\n        /** Function that is used to determine whether an item can be sorted into a particular index. */\n        this.sortPredicate = () => true;\n        /** Emits right before dragging has started. */\n        this.beforeStarted = new Subject();\n        /**\n         * Emits when the user has moved a new drag item into this container.\n         */\n        this.entered = new Subject();\n        /**\n         * Emits when the user removes an item from the container\n         * by dragging it into another container.\n         */\n        this.exited = new Subject();\n        /** Emits when the user drops an item inside the container. */\n        this.dropped = new Subject();\n        /** Emits as the user is swapping items while actively dragging. */\n        this.sorted = new Subject();\n        /** Whether an item in the list is being dragged. */\n        this._isDragging = false;\n        /** Draggable items in the container. */\n        this._draggables = [];\n        /** Drop lists that are connected to the current one. */\n        this._siblings = [];\n        /** Connected siblings that currently have a dragged item. */\n        this._activeSiblings = new Set();\n        /** Subscription to the window being scrolled. */\n        this._viewportScrollSubscription = Subscription.EMPTY;\n        /** Vertical direction in which the list is currently scrolling. */\n        this._verticalScrollDirection = 0 /* AutoScrollVerticalDirection.NONE */;\n        /** Horizontal direction in which the list is currently scrolling. */\n        this._horizontalScrollDirection = 0 /* AutoScrollHorizontalDirection.NONE */;\n        /** Used to signal to the current auto-scroll sequence when to stop. */\n        this._stopScrollTimers = new Subject();\n        /** Shadow root of the current element. Necessary for `elementFromPoint` to resolve correctly. */\n        this._cachedShadowRoot = null;\n        /** Starts the interval that'll auto-scroll the element. */\n        this._startScrollInterval = () => {\n            this._stopScrolling();\n            interval(0, animationFrameScheduler)\n                .pipe(takeUntil(this._stopScrollTimers))\n                .subscribe(() => {\n                const node = this._scrollNode;\n                const scrollStep = this.autoScrollStep;\n                if (this._verticalScrollDirection === 1 /* AutoScrollVerticalDirection.UP */) {\n                    node.scrollBy(0, -scrollStep);\n                }\n                else if (this._verticalScrollDirection === 2 /* AutoScrollVerticalDirection.DOWN */) {\n                    node.scrollBy(0, scrollStep);\n                }\n                if (this._horizontalScrollDirection === 1 /* AutoScrollHorizontalDirection.LEFT */) {\n                    node.scrollBy(-scrollStep, 0);\n                }\n                else if (this._horizontalScrollDirection === 2 /* AutoScrollHorizontalDirection.RIGHT */) {\n                    node.scrollBy(scrollStep, 0);\n                }\n            });\n        };\n        this.element = coerceElement(element);\n        this._document = _document;\n        this.withScrollableParents([this.element]);\n        _dragDropRegistry.registerDropContainer(this);\n        this._parentPositions = new ParentPositionTracker(_document);\n        this._sortStrategy = new SingleAxisSortStrategy(this.element, _dragDropRegistry);\n        this._sortStrategy.withSortPredicate((index, item) => this.sortPredicate(index, item, this));\n    }\n    /** Removes the drop list functionality from the DOM element. */\n    dispose() {\n        this._stopScrolling();\n        this._stopScrollTimers.complete();\n        this._viewportScrollSubscription.unsubscribe();\n        this.beforeStarted.complete();\n        this.entered.complete();\n        this.exited.complete();\n        this.dropped.complete();\n        this.sorted.complete();\n        this._activeSiblings.clear();\n        this._scrollNode = null;\n        this._parentPositions.clear();\n        this._dragDropRegistry.removeDropContainer(this);\n    }\n    /** Whether an item from this list is currently being dragged. */\n    isDragging() {\n        return this._isDragging;\n    }\n    /** Starts dragging an item. */\n    start() {\n        this._draggingStarted();\n        this._notifyReceivingSiblings();\n    }\n    /**\n     * Attempts to move an item into the container.\n     * @param item Item that was moved into the container.\n     * @param pointerX Position of the item along the X axis.\n     * @param pointerY Position of the item along the Y axis.\n     * @param index Index at which the item entered. If omitted, the container will try to figure it\n     *   out automatically.\n     */\n    enter(item, pointerX, pointerY, index) {\n        this._draggingStarted();\n        // If sorting is disabled, we want the item to return to its starting\n        // position if the user is returning it to its initial container.\n        if (index == null && this.sortingDisabled) {\n            index = this._draggables.indexOf(item);\n        }\n        this._sortStrategy.enter(item, pointerX, pointerY, index);\n        // Note that this usually happens inside `_draggingStarted` as well, but the dimensions\n        // can change when the sort strategy moves the item around inside `enter`.\n        this._cacheParentPositions();\n        // Notify siblings at the end so that the item has been inserted into the `activeDraggables`.\n        this._notifyReceivingSiblings();\n        this.entered.next({ item, container: this, currentIndex: this.getItemIndex(item) });\n    }\n    /**\n     * Removes an item from the container after it was dragged into another container by the user.\n     * @param item Item that was dragged out.\n     */\n    exit(item) {\n        this._reset();\n        this.exited.next({ item, container: this });\n    }\n    /**\n     * Drops an item into this container.\n     * @param item Item being dropped into the container.\n     * @param currentIndex Index at which the item should be inserted.\n     * @param previousIndex Index of the item when dragging started.\n     * @param previousContainer Container from which the item got dragged in.\n     * @param isPointerOverContainer Whether the user's pointer was over the\n     *    container when the item was dropped.\n     * @param distance Distance the user has dragged since the start of the dragging sequence.\n     * @param event Event that triggered the dropping sequence.\n     *\n     * @breaking-change 15.0.0 `previousIndex` and `event` parameters to become required.\n     */\n    drop(item, currentIndex, previousIndex, previousContainer, isPointerOverContainer, distance, dropPoint, event = {}) {\n        this._reset();\n        this.dropped.next({\n            item,\n            currentIndex,\n            previousIndex,\n            container: this,\n            previousContainer,\n            isPointerOverContainer,\n            distance,\n            dropPoint,\n            event,\n        });\n    }\n    /**\n     * Sets the draggable items that are a part of this list.\n     * @param items Items that are a part of this list.\n     */\n    withItems(items) {\n        const previousItems = this._draggables;\n        this._draggables = items;\n        items.forEach(item => item._withDropContainer(this));\n        if (this.isDragging()) {\n            const draggedItems = previousItems.filter(item => item.isDragging());\n            // If all of the items being dragged were removed\n            // from the list, abort the current drag sequence.\n            if (draggedItems.every(item => items.indexOf(item) === -1)) {\n                this._reset();\n            }\n            else {\n                this._sortStrategy.withItems(this._draggables);\n            }\n        }\n        return this;\n    }\n    /** Sets the layout direction of the drop list. */\n    withDirection(direction) {\n        this._sortStrategy.direction = direction;\n        return this;\n    }\n    /**\n     * Sets the containers that are connected to this one. When two or more containers are\n     * connected, the user will be allowed to transfer items between them.\n     * @param connectedTo Other containers that the current containers should be connected to.\n     */\n    connectedTo(connectedTo) {\n        this._siblings = connectedTo.slice();\n        return this;\n    }\n    /**\n     * Sets the orientation of the container.\n     * @param orientation New orientation for the container.\n     */\n    withOrientation(orientation) {\n        // TODO(crisbeto): eventually we should be constructing the new sort strategy here based on\n        // the new orientation. For now we can assume that it'll always be `SingleAxisSortStrategy`.\n        this._sortStrategy.orientation = orientation;\n        return this;\n    }\n    /**\n     * Sets which parent elements are can be scrolled while the user is dragging.\n     * @param elements Elements that can be scrolled.\n     */\n    withScrollableParents(elements) {\n        const element = coerceElement(this.element);\n        // We always allow the current element to be scrollable\n        // so we need to ensure that it's in the array.\n        this._scrollableElements =\n            elements.indexOf(element) === -1 ? [element, ...elements] : elements.slice();\n        return this;\n    }\n    /** Gets the scrollable parents that are registered with this drop container. */\n    getScrollableParents() {\n        return this._scrollableElements;\n    }\n    /**\n     * Figures out the index of an item in the container.\n     * @param item Item whose index should be determined.\n     */\n    getItemIndex(item) {\n        return this._isDragging\n            ? this._sortStrategy.getItemIndex(item)\n            : this._draggables.indexOf(item);\n    }\n    /**\n     * Whether the list is able to receive the item that\n     * is currently being dragged inside a connected drop list.\n     */\n    isReceiving() {\n        return this._activeSiblings.size > 0;\n    }\n    /**\n     * Sorts an item inside the container based on its position.\n     * @param item Item to be sorted.\n     * @param pointerX Position of the item along the X axis.\n     * @param pointerY Position of the item along the Y axis.\n     * @param pointerDelta Direction in which the pointer is moving along each axis.\n     */\n    _sortItem(item, pointerX, pointerY, pointerDelta) {\n        // Don't sort the item if sorting is disabled or it's out of range.\n        if (this.sortingDisabled ||\n            !this._clientRect ||\n            !isPointerNearClientRect(this._clientRect, DROP_PROXIMITY_THRESHOLD, pointerX, pointerY)) {\n            return;\n        }\n        const result = this._sortStrategy.sort(item, pointerX, pointerY, pointerDelta);\n        if (result) {\n            this.sorted.next({\n                previousIndex: result.previousIndex,\n                currentIndex: result.currentIndex,\n                container: this,\n                item,\n            });\n        }\n    }\n    /**\n     * Checks whether the user's pointer is close to the edges of either the\n     * viewport or the drop list and starts the auto-scroll sequence.\n     * @param pointerX User's pointer position along the x axis.\n     * @param pointerY User's pointer position along the y axis.\n     */\n    _startScrollingIfNecessary(pointerX, pointerY) {\n        if (this.autoScrollDisabled) {\n            return;\n        }\n        let scrollNode;\n        let verticalScrollDirection = 0 /* AutoScrollVerticalDirection.NONE */;\n        let horizontalScrollDirection = 0 /* AutoScrollHorizontalDirection.NONE */;\n        // Check whether we should start scrolling any of the parent containers.\n        this._parentPositions.positions.forEach((position, element) => {\n            // We have special handling for the `document` below. Also this would be\n            // nicer with a  for...of loop, but it requires changing a compiler flag.\n            if (element === this._document || !position.clientRect || scrollNode) {\n                return;\n            }\n            if (isPointerNearClientRect(position.clientRect, DROP_PROXIMITY_THRESHOLD, pointerX, pointerY)) {\n                [verticalScrollDirection, horizontalScrollDirection] = getElementScrollDirections(element, position.clientRect, pointerX, pointerY);\n                if (verticalScrollDirection || horizontalScrollDirection) {\n                    scrollNode = element;\n                }\n            }\n        });\n        // Otherwise check if we can start scrolling the viewport.\n        if (!verticalScrollDirection && !horizontalScrollDirection) {\n            const { width, height } = this._viewportRuler.getViewportSize();\n            const clientRect = {\n                width,\n                height,\n                top: 0,\n                right: width,\n                bottom: height,\n                left: 0,\n            };\n            verticalScrollDirection = getVerticalScrollDirection(clientRect, pointerY);\n            horizontalScrollDirection = getHorizontalScrollDirection(clientRect, pointerX);\n            scrollNode = window;\n        }\n        if (scrollNode &&\n            (verticalScrollDirection !== this._verticalScrollDirection ||\n                horizontalScrollDirection !== this._horizontalScrollDirection ||\n                scrollNode !== this._scrollNode)) {\n            this._verticalScrollDirection = verticalScrollDirection;\n            this._horizontalScrollDirection = horizontalScrollDirection;\n            this._scrollNode = scrollNode;\n            if ((verticalScrollDirection || horizontalScrollDirection) && scrollNode) {\n                this._ngZone.runOutsideAngular(this._startScrollInterval);\n            }\n            else {\n                this._stopScrolling();\n            }\n        }\n    }\n    /** Stops any currently-running auto-scroll sequences. */\n    _stopScrolling() {\n        this._stopScrollTimers.next();\n    }\n    /** Starts the dragging sequence within the list. */\n    _draggingStarted() {\n        const styles = coerceElement(this.element).style;\n        this.beforeStarted.next();\n        this._isDragging = true;\n        // We need to disable scroll snapping while the user is dragging, because it breaks automatic\n        // scrolling. The browser seems to round the value based on the snapping points which means\n        // that we can't increment/decrement the scroll position.\n        this._initialScrollSnap = styles.msScrollSnapType || styles.scrollSnapType || '';\n        styles.scrollSnapType = styles.msScrollSnapType = 'none';\n        this._sortStrategy.start(this._draggables);\n        this._cacheParentPositions();\n        this._viewportScrollSubscription.unsubscribe();\n        this._listenToScrollEvents();\n    }\n    /** Caches the positions of the configured scrollable parents. */\n    _cacheParentPositions() {\n        const element = coerceElement(this.element);\n        this._parentPositions.cache(this._scrollableElements);\n        // The list element is always in the `scrollableElements`\n        // so we can take advantage of the cached `ClientRect`.\n        this._clientRect = this._parentPositions.positions.get(element).clientRect;\n    }\n    /** Resets the container to its initial state. */\n    _reset() {\n        this._isDragging = false;\n        const styles = coerceElement(this.element).style;\n        styles.scrollSnapType = styles.msScrollSnapType = this._initialScrollSnap;\n        this._siblings.forEach(sibling => sibling._stopReceiving(this));\n        this._sortStrategy.reset();\n        this._stopScrolling();\n        this._viewportScrollSubscription.unsubscribe();\n        this._parentPositions.clear();\n    }\n    /**\n     * Checks whether the user's pointer is positioned over the container.\n     * @param x Pointer position along the X axis.\n     * @param y Pointer position along the Y axis.\n     */\n    _isOverContainer(x, y) {\n        return this._clientRect != null && isInsideClientRect(this._clientRect, x, y);\n    }\n    /**\n     * Figures out whether an item should be moved into a sibling\n     * drop container, based on its current position.\n     * @param item Drag item that is being moved.\n     * @param x Position of the item along the X axis.\n     * @param y Position of the item along the Y axis.\n     */\n    _getSiblingContainerFromPosition(item, x, y) {\n        return this._siblings.find(sibling => sibling._canReceive(item, x, y));\n    }\n    /**\n     * Checks whether the drop list can receive the passed-in item.\n     * @param item Item that is being dragged into the list.\n     * @param x Position of the item along the X axis.\n     * @param y Position of the item along the Y axis.\n     */\n    _canReceive(item, x, y) {\n        if (!this._clientRect ||\n            !isInsideClientRect(this._clientRect, x, y) ||\n            !this.enterPredicate(item, this)) {\n            return false;\n        }\n        const elementFromPoint = this._getShadowRoot().elementFromPoint(x, y);\n        // If there's no element at the pointer position, then\n        // the client rect is probably scrolled out of the view.\n        if (!elementFromPoint) {\n            return false;\n        }\n        const nativeElement = coerceElement(this.element);\n        // The `ClientRect`, that we're using to find the container over which the user is\n        // hovering, doesn't give us any information on whether the element has been scrolled\n        // out of the view or whether it's overlapping with other containers. This means that\n        // we could end up transferring the item into a container that's invisible or is positioned\n        // below another one. We use the result from `elementFromPoint` to get the top-most element\n        // at the pointer position and to find whether it's one of the intersecting drop containers.\n        return elementFromPoint === nativeElement || nativeElement.contains(elementFromPoint);\n    }\n    /**\n     * Called by one of the connected drop lists when a dragging sequence has started.\n     * @param sibling Sibling in which dragging has started.\n     */\n    _startReceiving(sibling, items) {\n        const activeSiblings = this._activeSiblings;\n        if (!activeSiblings.has(sibling) &&\n            items.every(item => {\n                // Note that we have to add an exception to the `enterPredicate` for items that started off\n                // in this drop list. The drag ref has logic that allows an item to return to its initial\n                // container, if it has left the initial container and none of the connected containers\n                // allow it to enter. See `DragRef._updateActiveDropContainer` for more context.\n                return this.enterPredicate(item, this) || this._draggables.indexOf(item) > -1;\n            })) {\n            activeSiblings.add(sibling);\n            this._cacheParentPositions();\n            this._listenToScrollEvents();\n        }\n    }\n    /**\n     * Called by a connected drop list when dragging has stopped.\n     * @param sibling Sibling whose dragging has stopped.\n     */\n    _stopReceiving(sibling) {\n        this._activeSiblings.delete(sibling);\n        this._viewportScrollSubscription.unsubscribe();\n    }\n    /**\n     * Starts listening to scroll events on the viewport.\n     * Used for updating the internal state of the list.\n     */\n    _listenToScrollEvents() {\n        this._viewportScrollSubscription = this._dragDropRegistry\n            .scrolled(this._getShadowRoot())\n            .subscribe(event => {\n            if (this.isDragging()) {\n                const scrollDifference = this._parentPositions.handleScroll(event);\n                if (scrollDifference) {\n                    this._sortStrategy.updateOnScroll(scrollDifference.top, scrollDifference.left);\n                }\n            }\n            else if (this.isReceiving()) {\n                this._cacheParentPositions();\n            }\n        });\n    }\n    /**\n     * Lazily resolves and returns the shadow root of the element. We do this in a function, rather\n     * than saving it in property directly on init, because we want to resolve it as late as possible\n     * in order to ensure that the element has been moved into the shadow DOM. Doing it inside the\n     * constructor might be too early if the element is inside of something like `ngFor` or `ngIf`.\n     */\n    _getShadowRoot() {\n        if (!this._cachedShadowRoot) {\n            const shadowRoot = _getShadowRoot(coerceElement(this.element));\n            this._cachedShadowRoot = (shadowRoot || this._document);\n        }\n        return this._cachedShadowRoot;\n    }\n    /** Notifies any siblings that may potentially receive the item. */\n    _notifyReceivingSiblings() {\n        const draggedItems = this._sortStrategy\n            .getActiveItemsSnapshot()\n            .filter(item => item.isDragging());\n        this._siblings.forEach(sibling => sibling._startReceiving(this, draggedItems));\n    }\n}\n/**\n * Gets whether the vertical auto-scroll direction of a node.\n * @param clientRect Dimensions of the node.\n * @param pointerY Position of the user's pointer along the y axis.\n */\nfunction getVerticalScrollDirection(clientRect, pointerY) {\n    const { top, bottom, height } = clientRect;\n    const yThreshold = height * SCROLL_PROXIMITY_THRESHOLD;\n    if (pointerY >= top - yThreshold && pointerY <= top + yThreshold) {\n        return 1 /* AutoScrollVerticalDirection.UP */;\n    }\n    else if (pointerY >= bottom - yThreshold && pointerY <= bottom + yThreshold) {\n        return 2 /* AutoScrollVerticalDirection.DOWN */;\n    }\n    return 0 /* AutoScrollVerticalDirection.NONE */;\n}\n/**\n * Gets whether the horizontal auto-scroll direction of a node.\n * @param clientRect Dimensions of the node.\n * @param pointerX Position of the user's pointer along the x axis.\n */\nfunction getHorizontalScrollDirection(clientRect, pointerX) {\n    const { left, right, width } = clientRect;\n    const xThreshold = width * SCROLL_PROXIMITY_THRESHOLD;\n    if (pointerX >= left - xThreshold && pointerX <= left + xThreshold) {\n        return 1 /* AutoScrollHorizontalDirection.LEFT */;\n    }\n    else if (pointerX >= right - xThreshold && pointerX <= right + xThreshold) {\n        return 2 /* AutoScrollHorizontalDirection.RIGHT */;\n    }\n    return 0 /* AutoScrollHorizontalDirection.NONE */;\n}\n/**\n * Gets the directions in which an element node should be scrolled,\n * assuming that the user's pointer is already within it scrollable region.\n * @param element Element for which we should calculate the scroll direction.\n * @param clientRect Bounding client rectangle of the element.\n * @param pointerX Position of the user's pointer along the x axis.\n * @param pointerY Position of the user's pointer along the y axis.\n */\nfunction getElementScrollDirections(element, clientRect, pointerX, pointerY) {\n    const computedVertical = getVerticalScrollDirection(clientRect, pointerY);\n    const computedHorizontal = getHorizontalScrollDirection(clientRect, pointerX);\n    let verticalScrollDirection = 0 /* AutoScrollVerticalDirection.NONE */;\n    let horizontalScrollDirection = 0 /* AutoScrollHorizontalDirection.NONE */;\n    // Note that we here we do some extra checks for whether the element is actually scrollable in\n    // a certain direction and we only assign the scroll direction if it is. We do this so that we\n    // can allow other elements to be scrolled, if the current element can't be scrolled anymore.\n    // This allows us to handle cases where the scroll regions of two scrollable elements overlap.\n    if (computedVertical) {\n        const scrollTop = element.scrollTop;\n        if (computedVertical === 1 /* AutoScrollVerticalDirection.UP */) {\n            if (scrollTop > 0) {\n                verticalScrollDirection = 1 /* AutoScrollVerticalDirection.UP */;\n            }\n        }\n        else if (element.scrollHeight - scrollTop > element.clientHeight) {\n            verticalScrollDirection = 2 /* AutoScrollVerticalDirection.DOWN */;\n        }\n    }\n    if (computedHorizontal) {\n        const scrollLeft = element.scrollLeft;\n        if (computedHorizontal === 1 /* AutoScrollHorizontalDirection.LEFT */) {\n            if (scrollLeft > 0) {\n                horizontalScrollDirection = 1 /* AutoScrollHorizontalDirection.LEFT */;\n            }\n        }\n        else if (element.scrollWidth - scrollLeft > element.clientWidth) {\n            horizontalScrollDirection = 2 /* AutoScrollHorizontalDirection.RIGHT */;\n        }\n    }\n    return [verticalScrollDirection, horizontalScrollDirection];\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Event options that can be used to bind an active, capturing event. */\nconst activeCapturingEventOptions = normalizePassiveListenerOptions({\n    passive: false,\n    capture: true,\n});\n/**\n * Service that keeps track of all the drag item and drop container\n * instances, and manages global event listeners on the `document`.\n * @docs-private\n */\n// Note: this class is generic, rather than referencing CdkDrag and CdkDropList directly, in order\n// to avoid circular imports. If we were to reference them here, importing the registry into the\n// classes that are registering themselves will introduce a circular import.\nclass DragDropRegistry {\n    constructor(_ngZone, _document) {\n        this._ngZone = _ngZone;\n        /** Registered drop container instances. */\n        this._dropInstances = new Set();\n        /** Registered drag item instances. */\n        this._dragInstances = new Set();\n        /** Drag item instances that are currently being dragged. */\n        this._activeDragInstances = [];\n        /** Keeps track of the event listeners that we've bound to the `document`. */\n        this._globalListeners = new Map();\n        /**\n         * Predicate function to check if an item is being dragged.  Moved out into a property,\n         * because it'll be called a lot and we don't want to create a new function every time.\n         */\n        this._draggingPredicate = (item) => item.isDragging();\n        /**\n         * Emits the `touchmove` or `mousemove` events that are dispatched\n         * while the user is dragging a drag item instance.\n         */\n        this.pointerMove = new Subject();\n        /**\n         * Emits the `touchend` or `mouseup` events that are dispatched\n         * while the user is dragging a drag item instance.\n         */\n        this.pointerUp = new Subject();\n        /**\n         * Emits when the viewport has been scrolled while the user is dragging an item.\n         * @deprecated To be turned into a private member. Use the `scrolled` method instead.\n         * @breaking-change 13.0.0\n         */\n        this.scroll = new Subject();\n        /**\n         * Event listener that will prevent the default browser action while the user is dragging.\n         * @param event Event whose default action should be prevented.\n         */\n        this._preventDefaultWhileDragging = (event) => {\n            if (this._activeDragInstances.length > 0) {\n                event.preventDefault();\n            }\n        };\n        /** Event listener for `touchmove` that is bound even if no dragging is happening. */\n        this._persistentTouchmoveListener = (event) => {\n            if (this._activeDragInstances.length > 0) {\n                // Note that we only want to prevent the default action after dragging has actually started.\n                // Usually this is the same time at which the item is added to the `_activeDragInstances`,\n                // but it could be pushed back if the user has set up a drag delay or threshold.\n                if (this._activeDragInstances.some(this._draggingPredicate)) {\n                    event.preventDefault();\n                }\n                this.pointerMove.next(event);\n            }\n        };\n        this._document = _document;\n    }\n    /** Adds a drop container to the registry. */\n    registerDropContainer(drop) {\n        if (!this._dropInstances.has(drop)) {\n            this._dropInstances.add(drop);\n        }\n    }\n    /** Adds a drag item instance to the registry. */\n    registerDragItem(drag) {\n        this._dragInstances.add(drag);\n        // The `touchmove` event gets bound once, ahead of time, because WebKit\n        // won't preventDefault on a dynamically-added `touchmove` listener.\n        // See https://bugs.webkit.org/show_bug.cgi?id=184250.\n        if (this._dragInstances.size === 1) {\n            this._ngZone.runOutsideAngular(() => {\n                // The event handler has to be explicitly active,\n                // because newer browsers make it passive by default.\n                this._document.addEventListener('touchmove', this._persistentTouchmoveListener, activeCapturingEventOptions);\n            });\n        }\n    }\n    /** Removes a drop container from the registry. */\n    removeDropContainer(drop) {\n        this._dropInstances.delete(drop);\n    }\n    /** Removes a drag item instance from the registry. */\n    removeDragItem(drag) {\n        this._dragInstances.delete(drag);\n        this.stopDragging(drag);\n        if (this._dragInstances.size === 0) {\n            this._document.removeEventListener('touchmove', this._persistentTouchmoveListener, activeCapturingEventOptions);\n        }\n    }\n    /**\n     * Starts the dragging sequence for a drag instance.\n     * @param drag Drag instance which is being dragged.\n     * @param event Event that initiated the dragging.\n     */\n    startDragging(drag, event) {\n        // Do not process the same drag twice to avoid memory leaks and redundant listeners\n        if (this._activeDragInstances.indexOf(drag) > -1) {\n            return;\n        }\n        this._activeDragInstances.push(drag);\n        if (this._activeDragInstances.length === 1) {\n            const isTouchEvent = event.type.startsWith('touch');\n            // We explicitly bind __active__ listeners here, because newer browsers will default to\n            // passive ones for `mousemove` and `touchmove`. The events need to be active, because we\n            // use `preventDefault` to prevent the page from scrolling while the user is dragging.\n            this._globalListeners\n                .set(isTouchEvent ? 'touchend' : 'mouseup', {\n                handler: (e) => this.pointerUp.next(e),\n                options: true,\n            })\n                .set('scroll', {\n                handler: (e) => this.scroll.next(e),\n                // Use capturing so that we pick up scroll changes in any scrollable nodes that aren't\n                // the document. See https://github.com/angular/components/issues/17144.\n                options: true,\n            })\n                // Preventing the default action on `mousemove` isn't enough to disable text selection\n                // on Safari so we need to prevent the selection event as well. Alternatively this can\n                // be done by setting `user-select: none` on the `body`, however it has causes a style\n                // recalculation which can be expensive on pages with a lot of elements.\n                .set('selectstart', {\n                handler: this._preventDefaultWhileDragging,\n                options: activeCapturingEventOptions,\n            });\n            // We don't have to bind a move event for touch drag sequences, because\n            // we already have a persistent global one bound from `registerDragItem`.\n            if (!isTouchEvent) {\n                this._globalListeners.set('mousemove', {\n                    handler: (e) => this.pointerMove.next(e),\n                    options: activeCapturingEventOptions,\n                });\n            }\n            this._ngZone.runOutsideAngular(() => {\n                this._globalListeners.forEach((config, name) => {\n                    this._document.addEventListener(name, config.handler, config.options);\n                });\n            });\n        }\n    }\n    /** Stops dragging a drag item instance. */\n    stopDragging(drag) {\n        const index = this._activeDragInstances.indexOf(drag);\n        if (index > -1) {\n            this._activeDragInstances.splice(index, 1);\n            if (this._activeDragInstances.length === 0) {\n                this._clearGlobalListeners();\n            }\n        }\n    }\n    /** Gets whether a drag item instance is currently being dragged. */\n    isDragging(drag) {\n        return this._activeDragInstances.indexOf(drag) > -1;\n    }\n    /**\n     * Gets a stream that will emit when any element on the page is scrolled while an item is being\n     * dragged.\n     * @param shadowRoot Optional shadow root that the current dragging sequence started from.\n     *   Top-level listeners won't pick up events coming from the shadow DOM so this parameter can\n     *   be used to include an additional top-level listener at the shadow root level.\n     */\n    scrolled(shadowRoot) {\n        const streams = [this.scroll];\n        if (shadowRoot && shadowRoot !== this._document) {\n            // Note that this is basically the same as `fromEvent` from rxjs, but we do it ourselves,\n            // because we want to guarantee that the event is bound outside of the `NgZone`. With\n            // `fromEvent` it'll only happen if the subscription is outside the `NgZone`.\n            streams.push(new Observable((observer) => {\n                return this._ngZone.runOutsideAngular(() => {\n                    const eventOptions = true;\n                    const callback = (event) => {\n                        if (this._activeDragInstances.length) {\n                            observer.next(event);\n                        }\n                    };\n                    shadowRoot.addEventListener('scroll', callback, eventOptions);\n                    return () => {\n                        shadowRoot.removeEventListener('scroll', callback, eventOptions);\n                    };\n                });\n            }));\n        }\n        return merge(...streams);\n    }\n    ngOnDestroy() {\n        this._dragInstances.forEach(instance => this.removeDragItem(instance));\n        this._dropInstances.forEach(instance => this.removeDropContainer(instance));\n        this._clearGlobalListeners();\n        this.pointerMove.complete();\n        this.pointerUp.complete();\n    }\n    /** Clears out the global event listeners from the `document`. */\n    _clearGlobalListeners() {\n        this._globalListeners.forEach((config, name) => {\n            this._document.removeEventListener(name, config.handler, config.options);\n        });\n        this._globalListeners.clear();\n    }\n}\nDragDropRegistry.fac = i0.ngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.2.0\", ngImport: i0, type: DragDropRegistry, deps: [{ token: i0.NgZone }, { token: DOCUMENT }], target: i0.FactoryTarget.Injectable });\nDragDropRegistry.prov = i0.ngDeclareInjectable({ minVersion: \"12.0.0\", version: \"14.2.0\", ngImport: i0, type: DragDropRegistry, providedIn: 'root' });\ni0.ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.2.0\", ngImport: i0, type: DragDropRegistry, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: function () { return [{ type: i0.NgZone }, { type: undefined, decorators: [{\n                    type: Inject,\n                    args: [DOCUMENT]\n                }] }]; } });\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Default configuration to be used when creating a `DragRef`. */\nconst DEFAULT_CONFIG = {\n    dragStartThreshold: 5,\n    pointerDirectionChangeThreshold: 5,\n};\n/**\n * Service that allows for drag-and-drop functionality to be attached to DOM elements.\n */\nclass DragDrop {\n    constructor(_document, _ngZone, _viewportRuler, _dragDropRegistry) {\n        this._document = _document;\n        this._ngZone = _ngZone;\n        this._viewportRuler = _viewportRuler;\n        this._dragDropRegistry = _dragDropRegistry;\n    }\n    /**\n     * Turns an element into a draggable item.\n     * @param element Element to which to attach the dragging functionality.\n     * @param config Object used to configure the dragging behavior.\n     */\n    createDrag(element, config = DEFAULT_CONFIG) {\n        return new DragRef(element, config, this._document, this._ngZone, this._viewportRuler, this._dragDropRegistry);\n    }\n    /**\n     * Turns an element into a drop list.\n     * @param element Element to which to attach the drop list functionality.\n     */\n    createDropList(element) {\n        return new DropListRef(element, this._dragDropRegistry, this._document, this._ngZone, this._viewportRuler);\n    }\n}\nDragDrop.fac = i0.ngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.2.0\", ngImport: i0, type: DragDrop, deps: [{ token: DOCUMENT }, { token: i0.NgZone }, { token: i1.ViewportRuler }, { token: DragDropRegistry }], target: i0.FactoryTarget.Injectable });\nDragDrop.prov = i0.ngDeclareInjectable({ minVersion: \"12.0.0\", version: \"14.2.0\", ngImport: i0, type: DragDrop, providedIn: 'root' });\ni0.ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.2.0\", ngImport: i0, type: DragDrop, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: function () { return [{ type: undefined, decorators: [{\n                    type: Inject,\n                    args: [DOCUMENT]\n                }] }, { type: i0.NgZone }, { type: i1.ViewportRuler }, { type: DragDropRegistry }]; } });\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Injection token that can be used for a `CdkDrag` to provide itself as a parent to the\n * drag-specific child directive (`CdkDragHandle`, `CdkDragPreview` etc.). Used primarily\n * to avoid circular imports.\n * @docs-private\n */\nconst CDK_DRAG_PARENT = new InjectionToken('CDK_DRAG_PARENT');\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Injection token that can be used to reference instances of `CdkDropListGroup`. It serves as\n * alternative token to the actual `CdkDropListGroup` class which could cause unnecessary\n * retention of the class and its directive metadata.\n */\nconst CDK_DROP_LIST_GROUP = new InjectionToken('CdkDropListGroup');\n/**\n * Declaratively connects sibling `cdkDropList` instances together. All of the `cdkDropList`\n * elements that are placed inside a `cdkDropListGroup` will be connected to each other\n * automatically. Can be used as an alternative to the `cdkDropListConnectedTo` input\n * from `cdkDropList`.\n */\nclass CdkDropListGroup {\n    constructor() {\n        /** Drop lists registered inside the group. */\n        this._items = new Set();\n        this._disabled = false;\n    }\n    /** Whether starting a dragging sequence from inside this group is disabled. */\n    get disabled() {\n        return this._disabled;\n    }\n    set disabled(value) {\n        this._disabled = coerceBooleanProperty(value);\n    }\n    ngOnDestroy() {\n        this._items.clear();\n    }\n}\nCdkDropListGroup.fac = i0.ngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.2.0\", ngImport: i0, type: CdkDropListGroup, deps: [], target: i0.FactoryTarget.Directive });\nCdkDropListGroup.dir = i0.ngDeclareDirective({ minVersion: \"14.0.0\", version: \"14.2.0\", type: CdkDropListGroup, selector: \"[cdkDropListGroup]\", inputs: { disabled: [\"cdkDropListGroupDisabled\", \"disabled\"] }, providers: [{ provide: CDK_DROP_LIST_GROUP, useExisting: CdkDropListGroup }], exportAs: [\"cdkDropListGroup\"], ngImport: i0 });\ni0.ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.2.0\", ngImport: i0, type: CdkDropListGroup, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[cdkDropListGroup]',\n                    exportAs: 'cdkDropListGroup',\n                    providers: [{ provide: CDK_DROP_LIST_GROUP, useExisting: CdkDropListGroup }],\n                }]\n        }], propDecorators: { disabled: [{\n                type: Input,\n                args: ['cdkDropListGroupDisabled']\n            }] } });\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Injection token that can be used to configure the\n * behavior of the drag&drop-related components.\n */\nconst CDK_DRAG_CONFIG = new InjectionToken('CDK_DRAG_CONFIG');\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Asserts that a particular node is an element.\n * @param node Node to be checked.\n * @param name Name to attach to the error message.\n */\nfunction assertElementNode(node, name) {\n    if (node.nodeType !== 1) {\n        throw Error(`${name} must be attached to an element node. ` + `Currently attached to \"${node.nodeName}\".`);\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Counter used to generate unique ids for drop zones. */\nlet _uniqueIdCounter = 0;\n/**\n * Injection token that can be used to reference instances of `CdkDropList`. It serves as\n * alternative token to the actual `CdkDropList` class which could cause unnecessary\n * retention of the class and its directive metadata.\n */\nconst CDK_DROP_LIST = new InjectionToken('CdkDropList');\n/** Container that wraps a set of draggable items. */\nclass CdkDropList {\n    constructor(\n    /** Element that the drop list is attached to. */\n    element, dragDrop, _changeDetectorRef, _scrollDispatcher, _dir, _group, config) {\n        this.element = element;\n        this._changeDetectorRef = _changeDetectorRef;\n        this._scrollDispatcher = _scrollDispatcher;\n        this._dir = _dir;\n        this._group = _group;\n        /** Emits when the list has been destroyed. */\n        this._destroyed = new Subject();\n        /**\n         * Other draggable containers that this container is connected to and into which the\n         * container's items can be transferred. Can either be references to other drop containers,\n         * or their unique IDs.\n         */\n        this.connectedTo = [];\n        /**\n         * Unique ID for the drop zone. Can be used as a reference\n         * in the `connectedTo` of another `CdkDropList`.\n         */\n        this.id = `cdk-drop-list-${_uniqueIdCounter++}`;\n        /**\n         * Function that is used to determine whether an item\n         * is allowed to be moved into a drop container.\n         */\n        this.enterPredicate = () => true;\n        /** Functions that is used to determine whether an item can be sorted into a particular index. */\n        this.sortPredicate = () => true;\n        /** Emits when the user drops an item inside the container. */\n        this.dropped = new EventEmitter();\n        /**\n         * Emits when the user has moved a new drag item into this container.\n         */\n        this.entered = new EventEmitter();\n        /**\n         * Emits when the user removes an item from the container\n         * by dragging it into another container.\n         */\n        this.exited = new EventEmitter();\n        /** Emits as the user is swapping items while actively dragging. */\n        this.sorted = new EventEmitter();\n        /**\n         * Keeps track of the items that are registered with this container. Historically we used to\n         * do this with a `ContentChildren` query, however queries don't handle transplanted views very\n         * well which means that we can't handle cases like dragging the headers of a `mat-table`\n         * correctly. What we do instead is to have the items register themselves with the container\n         * and then we sort them based on their position in the DOM.\n         */\n        this._unsortedItems = new Set();\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n            assertElementNode(element.nativeElement, 'cdkDropList');\n        }\n        this._dropListRef = dragDrop.createDropList(element);\n        this._dropListRef.data = this;\n        if (config) {\n            this._assignDefaults(config);\n        }\n        this._dropListRef.enterPredicate = (drag, drop) => {\n            return this.enterPredicate(drag.data, drop.data);\n        };\n        this._dropListRef.sortPredicate = (index, drag, drop) => {\n            return this.sortPredicate(index, drag.data, drop.data);\n        };\n        this._setupInputSyncSubscription(this._dropListRef);\n        this._handleEvents(this._dropListRef);\n        CdkDropList._dropLists.push(this);\n        if (_group) {\n            _group._items.add(this);\n        }\n    }\n    /** Whether starting a dragging sequence from this container is disabled. */\n    get disabled() {\n        return this._disabled || (!!this._group && this._group.disabled);\n    }\n    set disabled(value) {\n        // Usually we sync the directive and ref state right before dragging starts, in order to have\n        // a single point of failure and to avoid having to use setters for everything. `disabled` is\n        // a special case, because it can prevent the `beforeStarted` event from firing, which can lock\n        // the user in a disabled state, so we also need to sync it as it's being set.\n        this._dropListRef.disabled = this._disabled = coerceBooleanProperty(value);\n    }\n    /** Registers an items with the drop list. */\n    addItem(item) {\n        this._unsortedItems.add(item);\n        if (this._dropListRef.isDragging()) {\n            this._syncItemsWithRef();\n        }\n    }\n    /** Removes an item from the drop list. */\n    removeItem(item) {\n        this._unsortedItems.delete(item);\n        if (this._dropListRef.isDragging()) {\n            this._syncItemsWithRef();\n        }\n    }\n    /** Gets the registered items in the list, sorted by their position in the DOM. */\n    getSortedItems() {\n        return Array.from(this._unsortedItems).sort((a, b) => {\n            const documentPosition = a._dragRef\n                .getVisibleElement()\n                .compareDocumentPosition(b._dragRef.getVisibleElement());\n            // `compareDocumentPosition` returns a bitmask so we have to use a bitwise operator.\n            // https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition\n            // tslint:disable-next-line:no-bitwise\n            return documentPosition & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : 1;\n        });\n    }\n    ngOnDestroy() {\n        const index = CdkDropList._dropLists.indexOf(this);\n        if (index > -1) {\n            CdkDropList._dropLists.splice(index, 1);\n        }\n        if (this._group) {\n            this._group._items.delete(this);\n        }\n        this._unsortedItems.clear();\n        this._dropListRef.dispose();\n        this._destroyed.next();\n        this._destroyed.complete();\n    }\n    /** Syncs the inputs of the CdkDropList with the options of the underlying DropListRef. */\n    _setupInputSyncSubscription(ref) {\n        if (this._dir) {\n            this._dir.change\n                .pipe(startWith(this._dir.value), takeUntil(this._destroyed))\n                .subscribe(value => ref.withDirection(value));\n        }\n        ref.beforeStarted.subscribe(() => {\n            const siblings = coerceArray(this.connectedTo).map(drop => {\n                if (typeof drop === 'string') {\n                    const correspondingDropList = CdkDropList._dropLists.find(list => list.id === drop);\n                    if (!correspondingDropList && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n                        console.warn(`CdkDropList could not find connected drop list with id \"${drop}\"`);\n                    }\n                    return correspondingDropList;\n                }\n                return drop;\n            });\n            if (this._group) {\n                this._group._items.forEach(drop => {\n                    if (siblings.indexOf(drop) === -1) {\n                        siblings.push(drop);\n                    }\n                });\n            }\n            // Note that we resolve the scrollable parents here so that we delay the resolution\n            // as long as possible, ensuring that the element is in its final place in the DOM.\n            if (!this._scrollableParentsResolved) {\n                const scrollableParents = this._scrollDispatcher\n                    .getAncestorScrollContainers(this.element)\n                    .map(scrollable => scrollable.getElementRef().nativeElement);\n                this._dropListRef.withScrollableParents(scrollableParents);\n                // Only do this once since it involves traversing the DOM and the parents\n                // shouldn't be able to change without the drop list being destroyed.\n                this._scrollableParentsResolved = true;\n            }\n            ref.disabled = this.disabled;\n            ref.lockAxis = this.lockAxis;\n            ref.sortingDisabled = coerceBooleanProperty(this.sortingDisabled);\n            ref.autoScrollDisabled = coerceBooleanProperty(this.autoScrollDisabled);\n            ref.autoScrollStep = coerceNumberProperty(this.autoScrollStep, 2);\n            ref\n                .connectedTo(siblings.filter(drop => drop && drop !== this).map(list => list._dropListRef))\n                .withOrientation(this.orientation);\n        });\n    }\n    /** Handles events from the underlying DropListRef. */\n    _handleEvents(ref) {\n        ref.beforeStarted.subscribe(() => {\n            this._syncItemsWithRef();\n            this._changeDetectorRef.markForCheck();\n        });\n        ref.entered.subscribe(event => {\n            this.entered.emit({\n                container: this,\n                item: event.item.data,\n                currentIndex: event.currentIndex,\n            });\n        });\n        ref.exited.subscribe(event => {\n            this.exited.emit({\n                container: this,\n                item: event.item.data,\n            });\n            this._changeDetectorRef.markForCheck();\n        });\n        ref.sorted.subscribe(event => {\n            this.sorted.emit({\n                previousIndex: event.previousIndex,\n                currentIndex: event.currentIndex,\n                container: this,\n                item: event.item.data,\n            });\n        });\n        ref.dropped.subscribe(dropEvent => {\n            this.dropped.emit({\n                previousIndex: dropEvent.previousIndex,\n                currentIndex: dropEvent.currentIndex,\n                previousContainer: dropEvent.previousContainer.data,\n                container: dropEvent.container.data,\n                item: dropEvent.item.data,\n                isPointerOverContainer: dropEvent.isPointerOverContainer,\n                distance: dropEvent.distance,\n                dropPoint: dropEvent.dropPoint,\n                event: dropEvent.event,\n            });\n            // Mark for check since all of these events run outside of change\n            // detection and we're not guaranteed for something else to have triggered it.\n            this._changeDetectorRef.markForCheck();\n        });\n    }\n    /** Assigns the default input values based on a provided config object. */\n    _assignDefaults(config) {\n        const { lockAxis, draggingDisabled, sortingDisabled, listAutoScrollDisabled, listOrientation } = config;\n        this.disabled = draggingDisabled == null ? false : draggingDisabled;\n        this.sortingDisabled = sortingDisabled == null ? false : sortingDisabled;\n        this.autoScrollDisabled = listAutoScrollDisabled == null ? false : listAutoScrollDisabled;\n        this.orientation = listOrientation || 'vertical';\n        if (lockAxis) {\n            this.lockAxis = lockAxis;\n        }\n    }\n    /** Syncs up the registered drag items with underlying drop list ref. */\n    _syncItemsWithRef() {\n        this._dropListRef.withItems(this.getSortedItems().map(item => item._dragRef));\n    }\n}\n/** Keeps track of the drop lists that are currently on the page. */\nCdkDropList._dropLists = [];\nCdkDropList.fac = i0.ngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.2.0\", ngImport: i0, type: CdkDropList, deps: [{ token: i0.ElementRef }, { token: DragDrop }, { token: i0.ChangeDetectorRef }, { token: i1.ScrollDispatcher }, { token: i3.Directionality, optional: true }, { token: CDK_DROP_LIST_GROUP, optional: true, skipSelf: true }, { token: CDK_DRAG_CONFIG, optional: true }], target: i0.FactoryTarget.Directive });\nCdkDropList.dir = i0.ngDeclareDirective({ minVersion: \"14.0.0\", version: \"14.2.0\", type: CdkDropList, selector: \"[cdkDropList], cdk-drop-list\", inputs: { connectedTo: [\"cdkDropListConnectedTo\", \"connectedTo\"], data: [\"cdkDropListData\", \"data\"], orientation: [\"cdkDropListOrientation\", \"orientation\"], id: \"id\", lockAxis: [\"cdkDropListLockAxis\", \"lockAxis\"], disabled: [\"cdkDropListDisabled\", \"disabled\"], sortingDisabled: [\"cdkDropListSortingDisabled\", \"sortingDisabled\"], enterPredicate: [\"cdkDropListEnterPredicate\", \"enterPredicate\"], sortPredicate: [\"cdkDropListSortPredicate\", \"sortPredicate\"], autoScrollDisabled: [\"cdkDropListAutoScrollDisabled\", \"autoScrollDisabled\"], autoScrollStep: [\"cdkDropListAutoScrollStep\", \"autoScrollStep\"] }, outputs: { dropped: \"cdkDropListDropped\", entered: \"cdkDropListEntered\", exited: \"cdkDropListExited\", sorted: \"cdkDropListSorted\" }, host: { properties: { \"attr.id\": \"id\", \"class.cdk-drop-list-disabled\": \"disabled\", \"class.cdk-drop-list-dragging\": \"_dropListRef.isDragging()\", \"class.cdk-drop-list-receiving\": \"_dropListRef.isReceiving()\" }, classAttribute: \"cdk-drop-list\" }, providers: [\n        // Prevent child drop lists from picking up the same group as their parent.\n        { provide: CDK_DROP_LIST_GROUP, useValue: undefined },\n        { provide: CDK_DROP_LIST, useExisting: CdkDropList },\n    ], exportAs: [\"cdkDropList\"], ngImport: i0 });\ni0.ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.2.0\", ngImport: i0, type: CdkDropList, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[cdkDropList], cdk-drop-list',\n                    exportAs: 'cdkDropList',\n                    providers: [\n                        // Prevent child drop lists from picking up the same group as their parent.\n                        { provide: CDK_DROP_LIST_GROUP, useValue: undefined },\n                        { provide: CDK_DROP_LIST, useExisting: CdkDropList },\n                    ],\n                    host: {\n                        'class': 'cdk-drop-list',\n                        '[attr.id]': 'id',\n                        '[class.cdk-drop-list-disabled]': 'disabled',\n                        '[class.cdk-drop-list-dragging]': '_dropListRef.isDragging()',\n                        '[class.cdk-drop-list-receiving]': '_dropListRef.isReceiving()',\n                    },\n                }]\n        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: DragDrop }, { type: i0.ChangeDetectorRef }, { type: i1.ScrollDispatcher }, { type: i3.Directionality, decorators: [{\n                    type: Optional\n                }] }, { type: CdkDropListGroup, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [CDK_DROP_LIST_GROUP]\n                }, {\n                    type: SkipSelf\n                }] }, { type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [CDK_DRAG_CONFIG]\n                }] }]; }, propDecorators: { connectedTo: [{\n                type: Input,\n                args: ['cdkDropListConnectedTo']\n            }], data: [{\n                type: Input,\n                args: ['cdkDropListData']\n            }], orientation: [{\n                type: Input,\n                args: ['cdkDropListOrientation']\n            }], id: [{\n                type: Input\n            }], lockAxis: [{\n                type: Input,\n                args: ['cdkDropListLockAxis']\n            }], disabled: [{\n                type: Input,\n                args: ['cdkDropListDisabled']\n            }], sortingDisabled: [{\n                type: Input,\n                args: ['cdkDropListSortingDisabled']\n            }], enterPredicate: [{\n                type: Input,\n                args: ['cdkDropListEnterPredicate']\n            }], sortPredicate: [{\n                type: Input,\n                args: ['cdkDropListSortPredicate']\n            }], autoScrollDisabled: [{\n                type: Input,\n                args: ['cdkDropListAutoScrollDisabled']\n            }], autoScrollStep: [{\n                type: Input,\n                args: ['cdkDropListAutoScrollStep']\n            }], dropped: [{\n                type: Output,\n                args: ['cdkDropListDropped']\n            }], entered: [{\n                type: Output,\n                args: ['cdkDropListEntered']\n            }], exited: [{\n                type: Output,\n                args: ['cdkDropListExited']\n            }], sorted: [{\n                type: Output,\n                args: ['cdkDropListSorted']\n            }] } });\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Injection token that can be used to reference instances of `CdkDragHandle`. It serves as\n * alternative token to the actual `CdkDragHandle` class which could cause unnecessary\n * retention of the class and its directive metadata.\n */\nconst CDK_DRAG_HANDLE = new InjectionToken('CdkDragHandle');\n/** Handle that can be used to drag a CdkDrag instance. */\nclass CdkDragHandle {\n    constructor(element, parentDrag) {\n        this.element = element;\n        /** Emits when the state of the handle has changed. */\n        this._stateChanges = new Subject();\n        this._disabled = false;\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n            assertElementNode(element.nativeElement, 'cdkDragHandle');\n        }\n        this._parentDrag = parentDrag;\n    }\n    /** Whether starting to drag through this handle is disabled. */\n    get disabled() {\n        return this._disabled;\n    }\n    set disabled(value) {\n        this._disabled = coerceBooleanProperty(value);\n        this._stateChanges.next(this);\n    }\n    ngOnDestroy() {\n        this._stateChanges.complete();\n    }\n}\nCdkDragHandle.fac = i0.ngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.2.0\", ngImport: i0, type: CdkDragHandle, deps: [{ token: i0.ElementRef }, { token: CDK_DRAG_PARENT, optional: true, skipSelf: true }], target: i0.FactoryTarget.Directive });\nCdkDragHandle.dir = i0.ngDeclareDirective({ minVersion: \"14.0.0\", version: \"14.2.0\", type: CdkDragHandle, selector: \"[cdkDragHandle]\", inputs: { disabled: [\"cdkDragHandleDisabled\", \"disabled\"] }, host: { classAttribute: \"cdk-drag-handle\" }, providers: [{ provide: CDK_DRAG_HANDLE, useExisting: CdkDragHandle }], ngImport: i0 });\ni0.ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.2.0\", ngImport: i0, type: CdkDragHandle, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[cdkDragHandle]',\n                    host: {\n                        'class': 'cdk-drag-handle',\n                    },\n                    providers: [{ provide: CDK_DRAG_HANDLE, useExisting: CdkDragHandle }],\n                }]\n        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: undefined, decorators: [{\n                    type: Inject,\n                    args: [CDK_DRAG_PARENT]\n                }, {\n                    type: Optional\n                }, {\n                    type: SkipSelf\n                }] }]; }, propDecorators: { disabled: [{\n                type: Input,\n                args: ['cdkDragHandleDisabled']\n            }] } });\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Injection token that can be used to reference instances of `CdkDragPlaceholder`. It serves as\n * alternative token to the actual `CdkDragPlaceholder` class which could cause unnecessary\n * retention of the class and its directive metadata.\n */\nconst CDK_DRAG_PLACEHOLDER = new InjectionToken('CdkDragPlaceholder');\n/**\n * Element that will be used as a template for the placeholder of a CdkDrag when\n * it is being dragged. The placeholder is displayed in place of the element being dragged.\n */\nclass CdkDragPlaceholder {\n    constructor(templateRef) {\n        this.templateRef = templateRef;\n    }\n}\nCdkDragPlaceholder.fac = i0.ngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.2.0\", ngImport: i0, type: CdkDragPlaceholder, deps: [{ token: i0.TemplateRef }], target: i0.FactoryTarget.Directive });\nCdkDragPlaceholder.dir = i0.ngDeclareDirective({ minVersion: \"14.0.0\", version: \"14.2.0\", type: CdkDragPlaceholder, selector: \"ng-template[cdkDragPlaceholder]\", inputs: { data: \"data\" }, providers: [{ provide: CDK_DRAG_PLACEHOLDER, useExisting: CdkDragPlaceholder }], ngImport: i0 });\ni0.ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.2.0\", ngImport: i0, type: CdkDragPlaceholder, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: 'ng-template[cdkDragPlaceholder]',\n                    providers: [{ provide: CDK_DRAG_PLACEHOLDER, useExisting: CdkDragPlaceholder }],\n                }]\n        }], ctorParameters: function () { return [{ type: i0.TemplateRef }]; }, propDecorators: { data: [{\n                type: Input\n            }] } });\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Injection token that can be used to reference instances of `CdkDragPreview`. It serves as\n * alternative token to the actual `CdkDragPreview` class which could cause unnecessary\n * retention of the class and its directive metadata.\n */\nconst CDK_DRAG_PREVIEW = new InjectionToken('CdkDragPreview');\n/**\n * Element that will be used as a template for the preview\n * of a CdkDrag when it is being dragged.\n */\nclass CdkDragPreview {\n    constructor(templateRef) {\n        this.templateRef = templateRef;\n        this._matchSize = false;\n    }\n    /** Whether the preview should preserve the same size as the item that is being dragged. */\n    get matchSize() {\n        return this._matchSize;\n    }\n    set matchSize(value) {\n        this._matchSize = coerceBooleanProperty(value);\n    }\n}\nCdkDragPreview.fac = i0.ngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.2.0\", ngImport: i0, type: CdkDragPreview, deps: [{ token: i0.TemplateRef }], target: i0.FactoryTarget.Directive });\nCdkDragPreview.dir = i0.ngDeclareDirective({ minVersion: \"14.0.0\", version: \"14.2.0\", type: CdkDragPreview, selector: \"ng-template[cdkDragPreview]\", inputs: { data: \"data\", matchSize: \"matchSize\" }, providers: [{ provide: CDK_DRAG_PREVIEW, useExisting: CdkDragPreview }], ngImport: i0 });\ni0.ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.2.0\", ngImport: i0, type: CdkDragPreview, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: 'ng-template[cdkDragPreview]',\n                    providers: [{ provide: CDK_DRAG_PREVIEW, useExisting: CdkDragPreview }],\n                }]\n        }], ctorParameters: function () { return [{ type: i0.TemplateRef }]; }, propDecorators: { data: [{\n                type: Input\n            }], matchSize: [{\n                type: Input\n            }] } });\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst DRAG_HOST_CLASS = 'cdk-drag';\n/** Element that can be moved inside a CdkDropList container. */\nclass CdkDrag {\n    constructor(\n    /** Element that the draggable is attached to. */\n    element, \n    /** Droppable container that the draggable is a part of. */\n    dropContainer, \n    /**\n     * @deprecated `_document` parameter no longer being used and will be removed.\n     * @breaking-change 12.0.0\n     */\n    _document, _ngZone, _viewContainerRef, config, _dir, dragDrop, _changeDetectorRef, _selfHandle, _parentDrag) {\n        this.element = element;\n        this.dropContainer = dropContainer;\n        this._ngZone = _ngZone;\n        this._viewContainerRef = _viewContainerRef;\n        this._dir = _dir;\n        this._changeDetectorRef = _changeDetectorRef;\n        this._selfHandle = _selfHandle;\n        this._parentDrag = _parentDrag;\n        this._destroyed = new Subject();\n        /** Emits when the user starts dragging the item. */\n        this.started = new EventEmitter();\n        /** Emits when the user has released a drag item, before any animations have started. */\n        this.released = new EventEmitter();\n        /** Emits when the user stops dragging an item in the container. */\n        this.ended = new EventEmitter();\n        /** Emits when the user has moved the item into a new container. */\n        this.entered = new EventEmitter();\n        /** Emits when the user removes the item its container by dragging it into another container. */\n        this.exited = new EventEmitter();\n        /** Emits when the user drops the item inside a container. */\n        this.dropped = new EventEmitter();\n        /**\n         * Emits as the user is dragging the item. Use with caution,\n         * because this event will fire for every pixel that the user has dragged.\n         */\n        this.moved = new Observable((observer) => {\n            const subscription = this._dragRef.moved\n                .pipe(map(movedEvent => ({\n                source: this,\n                pointerPosition: movedEvent.pointerPosition,\n                event: movedEvent.event,\n                delta: movedEvent.delta,\n                distance: movedEvent.distance,\n            })))\n                .subscribe(observer);\n            return () => {\n                subscription.unsubscribe();\n            };\n        });\n        this._dragRef = dragDrop.createDrag(element, {\n            dragStartThreshold: config && config.dragStartThreshold != null ? config.dragStartThreshold : 5,\n            pointerDirectionChangeThreshold: config && config.pointerDirectionChangeThreshold != null\n                ? config.pointerDirectionChangeThreshold\n                : 5,\n            zIndex: config?.zIndex,\n        });\n        this._dragRef.data = this;\n        // We have to keep track of the drag instances in order to be able to match an element to\n        // a drag instance. We can't go through the global registry of `DragRef`, because the root\n        // element could be different.\n        CdkDrag._dragInstances.push(this);\n        if (config) {\n            this._assignDefaults(config);\n        }\n        // Note that usually the container is assigned when the drop list is picks up the item, but in\n        // some cases (mainly transplanted views with OnPush, see #18341) we may end up in a situation\n        // where there are no items on the first change detection pass, but the items get picked up as\n        // soon as the user triggers another pass by dragging. This is a problem, because the item would\n        // have to switch from standalone mode to drag mode in the middle of the dragging sequence which\n        // is too late since the two modes save different kinds of information. We work around it by\n        // assigning the drop container both from here and the list.\n        if (dropContainer) {\n            this._dragRef._withDropContainer(dropContainer._dropListRef);\n            dropContainer.addItem(this);\n        }\n        this._syncInputs(this._dragRef);\n        this._handleEvents(this._dragRef);\n    }\n    /** Whether starting to drag this element is disabled. */\n    get disabled() {\n        return this._disabled || (this.dropContainer && this.dropContainer.disabled);\n    }\n    set disabled(value) {\n        this._disabled = coerceBooleanProperty(value);\n        this._dragRef.disabled = this._disabled;\n    }\n    /**\n     * Returns the element that is being used as a placeholder\n     * while the current element is being dragged.\n     */\n    getPlaceholderElement() {\n        return this._dragRef.getPlaceholderElement();\n    }\n    /** Returns the root draggable element. */\n    getRootElement() {\n        return this._dragRef.getRootElement();\n    }\n    /** Resets a standalone drag item to its initial position. */\n    reset() {\n        this._dragRef.reset();\n    }\n    /**\n     * Gets the pixel coordinates of the draggable outside of a drop container.\n     */\n    getFreeDragPosition() {\n        return this._dragRef.getFreeDragPosition();\n    }\n    /**\n     * Sets the current position in pixels the draggable outside of a drop container.\n     * @param value New position to be set.\n     */\n    setFreeDragPosition(value) {\n        this._dragRef.setFreeDragPosition(value);\n    }\n    ngAfterViewInit() {\n        // Normally this isn't in the zone, but it can cause major performance regressions for apps\n        // using `zone-patch-rxjs` because it'll trigger a change detection when it unsubscribes.\n        this._ngZone.runOutsideAngular(() => {\n            // We need to wait for the zone to stabilize, in order for the reference\n            // element to be in the proper place in the DOM. This is mostly relevant\n            // for draggable elements inside portals since they get stamped out in\n            // their original DOM position and then they get transferred to the portal.\n            this._ngZone.onStable.pipe(take(1), takeUntil(this._destroyed)).subscribe(() => {\n                this._updateRootElement();\n                this._setupHandlesListener();\n                if (this.freeDragPosition) {\n                    this._dragRef.setFreeDragPosition(this.freeDragPosition);\n                }\n            });\n        });\n    }\n    ngOnChanges(changes) {\n        const rootSelectorChange = changes['rootElementSelector'];\n        const positionChange = changes['freeDragPosition'];\n        // We don't have to react to the first change since it's being\n        // handled in `ngAfterViewInit` where it needs to be deferred.\n        if (rootSelectorChange && !rootSelectorChange.firstChange) {\n            this._updateRootElement();\n        }\n        // Skip the first change since it's being handled in `ngAfterViewInit`.\n        if (positionChange && !positionChange.firstChange && this.freeDragPosition) {\n            this._dragRef.setFreeDragPosition(this.freeDragPosition);\n        }\n    }\n    ngOnDestroy() {\n        if (this.dropContainer) {\n            this.dropContainer.removeItem(this);\n        }\n        const index = CdkDrag._dragInstances.indexOf(this);\n        if (index > -1) {\n            CdkDrag._dragInstances.splice(index, 1);\n        }\n        // Unnecessary in most cases, but used to avoid extra change detections with `zone-paths-rxjs`.\n        this._ngZone.runOutsideAngular(() => {\n            this._destroyed.next();\n            this._destroyed.complete();\n            this._dragRef.dispose();\n        });\n    }\n    /** Syncs the root element with the `DragRef`. */\n    _updateRootElement() {\n        const element = this.element.nativeElement;\n        let rootElement = element;\n        if (this.rootElementSelector) {\n            rootElement =\n                element.closest !== undefined\n                    ? element.closest(this.rootElementSelector)\n                    : // Comment tag doesn't have closest method, so use parent's one.\n                        element.parentElement?.closest(this.rootElementSelector);\n        }\n        if (rootElement && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n            assertElementNode(rootElement, 'cdkDrag');\n        }\n        this._dragRef.withRootElement(rootElement || element);\n    }\n    /** Gets the boundary element, based on the `boundaryElement` value. */\n    _getBoundaryElement() {\n        const boundary = this.boundaryElement;\n        if (!boundary) {\n            return null;\n        }\n        if (typeof boundary === 'string') {\n            return this.element.nativeElement.closest(boundary);\n        }\n        return coerceElement(boundary);\n    }\n    /** Syncs the inputs of the CdkDrag with the options of the underlying DragRef. */\n    _syncInputs(ref) {\n        ref.beforeStarted.subscribe(() => {\n            if (!ref.isDragging()) {\n                const dir = this._dir;\n                const dragStartDelay = this.dragStartDelay;\n                const placeholder = this._placeholderTemplate\n                    ? {\n                        template: this._placeholderTemplate.templateRef,\n                        context: this._placeholderTemplate.data,\n                        viewContainer: this._viewContainerRef,\n                    }\n                    : null;\n                const preview = this._previewTemplate\n                    ? {\n                        template: this._previewTemplate.templateRef,\n                        context: this._previewTemplate.data,\n                        matchSize: this._previewTemplate.matchSize,\n                        viewContainer: this._viewContainerRef,\n                    }\n                    : null;\n                ref.disabled = this.disabled;\n                ref.lockAxis = this.lockAxis;\n                ref.dragStartDelay =\n                    typeof dragStartDelay === 'object' && dragStartDelay\n                        ? dragStartDelay\n                        : coerceNumberProperty(dragStartDelay);\n                ref.constrainPosition = this.constrainPosition;\n                ref.previewClass = this.previewClass;\n                ref\n                    .withBoundaryElement(this._getBoundaryElement())\n                    .withPlaceholderTemplate(placeholder)\n                    .withPreviewTemplate(preview)\n                    .withPreviewContainer(this.previewContainer || 'global');\n                if (dir) {\n                    ref.withDirection(dir.value);\n                }\n            }\n        });\n        // This only needs to be resolved once.\n        ref.beforeStarted.pipe(take(1)).subscribe(() => {\n            // If we managed to resolve a parent through DI, use it.\n            if (this._parentDrag) {\n                ref.withParent(this._parentDrag._dragRef);\n                return;\n            }\n            // Otherwise fall back to resolving the parent by looking up the DOM. This can happen if\n            // the item was projected into another item by something like `ngTemplateOutlet`.\n            let parent = this.element.nativeElement.parentElement;\n            while (parent) {\n                if (parent.classList.contains(DRAG_HOST_CLASS)) {\n                    ref.withParent(CdkDrag._dragInstances.find(drag => {\n                        return drag.element.nativeElement === parent;\n                    })?._dragRef || null);\n                    break;\n                }\n                parent = parent.parentElement;\n            }\n        });\n    }\n    /** Handles the events from the underlying `DragRef`. */\n    _handleEvents(ref) {\n        ref.started.subscribe(startEvent => {\n            this.started.emit({ source: this, event: startEvent.event });\n            // Since all of these events run outside of change detection,\n            // we need to ensure that everything is marked correctly.\n            this._changeDetectorRef.markForCheck();\n        });\n        ref.released.subscribe(releaseEvent => {\n            this.released.emit({ source: this, event: releaseEvent.event });\n        });\n        ref.ended.subscribe(endEvent => {\n            this.ended.emit({\n                source: this,\n                distance: endEvent.distance,\n                dropPoint: endEvent.dropPoint,\n                event: endEvent.event,\n            });\n            // Since all of these events run outside of change detection,\n            // we need to ensure that everything is marked correctly.\n            this._changeDetectorRef.markForCheck();\n        });\n        ref.entered.subscribe(enterEvent => {\n            this.entered.emit({\n                container: enterEvent.container.data,\n                item: this,\n                currentIndex: enterEvent.currentIndex,\n            });\n        });\n        ref.exited.subscribe(exitEvent => {\n            this.exited.emit({\n                container: exitEvent.container.data,\n                item: this,\n            });\n        });\n        ref.dropped.subscribe(dropEvent => {\n            this.dropped.emit({\n                previousIndex: dropEvent.previousIndex,\n                currentIndex: dropEvent.currentIndex,\n                previousContainer: dropEvent.previousContainer.data,\n                container: dropEvent.container.data,\n                isPointerOverContainer: dropEvent.isPointerOverContainer,\n                item: this,\n                distance: dropEvent.distance,\n                dropPoint: dropEvent.dropPoint,\n                event: dropEvent.event,\n            });\n        });\n    }\n    /** Assigns the default input values based on a provided config object. */\n    _assignDefaults(config) {\n        const { lockAxis, dragStartDelay, constrainPosition, previewClass, boundaryElement, draggingDisabled, rootElementSelector, previewContainer, } = config;\n        this.disabled = draggingDisabled == null ? false : draggingDisabled;\n        this.dragStartDelay = dragStartDelay || 0;\n        if (lockAxis) {\n            this.lockAxis = lockAxis;\n        }\n        if (constrainPosition) {\n            this.constrainPosition = constrainPosition;\n        }\n        if (previewClass) {\n            this.previewClass = previewClass;\n        }\n        if (boundaryElement) {\n            this.boundaryElement = boundaryElement;\n        }\n        if (rootElementSelector) {\n            this.rootElementSelector = rootElementSelector;\n        }\n        if (previewContainer) {\n            this.previewContainer = previewContainer;\n        }\n    }\n    /** Sets up the listener that syncs the handles with the drag ref. */\n    _setupHandlesListener() {\n        // Listen for any newly-added handles.\n        this._handles.changes\n            .pipe(startWith(this._handles), \n        // Sync the new handles with the DragRef.\n        tap((handles) => {\n            const childHandleElements = handles\n                .filter(handle => handle._parentDrag === this)\n                .map(handle => handle.element);\n            // Usually handles are only allowed to be a descendant of the drag element, but if\n            // the consumer defined a different drag root, we should allow the drag element\n            // itself to be a handle too.\n            if (this._selfHandle && this.rootElementSelector) {\n                childHandleElements.push(this.element);\n            }\n            this._dragRef.withHandles(childHandleElements);\n        }), \n        // Listen if the state of any of the handles changes.\n        switchMap((handles) => {\n            return merge(...handles.map(item => {\n                return item._stateChanges.pipe(startWith(item));\n            }));\n        }), takeUntil(this._destroyed))\n            .subscribe(handleInstance => {\n            // Enabled/disable the handle that changed in the DragRef.\n            const dragRef = this._dragRef;\n            const handle = handleInstance.element.nativeElement;\n            handleInstance.disabled ? dragRef.disableHandle(handle) : dragRef.enableHandle(handle);\n        });\n    }\n}\nCdkDrag._dragInstances = [];\nCdkDrag.fac = i0.ngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.2.0\", ngImport: i0, type: CdkDrag, deps: [{ token: i0.ElementRef }, { token: CDK_DROP_LIST, optional: true, skipSelf: true }, { token: DOCUMENT }, { token: i0.NgZone }, { token: i0.ViewContainerRef }, { token: CDK_DRAG_CONFIG, optional: true }, { token: i3.Directionality, optional: true }, { token: DragDrop }, { token: i0.ChangeDetectorRef }, { token: CDK_DRAG_HANDLE, optional: true, self: true }, { token: CDK_DRAG_PARENT, optional: true, skipSelf: true }], target: i0.FactoryTarget.Directive });\nCdkDrag.dir = i0.ngDeclareDirective({ minVersion: \"14.0.0\", version: \"14.2.0\", type: CdkDrag, selector: \"[cdkDrag]\", inputs: { data: [\"cdkDragData\", \"data\"], lockAxis: [\"cdkDragLockAxis\", \"lockAxis\"], rootElementSelector: [\"cdkDragRootElement\", \"rootElementSelector\"], boundaryElement: [\"cdkDragBoundary\", \"boundaryElement\"], dragStartDelay: [\"cdkDragStartDelay\", \"dragStartDelay\"], freeDragPosition: [\"cdkDragFreeDragPosition\", \"freeDragPosition\"], disabled: [\"cdkDragDisabled\", \"disabled\"], constrainPosition: [\"cdkDragConstrainPosition\", \"constrainPosition\"], previewClass: [\"cdkDragPreviewClass\", \"previewClass\"], previewContainer: [\"cdkDragPreviewContainer\", \"previewContainer\"] }, outputs: { started: \"cdkDragStarted\", released: \"cdkDragReleased\", ended: \"cdkDragEnded\", entered: \"cdkDragEntered\", exited: \"cdkDragExited\", dropped: \"cdkDragDropped\", moved: \"cdkDragMoved\" }, host: { properties: { \"class.cdk-drag-disabled\": \"disabled\", \"class.cdk-drag-dragging\": \"_dragRef.isDragging()\" }, classAttribute: \"cdk-drag\" }, providers: [{ provide: CDK_DRAG_PARENT, useExisting: CdkDrag }], queries: [{ propertyName: \"_previewTemplate\", first: true, predicate: CDK_DRAG_PREVIEW, descendants: true }, { propertyName: \"_placeholderTemplate\", first: true, predicate: CDK_DRAG_PLACEHOLDER, descendants: true }, { propertyName: \"_handles\", predicate: CDK_DRAG_HANDLE, descendants: true }], exportAs: [\"cdkDrag\"], usesOnChanges: true, ngImport: i0 });\ni0.ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.2.0\", ngImport: i0, type: CdkDrag, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[cdkDrag]',\n                    exportAs: 'cdkDrag',\n                    host: {\n                        'class': DRAG_HOST_CLASS,\n                        '[class.cdk-drag-disabled]': 'disabled',\n                        '[class.cdk-drag-dragging]': '_dragRef.isDragging()',\n                    },\n                    providers: [{ provide: CDK_DRAG_PARENT, useExisting: CdkDrag }],\n                }]\n        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: undefined, decorators: [{\n                    type: Inject,\n                    args: [CDK_DROP_LIST]\n                }, {\n                    type: Optional\n                }, {\n                    type: SkipSelf\n                }] }, { type: undefined, decorators: [{\n                    type: Inject,\n                    args: [DOCUMENT]\n                }] }, { type: i0.NgZone }, { type: i0.ViewContainerRef }, { type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [CDK_DRAG_CONFIG]\n                }] }, { type: i3.Directionality, decorators: [{\n                    type: Optional\n                }] }, { type: DragDrop }, { type: i0.ChangeDetectorRef }, { type: CdkDragHandle, decorators: [{\n                    type: Optional\n                }, {\n                    type: Self\n                }, {\n                    type: Inject,\n                    args: [CDK_DRAG_HANDLE]\n                }] }, { type: CdkDrag, decorators: [{\n                    type: Optional\n                }, {\n                    type: SkipSelf\n                }, {\n                    type: Inject,\n                    args: [CDK_DRAG_PARENT]\n                }] }]; }, propDecorators: { _handles: [{\n                type: ContentChildren,\n                args: [CDK_DRAG_HANDLE, { descendants: true }]\n            }], _previewTemplate: [{\n                type: ContentChild,\n                args: [CDK_DRAG_PREVIEW]\n            }], _placeholderTemplate: [{\n                type: ContentChild,\n                args: [CDK_DRAG_PLACEHOLDER]\n            }], data: [{\n                type: Input,\n                args: ['cdkDragData']\n            }], lockAxis: [{\n                type: Input,\n                args: ['cdkDragLockAxis']\n            }], rootElementSelector: [{\n                type: Input,\n                args: ['cdkDragRootElement']\n            }], boundaryElement: [{\n                type: Input,\n                args: ['cdkDragBoundary']\n            }], dragStartDelay: [{\n                type: Input,\n                args: ['cdkDragStartDelay']\n            }], freeDragPosition: [{\n                type: Input,\n                args: ['cdkDragFreeDragPosition']\n            }], disabled: [{\n                type: Input,\n                args: ['cdkDragDisabled']\n            }], constrainPosition: [{\n                type: Input,\n                args: ['cdkDragConstrainPosition']\n            }], previewClass: [{\n                type: Input,\n                args: ['cdkDragPreviewClass']\n            }], previewContainer: [{\n                type: Input,\n                args: ['cdkDragPreviewContainer']\n            }], started: [{\n                type: Output,\n                args: ['cdkDragStarted']\n            }], released: [{\n                type: Output,\n                args: ['cdkDragReleased']\n            }], ended: [{\n                type: Output,\n                args: ['cdkDragEnded']\n            }], entered: [{\n                type: Output,\n                args: ['cdkDragEntered']\n            }], exited: [{\n                type: Output,\n                args: ['cdkDragExited']\n            }], dropped: [{\n                type: Output,\n                args: ['cdkDragDropped']\n            }], moved: [{\n                type: Output,\n                args: ['cdkDragMoved']\n            }] } });\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nclass DragDropModule {\n}\nDragDropModule.fac = i0.ngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.2.0\", ngImport: i0, type: DragDropModule, deps: [], target: i0.FactoryTarget.NgModule });\nDragDropModule.mod = i0.ngDeclareNgModule({ minVersion: \"14.0.0\", version: \"14.2.0\", ngImport: i0, type: DragDropModule, declarations: [CdkDropList,\n        CdkDropListGroup,\n        CdkDrag,\n        CdkDragHandle,\n        CdkDragPreview,\n        CdkDragPlaceholder], exports: [CdkScrollableModule,\n        CdkDropList,\n        CdkDropListGroup,\n        CdkDrag,\n        CdkDragHandle,\n        CdkDragPreview,\n        CdkDragPlaceholder] });\nDragDropModule.inj = i0.ngDeclareInjector({ minVersion: \"12.0.0\", version: \"14.2.0\", ngImport: i0, type: DragDropModule, providers: [DragDrop], imports: [CdkScrollableModule] });\ni0.ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.2.0\", ngImport: i0, type: DragDropModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    declarations: [\n                        CdkDropList,\n                        CdkDropListGroup,\n                        CdkDrag,\n                        CdkDragHandle,\n                        CdkDragPreview,\n                        CdkDragPlaceholder,\n                    ],\n                    exports: [\n                        CdkScrollableModule,\n                        CdkDropList,\n                        CdkDropListGroup,\n                        CdkDrag,\n                        CdkDragHandle,\n                        CdkDragPreview,\n                        CdkDragPlaceholder,\n                    ],\n                    providers: [DragDrop],\n                }]\n        }] });\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { CDK_DRAG_CONFIG, CDK_DRAG_HANDLE, CDK_DRAG_PARENT, CDK_DRAG_PLACEHOLDER, CDK_DRAG_PREVIEW, CDK_DROP_LIST, CDK_DROP_LIST_GROUP, CdkDrag, CdkDragHandle, CdkDragPlaceholder, CdkDragPreview, CdkDropList, CdkDropListGroup, DragDrop, DragDropModule, DragDropRegistry, DragRef, DropListRef, copyArrayItem, moveItemInArray, transferArrayItem };\n","import { asyncScheduler } from '../scheduler/async';\nimport { timer } from './timer';\nexport function interval(period = 0, scheduler = asyncScheduler) {\n    if (period < 0) {\n        period = 0;\n    }\n    return timer(period, period, scheduler);\n}\n","<div class=\"multilevelselection-holder\">\n  <mat-checkbox\n    color=\"primary\"\n    checkboxPosition=\"before\"\n    [(ngModel)]=\"isAllSelected\"\n    (change)=\"toggleSelectAll()\"\n    class=\"multilevelselection__checkbox\"\n    [data-qa]=\"'select_all'\"\n  >\n    {{ 'nav.select_all' | translate }}\n  </mat-checkbox>\n\n  <mat-tree [dataSource]=\"dataSource\" [treeControl]=\"treeControl\" class=\"multilevelselection\">\n    <mat-tree-node *matTreeNodeDef=\"let option\" class=\"multilevelselection__option\">\n      <mat-checkbox\n        color=\"primary\"\n        [value]=\"option[fields[0]]\"\n        checkboxPosition=\"before\"\n        (click)=\"$event.stopPropagation()\"\n        class=\"multilevelselection__checkbox\"\n        (change)=\"categoryLeafSelectionToggle(option)\"\n        [checked]=\"checklistSelection.isSelected(option)\"\n        [data-qa]=\"'tag-' + option[fields[1]] | lowercase\"\n      >\n        {{ option[fields[1]] | translate }}\n      </mat-checkbox>\n    </mat-tree-node>\n    <mat-tree-node\n      (click)=\"$event.stopPropagation()\"\n      class=\"multilevelselection__option\"\n      *matTreeNodeDef=\"let option; when: hasChild\"\n    >\n      <mat-checkbox\n        color=\"primary\"\n        checkboxPosition=\"before\"\n        [value]=\"option[fields[0]]\"\n        (click)=\"$event.stopPropagation()\"\n        class=\"multilevelselection__checkbox\"\n        [checked]=\"descendantsHasSelected(option)\"\n        (change)=\"categorySelectionToggle(option)\"\n        [data-qa]=\"'tag-' + option[fields[1]] | lowercase\"\n      >\n        {{ option[fields[1]] | translate }}\n      </mat-checkbox>\n      <mzima-client-button\n        fill=\"clear\"\n        color=\"secondary\"\n        [iconOnly]=\"true\"\n        matTreeNodeToggle\n        class=\"multilevelselection__option__arrow\"\n        [ariaLabel]=\"'Toggle ' + option[fields[1]] | translate\"\n        [ngClass]=\"{\n          'multilevelselection__option__arrow--open': treeControl.isExpanded(option)\n        }\"\n        [data-qa]=\"'btn-tag-toggle-' + option[fields[1]] | lowercase\"\n      >\n        <mat-icon icon svgIcon=\"arrow-down\"></mat-icon>\n      </mzima-client-button>\n    </mat-tree-node>\n  </mat-tree>\n</div>\n","import { SelectionModel } from '@angular/cdk/collections';\nimport { FlatTreeControl } from '@angular/cdk/tree';\nimport { Component, forwardRef, Input, OnChanges, SimpleChanges } from '@angular/core';\nimport { ControlValueAccessor, NG_VALUE_ACCESSOR } from '@angular/forms';\nimport { MatTreeFlatDataSource, MatTreeFlattener } from '@angular/material/tree';\n\nexport interface MultilevelSelectionOption {\n  name: string;\n  id: number | string;\n  children?: Omit<MultilevelSelectionOption, 'children'>[];\n}\n\ninterface CategoryFlatNode {\n  expandable: boolean;\n  name: string;\n  id: string | number;\n  level: number;\n}\n\n@Component({\n  selector: 'app-multilevel-selection',\n  templateUrl: './multilevel-selection.component.html',\n  styleUrls: ['./multilevel-selection.component.scss'],\n  providers: [\n    {\n      provide: NG_VALUE_ACCESSOR,\n      multi: true,\n      useExisting: forwardRef(() => MultilevelSelectionComponent),\n    },\n  ],\n})\nexport class MultilevelSelectionComponent implements ControlValueAccessor, OnChanges {\n  @Input() public data: any[];\n  @Input() public fields: string[] = ['id', 'name'];\n  public value: any;\n  public touched = false;\n  public disabled = false;\n  public isAllSelected = false;\n  public checklistSelection = new SelectionModel<CategoryFlatNode>(true);\n\n  ngOnChanges(changes: SimpleChanges): void {\n    if (changes['data']?.currentValue) {\n      setTimeout(() => {\n        this.dataSource = new MatTreeFlatDataSource(\n          this.treeControl,\n          this.treeFlattener,\n          changes['data'].currentValue || [],\n        );\n      }, 10);\n    }\n  }\n\n  private _transformer = (node: any, level: number) => {\n    return {\n      expandable: !!node.children && node.children.length > 0,\n      name: node.name,\n      id: node.id,\n      level: level,\n    };\n  };\n\n  public treeControl = new FlatTreeControl<CategoryFlatNode>(\n    (node) => node.level,\n    (node) => node.expandable,\n  );\n\n  private treeFlattener = new MatTreeFlattener(\n    this._transformer,\n    (node) => node.level,\n    (node) => node.expandable,\n    (node) => node.children,\n  );\n  public dataSource: any;\n\n  private onChange = (values: any) => {\n    console.log(values);\n  };\n  private onTouched = () => {};\n\n  public hasChild = (_: number, node: CategoryFlatNode) => node.expandable;\n\n  public valueChanged(): void {\n    this.markAsTouched();\n    this.onChange(this.value);\n  }\n\n  public writeValue(values: any[]) {\n    if (values) {\n      setTimeout(() => {\n        this.checklistSelection.deselect(...this.treeControl.dataNodes);\n        const nodes = this.treeControl.dataNodes.filter((node) =>\n          values.some((val: any) => val === node.id),\n        );\n        this.checklistSelection.select(...nodes);\n      }, 50);\n    } else {\n      this.value = [];\n    }\n  }\n\n  registerOnChange(onChange: any) {\n    this.onChange = onChange;\n  }\n\n  registerOnTouched(onTouched: any) {\n    this.onTouched = onTouched;\n  }\n\n  markAsTouched() {\n    if (!this.touched) {\n      this.onTouched();\n      this.touched = true;\n    }\n  }\n\n  public descendantsHasSelected(option: CategoryFlatNode): boolean {\n    const descendants = this.treeControl.getDescendants(option);\n    const descHasSelected =\n      descendants.length > 0 &&\n      !!descendants.find((child) => this.checklistSelection.isSelected(child));\n    return descHasSelected;\n  }\n\n  public categorySelectionToggle(node: CategoryFlatNode): void {\n    this.checklistSelection.toggle(node);\n    const descendants = this.treeControl.getDescendants(node);\n    this.checklistSelection.isSelected(node)\n      ? this.checklistSelection.select(...descendants)\n      : this.checklistSelection.deselect(...descendants);\n\n    descendants.forEach((child) => this.checklistSelection.isSelected(child));\n    this.checkAllParentsSelection(node);\n    this.checkAllSelection();\n    this.onChange(this.checklistSelection.selected.map((n) => n.id));\n  }\n\n  public categoryLeafSelectionToggle(option: CategoryFlatNode): void {\n    this.checklistSelection.toggle(option);\n    this.checkAllParentsSelection(option);\n    this.checkAllSelection();\n    this.onChange(this.checklistSelection.selected.map((node) => node.id));\n  }\n\n  private checkAllParentsSelection(option: CategoryFlatNode): void {\n    let parent: CategoryFlatNode | null = this.getParentNode(option);\n    while (parent) {\n      this.checkRootNodeSelection(parent);\n      parent = this.getParentNode(parent);\n    }\n  }\n\n  private getParentNode(option: CategoryFlatNode): CategoryFlatNode | null {\n    const currentLevel = this.getLevel(option);\n\n    if (currentLevel < 1) {\n      return null;\n    }\n\n    const startIndex = this.treeControl.dataNodes.indexOf(option) - 1;\n\n    for (let i = startIndex; i >= 0; i--) {\n      const currentNode = this.treeControl.dataNodes[i];\n\n      if (this.getLevel(currentNode) < currentLevel) {\n        return currentNode;\n      }\n    }\n    return null;\n  }\n\n  private getLevel = (option: CategoryFlatNode) => option.level;\n\n  private checkRootNodeSelection(option: CategoryFlatNode): void {\n    const descendants = this.treeControl.getDescendants(option);\n\n    const descHasSelected =\n      descendants.length > 0 &&\n      !!descendants.find((child) => this.checklistSelection.isSelected(child));\n\n    descHasSelected\n      ? this.checklistSelection.select(option)\n      : this.checklistSelection.deselect(option);\n  }\n\n  public toggleSelectAll(): void {\n    if (this.isAllSelected) {\n      this.checklistSelection.select(...this.treeControl.dataNodes);\n    } else {\n      this.checklistSelection.deselect(...this.treeControl.dataNodes);\n    }\n    this.onChange(this.checklistSelection.selected.map((node) => node.id));\n  }\n\n  private checkAllSelection(): void {\n    this.isAllSelected =\n      this.checklistSelection.selected.length === this.treeControl.dataNodes.length;\n  }\n}\n","<mzima-client-button\n  tabindex=\"-1\"\n  fill=\"outline\"\n  [iconOnly]=\"true\"\n  color=\"light-gray\"\n  [data-qa]=\"'btn-close'\"\n  class=\"modal__close-btn\"\n  [mat-dialog-close]=\"false\"\n  ariaLabel=\"{{ 'modal.button.close' | translate }}\"\n>\n  <mat-icon icon svgIcon=\"close\"></mat-icon>\n</mzima-client-button>\n\n<strong mat-dialog-title>{{\n  isTranslateMode ? ('form.translate_field' | translate) : ('form.add_field' | translate)\n}}</strong>\n<mat-dialog-content>\n  <ng-container *ngIf=\"selectedFieldType; else allFields\">\n    <ng-container *ngIf=\"!isTranslateMode; else translateMode\">\n      <div class=\"form-row\">\n        <mat-label>{{ 'app.name' | translate }}</mat-label>\n        <mat-form-field appearance=\"outline\">\n          <input\n            matInput\n            required\n            [(ngModel)]=\"selectedFieldType.label\"\n            placeholder=\"{{ 'form.field_name_placeholder' | translate }}\"\n            [data-qa]=\"'selected-field-name'\"\n          />\n        </mat-form-field>\n      </div>\n\n      <div class=\"form-row\">\n        <mat-label>{{ 'survey.show_field_description' | translate }} </mat-label>\n        <quill-editor\n          [(ngModel)]=\"selectedFieldType.instructions\"\n          placeholder=\"{{ 'app.insert_text_here' | translate }}\"\n          [data-qa]=\"'selected-field-description'\"\n        ></quill-editor>\n      </div>\n\n      <!-- Has options -->\n      <div class=\"form-row form-row__options\" *ngIf=\"hasOptions\">\n        <div class=\"form-head-panel\">\n          <mat-label class=\"form-label\" [data-qa]=\"'field-options'\"\n            >{{ 'form.field_options' | translate }}\n          </mat-label>\n\n          <mzima-client-button\n            fill=\"outline\"\n            color=\"gray\"\n            size=\"medium\"\n            class=\"form-row__options__button\"\n            (buttonClick)=\"addOption()\"\n            [data-qa]=\"'btn-add-option'\"\n          >\n            {{ 'form.field_add_option' | translate }}\n            <mat-icon icon svgIcon=\"plus\"></mat-icon>\n          </mzima-client-button>\n        </div>\n\n        <div class=\"form-row__item\" *ngFor=\"let option of fieldOptions; let i = index\">\n          <mat-form-field appearance=\"outline\">\n            <input\n              matInput\n              [(ngModel)]=\"option.value\"\n              (input)=\"onChange(i)\"\n              placeholder=\"{{ 'form.field_name_placeholder' | translate }}\"\n              [data-qa]=\"'option-' + i\"\n              [disabled]=\"option.value === 'Other'\"\n            />\n            <mzima-client-button\n              matSuffix\n              fill=\"clear\"\n              color=\"danger\"\n              [iconOnly]=\"true\"\n              class=\"button-flat button-beta\"\n              (buttonClick)=\"removeOption(i)\"\n              [data-qa]=\"'btn-remove-option-' + i\"\n            >\n              <mat-icon icon svgIcon=\"delete\"></mat-icon>\n            </mzima-client-button>\n          </mat-form-field>\n          <mat-error role=\"alert\" *ngIf=\"option.error\">\n            {{ option.error | translate }}\n          </mat-error>\n        </div>\n        <div\n          *ngIf=\"\n            selectedFieldType?.options?.length > 0 &&\n            !selectedFieldType?.options?.includes('Other') &&\n            selectedFieldType.input !== 'select'\n          \"\n        >\n          <mzima-client-button\n            fill=\"outline\"\n            color=\"gray\"\n            size=\"medium\"\n            class=\"form-row__options__button\"\n            (buttonClick)=\"addOther()\"\n          >\n            {{ 'form.field_add_other' | translate }}\n          </mzima-client-button>\n          <p class=\"form-row__options__add-other\">\n            {{ 'form.field_add_other_desc' | translate }}\n          </p>\n        </div>\n      </div>\n\n      <div class=\"form-row\" *ngIf=\"selectedFieldType.input === 'tags'\">\n        <ng-container *ngIf=\"availableCategories; else spinner\">\n          <mat-label>{{ 'category.which_categories' | translate }}</mat-label>\n          <app-multilevel-selection\n            [data]=\"availableCategories\"\n            [(ngModel)]=\"selectedFieldType.options\"\n          >\n          </app-multilevel-selection>\n        </ng-container>\n      </div>\n\n      <div class=\"form-row\" *ngIf=\"selectedFieldType.input === 'relation'\">\n        <app-multilevel-select\n          [(ngModel)]=\"selectedFieldType.config.input.form\"\n          [placeholder]=\"'survey.select_related_post' | translate\"\n          [data]=\"availableSurveys\"\n          [label]=\"'survey.field_allowed_relation_survey' | translate\"\n        >\n        </app-multilevel-select>\n      </div>\n\n      <div class=\"form-row\" *ngIf=\"onlyOptional || canDisableCaption || canMakePrivate\">\n        <div class=\"toggle\">\n          <mat-slide-toggle\n            *ngIf=\"onlyOptional\"\n            [(ngModel)]=\"selectedFieldType.required\"\n            [data-qa]=\"'toggle-required'\"\n          >\n            {{ 'survey.required' | translate }}\n          </mat-slide-toggle>\n        </div>\n\n        <div class=\"toggle\">\n          <mat-slide-toggle\n            *ngIf=\"canDisableCaption\"\n            [(ngModel)]=\"selectedFieldType.config.hasCaption\"\n          >\n            {{ 'survey.collect_image_caption' | translate }}\n            <p class=\"init active\" *ngIf=\"!selectedFieldType.config?.hasCaption\">\n              <small>{{ 'survey.disable_caption_field_explanation' | translate }}</small>\n            </p>\n          </mat-slide-toggle>\n        </div>\n\n        <div class=\"toggle\">\n          <mat-slide-toggle\n            *ngIf=\"canMakePrivate\"\n            [(ngModel)]=\"selectedFieldType.response_private\"\n            [data-qa]=\"'toggle-private'\"\n          >\n            {{ 'survey.make_response_private' | translate }}\n            <p class=\"init active\" *ngIf=\"selectedFieldType.response_private\">\n              <small>{{ 'survey.response_private_desc' | translate }}</small>\n            </p>\n          </mat-slide-toggle>\n        </div>\n      </div>\n\n      <div id=\"field_value\" class=\"form-row\" *ngIf=\"canDisplay\">\n        <mat-label>{{ 'app.default_value' | translate }} </mat-label>\n        <mat-form-field appearance=\"outline\">\n          <ng-container [ngSwitch]=\"selectedFieldType.type\">\n            <input\n              *ngSwitchCase=\"'int'\"\n              matInput\n              [(ngModel)]=\"selectedFieldType.default\"\n              type=\"number\"\n              step=\"1\"\n              [data-qa]=\"'default-number'\"\n            />\n            <input\n              *ngSwitchCase=\"'decimal'\"\n              matInput\n              [(ngModel)]=\"selectedFieldType.default\"\n              type=\"text\"\n              [data-qa]=\"'default-number'\"\n            />\n            <input\n              *ngSwitchDefault\n              matInput\n              [(ngModel)]=\"selectedFieldType.default\"\n              placeholder=\"{{ 'form.default_default_placeholder' | translate }}\"\n              [data-qa]=\"'default-value'\"\n            />\n          </ng-container>\n          <mat-hint\n            *ngIf=\"numberError\"\n            class=\"alert error\"\n            [translate]=\"'form.error_input_number'\"\n            [translateParams]=\"{ type: selectedFieldType.type }\"\n          >\n          </mat-hint>\n        </mat-form-field>\n      </div>\n    </ng-container>\n  </ng-container>\n</mat-dialog-content>\n\n<div mat-dialog-actions align=\"end\">\n  <mzima-client-button\n    fill=\"outline\"\n    color=\"secondary\"\n    [mat-dialog-close]=\"false\"\n    [data-qa]=\"'btn-cancel-field'\"\n  >\n    {{ 'app.cancel' | translate }}\n  </mzima-client-button>\n  <mzima-client-button\n    (buttonClick)=\"addNewTask()\"\n    [disabled]=\"\n      !selectedFieldType?.label.trim()?.length ||\n      !validateDuplicate() ||\n      emptyTitleOption ||\n      checkForSpecialOptions()\n    \"\n    [data-qa]=\"'btn-add-field'\"\n  >\n    {{ (editMode ? 'app.update' : 'app.save') | translate }}\n  </mzima-client-button>\n</div>\n\n<ng-template #allFields>\n  <div class=\"fields-list\">\n    <mzima-client-button\n      color=\"default-color\"\n      size=\"medium__padding-equal__width-100\"\n      [expand]=\"false\"\n      matRipple\n      class=\"list-item\"\n      *ngFor=\"let field of fields\"\n      (click)=\"(field.input !== 'tags' || availableCategories?.length) && selectField(field)\"\n      [ngClass]=\"{ 'list-item--disabled': field.input === 'tags' && !availableCategories?.length }\"\n      [data-qa]=\"'select-' + field.label\"\n    >\n      <h3>{{ field.label | translate }}</h3>\n      <p>{{ field.instructions | translate }}</p>\n    </mzima-client-button>\n  </div>\n</ng-template>\n\n<ng-template #translateMode>\n  <div class=\"form-row\">\n    <mat-label>{{ 'app.name' | translate }}</mat-label>\n    <mat-form-field appearance=\"outline\">\n      <input\n        matInput\n        required\n        [(ngModel)]=\"selectedFieldType.label\"\n        placeholder=\"{{ 'form.field_name_placeholder' | translate }}\"\n        disabled\n      />\n    </mat-form-field>\n  </div>\n  <div class=\"form-row\">\n    <mat-label>{{ 'app.name' | translate }} ({{ selectLanguageCode }})</mat-label>\n    <mat-form-field appearance=\"outline\">\n      <input\n        matInput\n        required\n        [(ngModel)]=\"selectedFieldType.translations[selectLanguageCode].label\"\n        placeholder=\"{{ 'form.field_name_placeholder' | translate }}\"\n      />\n    </mat-form-field>\n  </div>\n  <ng-container *ngIf=\"selectedFieldType.instructions\">\n    <div class=\"form-row\">\n      <mat-label>{{ 'survey.show_field_description' | translate }}</mat-label>\n      <quill-editor\n        [(ngModel)]=\"selectedFieldType.instructions\"\n        placeholder=\"{{ 'app.insert_text_here' | translate }}\"\n        [disabled]=\"true\"\n      ></quill-editor>\n    </div>\n    <div class=\"form-row\">\n      <mat-label\n        >{{ 'survey.show_field_description' | translate }} ({{ selectLanguageCode }})</mat-label\n      >\n      <quill-editor\n        [(ngModel)]=\"selectedFieldType.translations[selectLanguageCode].instructions\"\n        placeholder=\"{{ 'app.insert_text_here' | translate }}\"\n      ></quill-editor>\n    </div>\n  </ng-container>\n</ng-template>\n\n<ng-template #spinner>\n  <app-spinner class=\"spinner\"></app-spinner>\n</ng-template>\n","import { Component, Inject, OnInit } from '@angular/core';\nimport { MatDialogRef, MAT_DIALOG_DATA } from '@angular/material/dialog';\nimport { surveyHelper } from '@helpers';\nimport { TranslateService } from '@ngx-translate/core';\nimport { map } from 'rxjs';\nimport { MultilevelSelectOption } from '../../../shared/components';\nimport {\n  CategoriesService,\n  SurveysService,\n  CategoryInterface,\n  FormAttributeInterface,\n  SurveyItem,\n} from '@mzima-client/sdk';\nimport { NotificationService } from '@services';\nimport _ from 'lodash';\n\n@Component({\n  selector: 'app-create-field-modal',\n  templateUrl: './create-field-modal.component.html',\n  styleUrls: ['./create-field-modal.component.scss'],\n})\nexport class CreateFieldModalComponent implements OnInit {\n  private surveyId: string;\n  public fields = _.cloneDeep(surveyHelper.surveyFields);\n  public selectedFieldType: any;\n  public editMode = false;\n  public availableCategories?: MultilevelSelectOption[];\n  public categories: any = [];\n  public availableSurveys: SurveyItem[] = [];\n  public hasOptions = false;\n  public fieldOptions: Array<{ value: string; error: string }> = [];\n  public emptyTitleOption = false;\n  public numberError = false;\n  isTranslateMode = false;\n  selectLanguageCode = 'en';\n\n  constructor(\n    @Inject(MAT_DIALOG_DATA) public data: any,\n    private matDialogRef: MatDialogRef<CreateFieldModalComponent>,\n    private translate: TranslateService,\n    private categoriesService: CategoriesService,\n    private surveysService: SurveysService,\n    private notificationService: NotificationService,\n  ) {}\n\n  ngOnInit() {\n    this.isTranslateMode = this.data?.isTranslateMode;\n    this.selectLanguageCode = this.data?.selectLanguageCode;\n    if (this.data?.selectedFieldType) {\n      this.editField();\n    }\n    this.surveyId = this.data?.surveyId;\n    this.getCategories();\n  }\n\n  private editField() {\n    this.editMode = true;\n\n    this.selectedFieldType = this.data.selectedFieldType;\n\n    this.updateRadioCheckboxFields();\n\n    this.updateTags();\n\n    this.setHasOptionValidate();\n\n    this.checkLoadAvailableData(this.selectedFieldType.input);\n\n    if (Array.isArray(this.selectedFieldType.translations)) {\n      this.selectedFieldType.translations = {};\n    }\n\n    if (!this.selectedFieldType.translations[this.selectLanguageCode]) {\n      this.selectedFieldType.translations[this.selectLanguageCode] = { label: '' };\n    }\n  }\n\n  private updateTags() {\n    if (\n      this.selectedFieldType.input === 'tags' &&\n      this.selectedFieldType.options?.length &&\n      typeof this.selectedFieldType.options[0] === 'object'\n    ) {\n      this.selectedFieldType.options = this.selectedFieldType.options.map(\n        (option: any) => option.id,\n      );\n      this.setTempSelectedFieldType();\n    }\n  }\n\n  private updateRadioCheckboxFields() {\n    const checkTypes = ['radio', 'checkbox', 'select'];\n    if (checkTypes.includes(this.selectedFieldType.input)) {\n      this.fieldOptions = this.data?.selectedFieldType.options?.map((option: any) => ({\n        value: option,\n        error: '',\n      }));\n    }\n  }\n\n  private getCategories() {\n    const array: MultilevelSelectOption[] = [];\n    this.categoriesService\n      .get()\n      .pipe(\n        map((res) => {\n          for (const category of res?.results) {\n            if (!category.parent_id) {\n              array.push({\n                id: category.id,\n                name: category.tag,\n                children: category.children.map((cat: CategoryInterface) => {\n                  return {\n                    id: cat.id,\n                    name: cat.tag,\n                  };\n                }),\n              });\n            }\n          }\n          return array;\n        }),\n      )\n      .subscribe({\n        next: (response) => {\n          this.availableCategories = response;\n        },\n        error: (err) => console.log(err),\n      });\n  }\n\n  onChange(index: number) {\n    const option = this.fieldOptions[index];\n    this.selectedFieldType.options[index] = option.value.trim();\n    this.checkForEmptyOptions();\n    this.optionValidation(index);\n  }\n\n  optionValidation(index: number) {\n    const option = this.fieldOptions[index];\n\n    const duplicates = this.fieldOptions.filter((e, i) => e.value === option.value && i !== index);\n    option.error = duplicates.length ? 'survey.duplicate_option' : '';\n  }\n\n  public checkForSpecialOptions(): boolean {\n    return this.fieldOptions.some((option) => !!option.error);\n  }\n\n  private checkForEmptyOptions() {\n    if (this.selectedFieldType.options.length) {\n      this.emptyTitleOption = !!this.selectedFieldType.options.filter(\n        (el: string) => el.trim() === '',\n      ).length;\n    }\n  }\n\n  get onlyOptional() {\n    const types = ['tags', 'description', 'title'];\n    return !types.includes(this.selectedFieldType.type);\n  }\n\n  get canMakePrivate() {\n    const types = ['tags', 'description', 'title'];\n    return !types.includes(this.selectedFieldType.type);\n  }\n\n  get canDisableCaption() {\n    const types = ['media'];\n    return types.includes(this.selectedFieldType.type);\n  }\n\n  get canDisplay() {\n    const inputs = [\n      'upload',\n      'tags',\n      'location',\n      'checkbox',\n      'select',\n      'radio',\n      'date',\n      'datetime',\n    ];\n    return !inputs.includes(this.selectedFieldType.input);\n  }\n\n  private loadAvailableSurveys() {\n    this.surveysService.get().subscribe({\n      next: (types) => {\n        this.availableSurveys =\n          types.results.filter((s: any) => s.id.toString() !== this.surveyId) || [];\n      },\n    });\n  }\n\n  private isNumber({ default: val, type }: any): boolean {\n    if (!val) return true;\n    if (type === 'decimal') {\n      return /((?<!\\S)[-+]?[0-9]*[.,][0-9]+$)/gm.test(String(val).trim());\n    }\n    if (type === 'int') {\n      return /^-?\\d+$/gm.test(String(val).trim());\n    }\n    return true;\n  }\n\n  public addNewTask() {\n    if (this.selectedFieldType.input === 'number') {\n      if (this.isNumber(this.selectedFieldType)) {\n        this.numberError = false;\n      } else {\n        this.numberError = true;\n        return;\n      }\n    }\n\n    if (this.hasOptions && !this.selectedFieldType.options?.length) {\n      this.notificationService.showError(this.translate.instant('survey.add_options_first'));\n      return;\n    }\n\n    if (!this.selectedFieldType.translations) {\n      this.selectedFieldType.translations = {};\n    }\n\n    this.matDialogRef.close({\n      ...this.selectedFieldType,\n      label: this.selectedFieldType.label.trim(),\n    });\n  }\n\n  public selectField(field: Partial<FormAttributeInterface>) {\n    this.selectedFieldType = _.cloneDeep(field);\n    this.selectedFieldType.label = this.translate.instant(this.selectedFieldType.label);\n    this.selectedFieldType.instructions = this.translate.instant(\n      this.selectedFieldType.instructions,\n    );\n    this.setHasOptionValidate();\n    this.checkLoadAvailableData(this.selectedFieldType.input);\n  }\n\n  private checkLoadAvailableData(input: string) {\n    switch (input) {\n      case 'relation':\n        return this.loadAvailableSurveys();\n    }\n  }\n\n  public removeOption(i: any) {\n    this.selectedFieldType.options.splice(i, 1);\n    this.fieldOptions.splice(i, 1);\n    this.checkForEmptyOptions();\n  }\n\n  public addOption() {\n    if (!this.selectedFieldType.options) this.selectedFieldType.options = [];\n    this.selectedFieldType.options.push('');\n    this.checkForEmptyOptions();\n    this.fieldOptions.push({ value: '', error: '' });\n  }\n\n  public addOther() {\n    if (!this.selectedFieldType.options) this.selectedFieldType.options = [];\n    if (this.selectedFieldType.options.includes('Other')) return;\n    this.selectedFieldType.options.push('Other');\n    this.fieldOptions.push({ value: 'Other', error: '' });\n  }\n\n  private setTempSelectedFieldType() {\n    this.fieldOptions = this.selectedFieldType.options.map((opt: string) => ({\n      value: opt,\n      error: '',\n    }));\n    this.fieldOptions.forEach((opt, i) => this.optionValidation(i));\n  }\n\n  private setHasOptionValidate() {\n    this.hasOptions = ['checkbox', 'radio', 'select'].some(\n      (a) => a === this.selectedFieldType.input,\n    );\n  }\n\n  public validateDuplicate() {\n    if (surveyHelper.fieldCanHaveOptions(this.selectedFieldType)) {\n      return surveyHelper.areOptionsUnique(this.selectedFieldType.options);\n    }\n    return true;\n  }\n}\n","<div class=\"form-row\">\n  <mat-label>{{ 'app.survey_web_address' | translate }}</mat-label>\n  <mat-form-field appearance=\"outline\">\n    <input type=\"url\" matInput [value]=\"shareUrl\" readonly=\"true\" />\n  </mat-form-field>\n</div>\n\n<div class=\"form-row\">\n  <mat-label>HTML</mat-label>\n  <div class=\"copy-success\" *ngIf=\"copySuccess\">{{ 'share.copied' | translate }}</div>\n  <mat-form-field appearance=\"outline\" class=\"copy\" [ngClass]=\"{ success: copySuccess }\">\n    <textarea matInput readonly cdkTextareaAutosize cdkAutosizeMaxRows=\"10\">{{ embed }}</textarea>\n    <mzima-client-button\n      matSuffix\n      fill=\"clear\"\n      color=\"secondary\"\n      [iconOnly]=\"true\"\n      class=\"copy-button\"\n      [disabled]=\"copySuccess\"\n      (buttonClick)=\"copyToClipboard(embed)\"\n    >\n      <mat-icon icon svgIcon=\"copy\"></mat-icon>\n    </mzima-client-button>\n  </mat-form-field>\n</div>\n\n<div class=\"form-row\">\n  <mzima-client-button\n    fill=\"clear\"\n    color=\"secondary\"\n    target=\"_blank\"\n    class=\"share-item\"\n    [href]=\"'https://twitter.com/intent/tweet?url=' + shareUrlEncoded\"\n  >\n    <mat-icon iconPrefix svgIcon=\"twitter\"></mat-icon>\n    Twitter\n  </mzima-client-button>\n</div>\n\n<div class=\"form-row\">\n  <mzima-client-button\n    fill=\"clear\"\n    color=\"secondary\"\n    target=\"_blank\"\n    class=\"share-item\"\n    [href]=\"\n      'https://www.facebook.com/sharer/sharer.php?u=' + shareUrlEncoded + '&amp;src=sdkpreparse'\n    \"\n  >\n    <mat-icon iconPrefix svgIcon=\"facebook\"></mat-icon>\n    Facebook\n  </mzima-client-button>\n</div>\n","import { Component, Input, OnInit } from '@angular/core';\nimport { Clipboard } from '@angular/cdk/clipboard';\n\n@Component({\n  selector: 'app-share-menu',\n  templateUrl: './share-menu.component.html',\n  styleUrls: ['./share-menu.component.scss'],\n})\nexport class ShareMenuComponent implements OnInit {\n  @Input() postId: string;\n  @Input() surveyId: string;\n  shareUrl: string = '';\n  shareUrlEncoded: any;\n  hasPermission = true;\n  public copySuccess = false;\n  public embed = `<iframe width=\"560\" height=\"315\" src=\"https://mzima.staging.ush.zone/posts/create/1\" frameborder=\"0\" allowfullscreen></iframe>`;\n\n  constructor(private clipboard: Clipboard) {}\n\n  ngOnInit(): void {\n    if (this.postId) {\n      this.shareUrl = `${window.location.origin}/posts/${this.postId}`;\n    }\n\n    if (this.surveyId) {\n      this.shareUrl = `${window.location.origin}/posts/create/${this.surveyId}`;\n    }\n\n    this.shareUrlEncoded = encodeURIComponent(this.shareUrl);\n  }\n\n  isExportable() {\n    return true;\n  }\n\n  public copyToClipboard(str: string): void {\n    this.copySuccess = this.clipboard.copy(str);\n    setTimeout(() => (this.copySuccess = !this.copySuccess), 2000);\n  }\n}\n","<div class=\"task\" [ngClass]=\"{ 'task--main': isMain }\">\n  <mat-tab-group dynamicHeight disableRipple disablePagination>\n    <mat-tab [label]=\"'survey.main_info' | translate\" [data-qa]=\"'survey-main-info'\">\n      <ng-container *ngIf=\"!isPost\">\n        <div class=\"form-row\">\n          <mat-label>{{ 'survey.task_name' | translate }} *</mat-label>\n          <mat-form-field appearance=\"outline\">\n            <input\n              matInput\n              [(ngModel)]=\"task.label\"\n              [placeholder]=\"'survey.untitled_task' | translate\"\n              [readonly]=\"!isDefaultLanguageSelected\"\n              (ngModelChange)=\"changeLabel($event)\"\n              required\n            />\n          </mat-form-field>\n        </div>\n        <div class=\"form-row\" *ngIf=\"!isDefaultLanguageSelected\">\n          <mat-label>{{ 'survey.task_name' | translate }} ({{ selectLanguageCode }})</mat-label>\n          <mat-form-field appearance=\"outline\">\n            <input\n              matInput\n              [(ngModel)]=\"task.translations[selectLanguageCode].label\"\n              [placeholder]=\"'survey.untitled_task' | translate\"\n              (ngModelChange)=\"changeLabel($event)\"\n            />\n          </mat-form-field>\n        </div>\n        <div class=\"form-row\">\n          <mat-label>{{ 'app.description' | translate }}</mat-label>\n          <mat-form-field appearance=\"outline\">\n            <textarea\n              matInput\n              cdkTextareaAutosize\n              [readonly]=\"!isDefaultLanguageSelected\"\n              [(ngModel)]=\"task.description\"\n              [placeholder]=\"'survey.describe_this_task' | translate\"\n            >\n            </textarea>\n          </mat-form-field>\n        </div>\n\n        <div class=\"form-row\" *ngIf=\"!isDefaultLanguageSelected\">\n          <mat-label>{{ 'app.description' | translate }} ({{ selectLanguageCode }})</mat-label>\n          <mat-form-field appearance=\"outline\">\n            <textarea\n              matInput\n              cdkTextareaAutosize\n              [(ngModel)]=\"task.translations[selectLanguageCode].description\"\n              [placeholder]=\"'survey.describe_this_task' | translate\"\n            >\n            </textarea>\n          </mat-form-field>\n        </div>\n      </ng-container>\n\n      <ng-content *ngIf=\"isPost\" select=\"[survey-info]\"></ng-content>\n\n      <div class=\"form-head-panel\">\n        <h2>\n          {{\n            isDefaultLanguageSelected\n              ? ('survey.fields.fields_title' | translate)\n              : ('translations.field_add_translation' | translate)\n          }}\n        </h2>\n        <mzima-client-button\n          color=\"secondary\"\n          fill=\"outline\"\n          (buttonClick)=\"addField()\"\n          [data-qa]=\"'btn-survey-add-field'\"\n          *ngIf=\"isDefaultLanguageSelected\"\n        >\n          <span>{{ 'form.add_field' | translate }}</span>\n          <mat-icon icon svgIcon=\"plus\"></mat-icon>\n        </mzima-client-button>\n      </div>\n\n      <div cdkDropList class=\"fields-list\" *ngIf=\"taskFields?.length\">\n        <div\n          class=\"field-item\"\n          *ngFor=\"let field of nonDraggableFields | sortByField : 'priority' : 'asc'; let i = index\"\n          [data-qa]=\"'field-' + field\"\n        >\n          <div class=\"field-item__main\">\n            <mat-icon\n              cdkDragHandle\n              class=\"field-item__non-drag-handle\"\n              svgIcon=\"drag-handle\"\n            ></mat-icon>\n            <span class=\"field-item__title\" [data-qa]=\"'field-name'\">{{\n              isDefaultLanguageSelected\n                ? field.label\n                : field.translations[selectLanguageCode]?.label || field.label\n            }}</span>\n          </div>\n          <!-- <span class=\"field-item__type\">{{ field.type }}</span> -->\n          <div class=\"field-item__controls\">\n            <mzima-client-button\n              fill=\"clear\"\n              color=\"gray\"\n              [iconOnly]=\"true\"\n              class=\"field-item__control\"\n              (buttonClick)=\"editField(field, i)\"\n              [data-qa]=\"'btn-field-edit-' + field.label\"\n            >\n              <mat-icon icon svgIcon=\"pencil\"></mat-icon>\n            </mzima-client-button>\n          </div>\n        </div>\n      </div>\n\n      <div\n        cdkDropList\n        class=\"fields-list\"\n        (cdkDropListDropped)=\"drop($event)\"\n        *ngIf=\"taskFields?.length; else noFields\"\n      >\n        <div\n          class=\"field-item\"\n          *ngFor=\"let field of draggableFields | sortByField : 'priority' : 'asc'; let i = index\"\n          cdkDrag\n          [cdkDragDisabled]=\"!isDefaultLanguageSelected\"\n          [data-qa]=\"'field-' + field\"\n        >\n          <div class=\"field-item__main\">\n            <mat-icon\n              cdkDragHandle\n              class=\"field-item__drag-handle\"\n              svgIcon=\"drag-handle\"\n            ></mat-icon>\n            <span class=\"field-item__title\" [data-qa]=\"'field-name'\">{{\n              isDefaultLanguageSelected\n                ? field.label\n                : field.translations[selectLanguageCode]?.label || field.label\n            }}</span>\n          </div>\n          <!-- <span class=\"field-item__type\">{{ field.type }}</span> -->\n          <div class=\"field-item__controls\">\n            <mzima-client-button\n              fill=\"clear\"\n              color=\"gray\"\n              [iconOnly]=\"true\"\n              class=\"field-item__control\"\n              (buttonClick)=\"editField(field, i)\"\n              [data-qa]=\"'btn-field-edit-' + field.label\"\n            >\n              <mat-icon icon svgIcon=\"pencil\"></mat-icon>\n            </mzima-client-button>\n            <mzima-client-button\n              fill=\"clear\"\n              color=\"gray\"\n              [iconOnly]=\"true\"\n              class=\"field-item__control\"\n              *ngIf=\"isDefaultLanguageSelected\"\n              (buttonClick)=\"deleteField(i)\"\n              [data-qa]=\"'btn-field-delete-' + field.label\"\n            >\n              <mat-icon icon svgIcon=\"delete\"></mat-icon>\n            </mzima-client-button>\n          </div>\n        </div>\n      </div>\n      <ng-template #noFields>\n        <div class=\"form-row empty\">{{ 'survey.no_fields' | translate }}</div>\n      </ng-template>\n\n      <div class=\"form-controls-panel\" *ngIf=\"!isPost && isDefaultLanguageSelected\">\n        <mzima-client-button color=\"danger\" (buttonClick)=\"deleteTask(task)\">\n          {{ 'survey.delete_task' | translate }}\n        </mzima-client-button>\n        <mzima-client-button fill=\"outline\" color=\"secondary\" (buttonClick)=\"duplicateTask(task)\">\n          {{ 'survey.duplicate_task' | translate }}\n        </mzima-client-button>\n      </div>\n    </mat-tab>\n    <mat-tab\n      [label]=\"'survey.configure' | translate\"\n      *ngIf=\"!isPost\"\n      [data-qa]=\"'survey-configure'\"\n      [disabled]=\"!isDefaultLanguageSelected\"\n    >\n      <div class=\"toggle\">\n        <mat-slide-toggle [(ngModel)]=\"task.required\" name=\"accept-survey\">\n          {{ 'survey.required' | translate }}\n          <p *ngIf=\"task.required\">\n            <small>{{ 'survey.required_desc' | translate }}</small>\n          </p>\n        </mat-slide-toggle>\n      </div>\n      <div class=\"toggle\">\n        <mat-slide-toggle [(ngModel)]=\"task.task_is_internal_only\" name=\"import-to-survey\">\n          {{ 'survey.internal_use_task' | translate }}\n          <p *ngIf=\"task.task_is_internal_only\">\n            <small>{{ 'survey.internal_use_task_desc' | translate }}</small>\n          </p>\n        </mat-slide-toggle>\n      </div>\n      <div class=\"toggle\">\n        <mat-slide-toggle [(ngModel)]=\"task.show_when_published\" name=\"import-to-survey\">\n          {{ 'survey.show_this_task_to' | translate }}\n          <p *ngIf=\"task.show_when_published\">\n            <small>{{ 'survey.show_this_task_to_desc' | translate }}</small>\n          </p>\n        </mat-slide-toggle>\n      </div>\n    </mat-tab>\n    <mat-tab\n      [label]=\"'survey.configure' | translate\"\n      *ngIf=\"isPost\"\n      [data-qa]=\"'survey-configure'\"\n      [disabled]=\"!isDefaultLanguageSelected\"\n    >\n      <ng-container *ngIf=\"survey\">\n        <div class=\"form-row\">\n          <div class=\"toggle\">\n            <mat-slide-toggle\n              [data-qa]=\"'toggle-posts-require-review'\"\n              [(ngModel)]=\"survey.require_approval\"\n              name=\"accept-survey\"\n            >\n              {{ 'survey.require_review' | translate }}\n            </mat-slide-toggle>\n            <p *ngIf=\"survey.require_approval\" class=\"toggle__description\">\n              {{ 'survey.require_review_desc' | translate }}\n            </p>\n          </div>\n          <div class=\"toggle\">\n            <mat-slide-toggle\n              [data-qa]=\"'toggle-hide-author'\"\n              [(ngModel)]=\"survey.hide_author\"\n              name=\"import-to-survey\"\n            >\n              {{ 'survey.hide_author_information' | translate }}\n            </mat-slide-toggle>\n            <p *ngIf=\"survey.hide_author\" class=\"toggle__description\">\n              {{ 'survey.hide_author_information_desc' | translate }}\n            </p>\n          </div>\n          <div class=\"toggle\" *ngIf=\"anonymiseReportersEnabled\">\n            <mat-slide-toggle\n              [data-qa]=\"'toggle-hide-location'\"\n              [(ngModel)]=\"survey.hide_location\"\n              name=\"import-to-survey\"\n            >\n              {{ 'survey.hide_location_information' | translate }}\n            </mat-slide-toggle>\n            <p\n              *ngIf=\"survey.hide_location\"\n              class=\"toggle__description\"\n              [translate]=\"'survey.hide_location_information_desc'\"\n              [translateParams]=\"{ precision: locationPrecision }\"\n            ></p>\n          </div>\n          <div class=\"toggle\" *ngIf=\"anonymiseReportersEnabled\">\n            <mat-slide-toggle\n              [data-qa]=\"'toggle-hide-time'\"\n              [(ngModel)]=\"survey.hide_time\"\n              name=\"import-to-survey\"\n            >\n              {{ 'survey.hide_time_information' | translate }}\n            </mat-slide-toggle>\n            <p *ngIf=\"survey.hide_time\" class=\"toggle__description\">\n              {{ 'survey.hide_time_information_desc' | translate }}\n            </p>\n          </div>\n        </div>\n        <div class=\"form-row\">\n          <mat-label>{{ 'survey.who_can_add' | translate }}</mat-label>\n          <div class=\"radio-group\">\n            <app-group-checkbox-select [data]=\"roleOptions\" [(ngModel)]=\"selectedRoles\">\n            </app-group-checkbox-select>\n          </div>\n        </div>\n\n        <app-color-picker\n          [label]=\"'survey.select_color' | translate\"\n          [(ngModel)]=\"selectedColor\"\n          (ngModelChange)=\"colorChanged()\"\n          color-container=\"survey\"\n        ></app-color-picker>\n\n        <div class=\"form-row\">\n          <mat-label>{{ 'translations.survey_select_default' | translate }}</mat-label>\n          <mat-form-field appearance=\"outline\">\n            <mat-select\n              disableOptionCentering\n              panelClass=\"language-field\"\n              [(value)]=\"selectedLanguage\"\n              (selectionChange)=\"changeLanguage($event)\"\n            >\n              <mat-option *ngFor=\"let lang of languagesToSelect\" [value]=\"lang.code\">\n                <span class=\"language-title\">{{ lang.name }}</span>\n              </mat-option>\n            </mat-select>\n          </mat-form-field>\n          <div class=\"alert error\" *ngIf=\"showLangError\">\n            <mat-icon svgIcon=\"warning\"></mat-icon>\n            <p translate=\"translations.error_translation_exists\"></p>\n          </div>\n        </div>\n      </ng-container>\n    </mat-tab>\n    <mat-tab *ngIf=\"isPost\" [label]=\"'survey.share' | translate\" [data-qa]=\"'survey-share'\">\n      <app-share-menu [surveyId]=\"surveyId\"></app-share-menu>\n    </mat-tab>\n  </mat-tab-group>\n</div>\n","import { CdkDragDrop, moveItemInArray } from '@angular/cdk/drag-drop';\nimport {\n  Component,\n  EventEmitter,\n  Input,\n  OnChanges,\n  OnInit,\n  Output,\n  SimpleChanges,\n} from '@angular/core';\nimport { MatDialog } from '@angular/material/dialog';\nimport { ActivatedRoute } from '@angular/router';\nimport { LanguageInterface } from '@mzima-client/sdk';\nimport { TranslateService } from '@ngx-translate/core';\nimport {\n  GroupCheckboxItemInterface,\n  GroupCheckboxValueInterface,\n} from '../../../shared/components';\nimport { CreateFieldModalComponent } from '../create-field-modal/create-field-modal.component';\nimport {\n  FormsService,\n  FormAttributeInterface,\n  RoleResult,\n  SurveyItem,\n  SurveyItemTask,\n  generalHelpers,\n} from '@mzima-client/sdk';\nimport { ConfirmModalService, LanguageService, SessionService } from '@services';\nimport _ from 'lodash';\n\n@Component({\n  selector: 'app-survey-task',\n  templateUrl: './survey-task.component.html',\n  styleUrls: ['./survey-task.component.scss'],\n})\nexport class SurveyTaskComponent implements OnInit, OnChanges {\n  @Input() task: SurveyItemTask;\n  @Input() survey: SurveyItem;\n  @Input() isDefaultLanguageSelected: boolean;\n  @Input() selectLanguageCode: string;\n  @Input() roles: RoleResult[];\n  @Input() isMain: boolean;\n  @Output() colorSelected = new EventEmitter();\n  @Output() languageChange = new EventEmitter();\n  @Output() duplicateTaskChange = new EventEmitter();\n  @Output() deleteTaskChange = new EventEmitter();\n  @Output() errorFieldChange = new EventEmitter();\n  @Output() taskChange = new EventEmitter();\n\n  surveyId: string;\n  selectedRoles: GroupCheckboxValueInterface = {\n    value: 'everyone',\n    options: [],\n  };\n\n  taskFields: FormAttributeInterface[];\n  nonDraggableFields: FormAttributeInterface[];\n  draggableFields: FormAttributeInterface[];\n  isPost = false;\n  showLangError = false;\n  selectedLanguage: any;\n  languages: any;\n  languagesToSelect: LanguageInterface[] = [];\n  roleOptions: GroupCheckboxItemInterface[] = [];\n  selectedColor: string;\n  currentInterimId = 0;\n  selectedTab: number;\n  locationPrecision = 1000;\n\n  constructor(\n    private confirm: ConfirmModalService,\n    private formsService: FormsService,\n    private dialog: MatDialog,\n    private route: ActivatedRoute,\n    private languageService: LanguageService,\n    private translate: TranslateService,\n    private sessionService: SessionService,\n  ) {}\n\n  ngOnChanges(changes: SimpleChanges): void {\n    if (changes['task']) {\n      if (Array.isArray(this.task.translations)) {\n        this.task.translations = {};\n      }\n    }\n\n    if (changes['selectLanguageCode']) {\n      if (!this.task.translations[this.selectLanguageCode]) {\n        this.task.translations[this.selectLanguageCode] = { label: '' };\n      }\n    }\n\n    if (changes['roles']) {\n      this.roleOptions = [\n        {\n          name: this.translate.instant('role.everyone'),\n          value: 'everyone',\n          icon: 'person',\n        },\n        {\n          name: this.translate.instant('app.specific_roles'),\n          value: 'specific',\n          icon: 'group',\n          options: this.roles.map((role) => {\n            return {\n              name: role.display_name,\n              value: role.name,\n              checked: role.name === 'admin',\n              disabled: role.name === 'admin',\n            };\n          }),\n        },\n      ];\n    }\n\n    if (changes['survey']) {\n      this.initLanguages();\n      this.selectedColor = this.survey.color;\n    }\n  }\n\n  ngOnInit(): void {\n    this.getMapConfig();\n    this.surveyId = this.route.snapshot.paramMap.get('id') || '';\n    this.taskFields = this.task.fields;\n    this.splitTaskFields(this.taskFields);\n    this.currentInterimId = this.findIntermId();\n    this.isPost = this.task.type === 'post';\n    if (this.surveyId && this.isPost) {\n      this.getSurveyRoles();\n    }\n  }\n\n  private getMapConfig() {\n    const { location_precision: locationPrecision } = this.sessionService.getMapConfigurations();\n    this.locationPrecision = this.sessionService.getPrecision(locationPrecision!);\n  }\n\n  private splitTaskFields(taskFields: FormAttributeInterface[]) {\n    const nonDraggableFieldType = (fieldType: string) =>\n      fieldType === 'title' || fieldType === 'description';\n    this.nonDraggableFields = taskFields.filter((field) => nonDraggableFieldType(field.type));\n    this.draggableFields = taskFields.filter((field) => !nonDraggableFieldType(field.type));\n  }\n\n  private getSurveyRoles() {\n    this.formsService.getRoles(this.surveyId).subscribe((response) => {\n      this.selectedRoles = {\n        value: this.survey.everyone_can_create ? 'everyone' : 'specific',\n        options: response.map((r) => {\n          return this.roles.find((role) => role.id === r.role_id)!.name;\n        }),\n      };\n    });\n  }\n\n  getConfigOptions() {\n    return {\n      selectedRoles: this.selectedRoles,\n      hide_time: this.survey.hide_time,\n      hide_location: this.survey.hide_location,\n      hide_author: this.survey.hide_author,\n      require_approval: this.survey.require_approval,\n      color: this.selectedColor,\n    };\n  }\n\n  private findIntermId() {\n    const stageIds: number[] = [];\n    _.each(this.taskFields, (field: any) => {\n      if (field.form_stage_id && typeof field.form_stage_id !== 'number') {\n        stageIds.push(field.form_stage_id.split('_')[2]);\n      }\n    });\n    return stageIds.length ? Math.max.apply(null, stageIds) : 0;\n  }\n\n  private initLanguages() {\n    this.languagesToSelect = this.languageService.getLanguages();\n\n    const language = localStorage.getItem(`${generalHelpers.CONST.LOCAL_STORAGE_PREFIX}language`);\n\n    if (!this.survey.enabled_languages) {\n      this.survey.enabled_languages = {\n        default: language!,\n        available: [],\n      };\n    }\n    this.languages = {\n      default: this.survey.enabled_languages.default,\n      active: this.survey.enabled_languages.default,\n      available: this.survey.enabled_languages.available,\n      surveyLanguages: [\n        this.survey.enabled_languages.default,\n        ...this.survey.enabled_languages.available,\n      ],\n    };\n    this.selectedLanguage = this.survey.enabled_languages.default;\n  }\n\n  drop(event: CdkDragDrop<FormAttributeInterface[]>) {\n    moveItemInArray(this.draggableFields, event.previousIndex, event.currentIndex);\n\n    if (event.previousIndex > event.currentIndex) {\n      this.draggableFields[event.currentIndex].priority =\n        this.draggableFields[event.currentIndex].priority - 1;\n    }\n\n    if (event.previousIndex < event.currentIndex) {\n      this.draggableFields[event.currentIndex].priority =\n        this.draggableFields[event.currentIndex].priority + 1;\n    }\n    this.mergeTaskFieldsData();\n    this.changePriority(event);\n    this.taskChangeEmit();\n  }\n\n  private changePriority(event: any) {\n    for (let i = event.currentIndex; i < this.taskFields.length; i++) {\n      this.taskFields[i].priority = i + 1;\n    }\n  }\n\n  changeLanguage(event: any) {\n    const newLang = event.value;\n    this.languageChange.emit(newLang);\n    if (this.survey.enabled_languages.available.some((l) => l === newLang)) {\n      this.showLangError = true;\n    } else {\n      this.showLangError = false;\n      this.languages = {\n        default: newLang,\n        active: newLang,\n        available: this.survey.enabled_languages.available,\n      };\n      this.selectedLanguage = newLang;\n      this.survey.enabled_languages.default = newLang;\n    }\n  }\n\n  async deleteField(index: number) {\n    const confirmed = await this.confirm.open({\n      title: this.translate.instant('notify.form.delete_attribute_confirm'),\n      description: `<p>${this.translate.instant('notify.form.delete_attribute_confirm_desc')}</p>`,\n    });\n    if (!confirmed) return;\n    this.draggableFields.splice(index, 1);\n    this.mergeTaskFieldsData();\n    this.taskChangeEmit();\n  }\n\n  get anonymiseReportersEnabled() {\n    return !!this.sessionService.getFeatureConfigurations()['anonymise-reporters']?.enabled;\n  }\n\n  private mergeTaskFieldsData() {\n    this.taskFields = [...this.nonDraggableFields, ...this.draggableFields];\n  }\n\n  addField() {\n    const dialogRef = this.dialog.open(CreateFieldModalComponent, {\n      width: '100%',\n      maxWidth: 576,\n      minWidth: 300,\n      panelClass: 'modal',\n      data: {\n        surveyId: this.surveyId,\n        isTranslateMode: !this.isDefaultLanguageSelected,\n      },\n    });\n\n    dialogRef.afterClosed().subscribe({\n      next: (response) => {\n        if (response) {\n          this.draggableFields.push(this.addPriority(this.taskFields, response));\n          this.taskFields.push(this.addPriority(this.taskFields, response));\n        }\n      },\n    });\n  }\n\n  addPriority(array: FormAttributeInterface[], newObject: any) {\n    const maxPriority = array.reduce((max, current) => {\n      return current.priority > max ? current.priority : max;\n    }, 0);\n\n    newObject.priority = maxPriority + 1;\n    return newObject;\n  }\n\n  editField(selectedFieldType: any, idx: number) {\n    const dialogRef = this.dialog.open(CreateFieldModalComponent, {\n      width: '100%',\n      maxWidth: 576,\n      minWidth: 300,\n      panelClass: 'modal',\n      data: {\n        selectedFieldType: _.cloneDeep(selectedFieldType),\n        surveyId: this.surveyId,\n        isTranslateMode: !this.isDefaultLanguageSelected,\n        selectLanguageCode: this.selectLanguageCode,\n      },\n    });\n\n    dialogRef.afterClosed().subscribe({\n      next: (response: FormAttributeInterface) => {\n        if (response) {\n          const safePriority: number[] = [1, 2];\n          if (safePriority.includes(response.priority)) {\n            this.nonDraggableFields[idx] = response;\n          } else {\n            this.draggableFields[idx] = response;\n          }\n          this.mergeTaskFieldsData();\n          this.taskChangeEmit();\n        }\n      },\n    });\n  }\n\n  private taskChangeEmit() {\n    this.task.fields = this.taskFields;\n    this.taskChange.emit(this.task);\n  }\n\n  public colorChanged(): void {\n    this.colorSelected.emit(this.selectedColor);\n  }\n\n  public deleteTask(task: SurveyItemTask) {\n    this.deleteTaskChange.emit(task);\n    this.errorFieldChange.emit(false);\n  }\n\n  public duplicateTask(task: SurveyItemTask) {\n    const dup = _.cloneDeep(task);\n    dup.label = '';\n    dup.description = '';\n    _.each(dup.fields, (field: Partial<any>) => {\n      if (field) {\n        delete field['id'];\n        delete field['url'];\n        delete field['key'];\n        field['form_stage_id'] = this.getInterimId();\n      }\n    });\n    this.duplicateTaskChange.emit(dup);\n  }\n\n  private getInterimId() {\n    const id = 'interim_id_' + this.currentInterimId;\n    this.currentInterimId++;\n    return id;\n  }\n\n  public changeLabel(value: string) {\n    this.errorFieldChange.emit(value.trim().length === 0);\n  }\n}\n","<form\n  novalidate\n  [formGroup]=\"form\"\n  class=\"main-form\"\n  (ngSubmit)=\"form.valid && save()\"\n  [ngStyle]=\"{\n    '--color': this.form.get('color')?.value\n  }\"\n>\n  <span class=\"main-form__border\"></span>\n  <app-settings-header\n    [settingsTitle]=\"(!isEdit ? 'app.add_survey' : 'app.edit_survey') | translate\"\n    [newButtonTitle]=\"isDesktop ? 'translations.add_translation_lang' : 'Translation'\"\n    [isShowActionsButton]=\"false\"\n    [isShowCreation]=\"false\"\n    [isShowTranslation]=\"true\"\n    [selectedLanguage]=\"selectedLang\"\n    [languages]=\"activeLanguages\"\n    [defaultLanguage]=\"defaultLanguage\"\n    (showLanguagesCall)=\"addTranslation()\"\n    (selectLanguageCall)=\"chooseTranslation($event)\"\n  >\n  </app-settings-header>\n\n  <app-survey-task\n    #configTask\n    [task]=\"mainPost\"\n    [roles]=\"roles\"\n    [isMain]=\"true\"\n    [survey]=\"surveyObject\"\n    (taskChange)=\"taskUpdate($event)\"\n    *ngIf=\"mainPost\"\n    (colorSelected)=\"setNewColor($event)\"\n    (languageChange)=\"languageChange($event)\"\n    [isDefaultLanguageSelected]=\"isDefaultLanguageSelected\"\n    [selectLanguageCode]=\"selectLanguageCode\"\n  >\n    <ng-container survey-info>\n      <div class=\"form-row\">\n        <mat-label>{{ 'survey.survey_name' | translate }} *</mat-label>\n        <mat-form-field appearance=\"outline\">\n          <input\n            matInput\n            formControlName=\"name\"\n            [placeholder]=\"'survey.survey_name' | translate\"\n            [readonly]=\"!isDefaultLanguageSelected\"\n          />\n          <mat-error *ngIf=\"form.get('name')?.hasError('required')\">\n            {{ 'survey.fields.validation.required' | translate }}\n          </mat-error>\n          <mat-error\n            *ngIf=\"form.get('name')?.hasError('specialCharacters')\"\n            [translate]=\"'survey.fields.validation.special_characters'\"\n            [translateParams]=\"{ name: ('survey.survey_name' | translate) }\"\n          >\n          </mat-error>\n        </mat-form-field>\n      </div>\n\n      <div class=\"form-row\" *ngIf=\"!isDefaultLanguageSelected\">\n        <mat-label> {{ 'survey.survey_name' | translate }} ({{ selectLanguageCode }})</mat-label>\n        <mat-form-field appearance=\"outline\">\n          <input\n            matInput\n            [placeholder]=\"'survey.survey_name' | translate\"\n            [value]=\"form.get('translations')?.value[selectLanguageCode]?.name\"\n            (change)=\"setTranslates(selectLanguageCode, 'name', $event)\"\n            [data-qa]=\"'survey-name-' + selectLanguageCode\"\n          />\n        </mat-form-field>\n      </div>\n\n      <div class=\"form-row\">\n        <mat-label>{{ 'survey.description' | translate }}</mat-label>\n        <mat-form-field appearance=\"outline\">\n          <textarea\n            matInput\n            cdkTextareaAutosize\n            cdkAutosizeMinRows=\"2\"\n            cdkAutosizeMaxRows=\"5\"\n            [placeholder]=\"'survey.description' | translate\"\n            formControlName=\"description\"\n            [data-qa]=\"'description'\"\n            [readonly]=\"!isDefaultLanguageSelected\"\n          >\n          </textarea>\n        </mat-form-field>\n      </div>\n\n      <div class=\"form-row\" *ngIf=\"!isDefaultLanguageSelected\">\n        <mat-label> {{ 'survey.description' | translate }} ({{ selectLanguageCode }})</mat-label>\n        <mat-form-field appearance=\"outline\">\n          <textarea\n            matInput\n            cdkTextareaAutosize\n            cdkAutosizeMinRows=\"2\"\n            cdkAutosizeMaxRows=\"5\"\n            [placeholder]=\"'survey.description' | translate\"\n            [value]=\"form.get('translations')?.value[selectLanguageCode]?.description\"\n            (change)=\"setTranslates(selectLanguageCode, 'description', $event)\"\n            [data-qa]=\"'survey-description-' + selectLanguageCode\"\n          >\n          </textarea>\n        </mat-form-field>\n      </div>\n    </ng-container>\n  </app-survey-task>\n</form>\n\n<div class=\"form-head-panel\">\n  <h1>{{ 'survey.tasks' | translate }}</h1>\n  <mzima-client-button\n    color=\"secondary\"\n    fill=\"outline\"\n    (click)=\"addTask()\"\n    [data-qa]=\"'btn-add-task'\"\n    *ngIf=\"isDefaultLanguageSelected\"\n  >\n    <span>{{ 'survey.add_task' | translate }}</span>\n    <mat-icon icon svgIcon=\"plus\"></mat-icon>\n  </mzima-client-button>\n</div>\n\n<ng-container *ngIf=\"additionalTasks?.length; else noTasks\">\n  <app-survey-task\n    *ngFor=\"let task of additionalTasks\"\n    [task]=\"task\"\n    [isDefaultLanguageSelected]=\"isDefaultLanguageSelected\"\n    [selectLanguageCode]=\"selectLanguageCode\"\n    (deleteTaskChange)=\"deleteTask($event)\"\n    (duplicateTaskChange)=\"duplicateTask($event)\"\n    (errorFieldChange)=\"setErrorTaskField($event)\"\n  ></app-survey-task>\n</ng-container>\n\n<ng-template #noTasks>\n  <div class=\"form-row empty\">{{ 'survey.no_tasks' | translate }}</div>\n</ng-template>\n\n<div class=\"form-controls-spacer\" *ngIf=\"!isDesktop\"></div>\n\n<div class=\"form-controls-panel form-controls-panel--sticky\">\n  <mzima-client-button\n    fill=\"outline\"\n    color=\"secondary\"\n    (buttonClick)=\"cancel()\"\n    [data-qa]=\"'btn-cancel-survey-item'\"\n  >\n    {{ 'app.cancel' | translate }}\n  </mzima-client-button>\n  <mzima-client-button\n    (buttonClick)=\"save()\"\n    [disabled]=\"form.invalid || form.disabled || errorTaskField || submitted\"\n    [data-qa]=\"'btn-save-survey-item'\"\n  >\n    {{ (isEdit ? 'app.save' : 'app.add_survey') | translate }}\n  </mzima-client-button>\n</div>\n\n<pre [style]=\"{ display: 'none' }\">task</pre>\n","import { Location } from '@angular/common';\nimport { Component, OnInit, ViewChild } from '@angular/core';\nimport { FormBuilder, FormGroup, Validators } from '@angular/forms';\nimport { MatDialog } from '@angular/material/dialog';\nimport { ActivatedRoute, Router } from '@angular/router';\nimport { surveyHelper } from '@helpers';\nimport { LanguageInterface } from '@mzima-client/sdk';\nimport { UntilDestroy, untilDestroyed } from '@ngneat/until-destroy';\nimport { BreakpointService, SessionService } from '@services';\nimport { BaseComponent } from '../../../base.component';\nimport { AlphanumericValidatorValidator, noWhitespaceValidator } from '../../../core/validators';\nimport { SelectLanguagesModalComponent } from '../../../shared/components';\nimport { CreateTaskModalComponent } from '../create-task-modal/create-task-modal.component';\nimport { SurveyTaskComponent } from '../survey-task/survey-task.component';\nimport {\n  FormsService,\n  SurveysService,\n  RolesService,\n  RoleResult,\n  SurveyItemTask,\n  SurveyItemEnabledLanguages,\n} from '@mzima-client/sdk';\nimport { NotificationService } from '../../../core/services/notification.service';\nimport { LanguageService } from '../../../core/services/language.service';\nimport _ from 'lodash';\n\n@UntilDestroy()\n@Component({\n  selector: 'app-survey-item',\n  templateUrl: './survey-item.component.html',\n  styleUrls: ['./survey-item.component.scss'],\n})\nexport class SurveyItemComponent extends BaseComponent implements OnInit {\n  @ViewChild('configTask') configTask: SurveyTaskComponent;\n  public selectedLang?: LanguageInterface;\n  selectLanguageCode: string;\n  public description: string;\n  public name: string;\n  public form: FormGroup;\n  public isEdit = false;\n  roles: RoleResult[] = [];\n  surveyId: string;\n  additionalTasks: SurveyItemTask[] = [];\n  mainPost: SurveyItemTask;\n  surveyObject: any;\n  public languages: LanguageInterface[];\n  public defaultLanguage?: LanguageInterface;\n  public activeLanguages: LanguageInterface[];\n  public errorTaskField = false;\n  public submitted = false;\n  isDefaultLanguageSelected = true;\n\n  constructor(\n    protected override sessionService: SessionService,\n    protected override breakpointService: BreakpointService,\n    private formBuilder: FormBuilder,\n    private router: Router,\n    private dialog: MatDialog,\n    private route: ActivatedRoute,\n    private surveysService: SurveysService,\n    private formsService: FormsService,\n    private rolesService: RolesService,\n    private notification: NotificationService,\n    private languageService: LanguageService,\n    private location: Location,\n  ) {\n    super(sessionService, breakpointService);\n    this.checkDesktop();\n\n    this.form = this.formBuilder.group({\n      name: ['', [Validators.required, noWhitespaceValidator, AlphanumericValidatorValidator()]],\n      description: [''],\n      color: [null],\n      enabled_languages: this.formBuilder.group({\n        default: ['en'],\n        available: [[]],\n      }),\n      tasks: [[]],\n      base_language: [''],\n      require_approval: [true],\n      everyone_can_create: [true],\n      translations: [{}],\n      can_create: [[]],\n      disabled: [false],\n      hide_author: [false],\n      hide_location: [false],\n      hide_time: [false],\n      targeted_survey: [false],\n      type: [''],\n    });\n  }\n\n  loadData(): void {}\n\n  private initLanguages(enabledLanguages: SurveyItemEnabledLanguages) {\n    this.languages = this.languageService.getLanguages();\n    this.defaultLanguage = this.languages.find(\n      (lang) => lang.code.split('-')[0] === enabledLanguages.default.split('-')[0],\n    );\n    this.selectedLang = this.defaultLanguage;\n    const availableLangs = enabledLanguages.available;\n    const active = this.defaultLanguage ? [this.defaultLanguage] : [];\n    if (availableLangs.length) {\n      availableLangs.forEach((langCode: string) => {\n        active.push(\n          this.languages.find((lang) => lang.code.split('-')[0] === langCode.split('-')[0])!,\n        );\n      });\n    }\n    this.activeLanguages = active;\n  }\n\n  public ngOnInit(): void {\n    this.initRoles();\n    const id = this.route.snapshot.paramMap.get('id');\n    if (id) {\n      this.surveyId = id;\n      this.isEdit = !!id;\n      this.surveysService.getSurveyById(id).subscribe({\n        next: (response) => {\n          this.updateForm(response.result);\n          this.initLanguages(response.result.enabled_languages);\n          this.initTasks();\n        },\n      });\n    } else {\n      this.initLanguages({ available: [], default: 'en' });\n      this.initTasks(true);\n    }\n  }\n\n  private initTasks(isNew = false) {\n    this.surveyObject = this.form.value;\n\n    if (isNew) {\n      const defaultTask = _.cloneDeep(surveyHelper.defaultTask);\n      this.form.patchValue({ tasks: [defaultTask] });\n    }\n\n    this.mainPost = this.form\n      .get('tasks')\n      ?.value.filter((t: SurveyItemTask) => t.type === 'post')[0];\n    this.additionalTasks = this.form\n      .get('tasks')\n      ?.value.filter((t: SurveyItemTask) => t.type === 'task');\n    this.form.controls['tasks'].valueChanges.pipe(untilDestroyed(this)).subscribe((change) => {\n      this.additionalTasks = change.filter((t: SurveyItemTask) => t.type === 'task');\n    });\n  }\n\n  updateForm(data: any) {\n    Object.keys(data).forEach((key) => {\n      if (this.form.controls[key]) {\n        this.form.controls[key].patchValue(data[key]);\n      }\n    });\n  }\n\n  taskUpdate(data: any) {\n    let tasks = this.form.controls['tasks'].value;\n    tasks = tasks.map((task: any) => (task.id === data.id ? data : task));\n\n    this.form.patchValue({\n      tasks: tasks,\n    });\n  }\n\n  private getFormControl(name: string) {\n    return this.form.controls[name];\n  }\n\n  public addTranslation(): void {\n    const dialogRef = this.dialog.open(SelectLanguagesModalComponent, {\n      width: '100%',\n      maxWidth: 576,\n      panelClass: ['modal', 'select-languages-modal'],\n      data: {\n        languages: this.languages,\n        activeLanguages: this.activeLanguages,\n        defaultLanguage: this.defaultLanguage,\n      },\n    });\n\n    dialogRef.afterClosed().subscribe({\n      next: (selectedLanguages: LanguageInterface[]) => {\n        if (!selectedLanguages) return;\n        this.getFormControl('enabled_languages').value.available = selectedLanguages\n          .filter((language) => language.code !== this.defaultLanguage?.code)\n          .map((language) => language.code);\n        const translations: any = {};\n        selectedLanguages\n          .filter((language) => language.code !== this.defaultLanguage?.code)\n          .map((language) => {\n            translations[language.code] = {\n              name: this.getFormControl('translations').value[language.code]?.name || '',\n              description:\n                this.getFormControl('translations').value[language.code]?.description || '',\n            };\n          });\n        this.getFormControl('translations').setValue(translations);\n        this.chooseTranslation(selectedLanguages[selectedLanguages.length - 1]);\n      },\n    });\n  }\n\n  public chooseTranslation(language: LanguageInterface): void {\n    this.selectLanguageCode = language.code;\n    this.selectedLang = language;\n    this.name = this.description = '';\n    this.isDefaultLanguageSelected = this.selectLanguageCode === this.defaultLanguage?.code;\n  }\n\n  public setTranslates(languageCode: string, field: string, event: any) {\n    const translations = this.getFormControl('translations').value;\n    for (const key in translations) {\n      if (key === languageCode) {\n        translations[key] = {\n          ...translations[key],\n          [field]: event.target.value,\n        };\n        this.form.patchValue({\n          translations: translations,\n        });\n      }\n    }\n  }\n\n  initRoles() {\n    this.rolesService.getRoles().subscribe((response) => {\n      this.roles = response.results;\n    });\n  }\n\n  saveRoles(formId: string, selectedRoles?: any[]) {\n    const admin: any = this.roles.find((r: any) => r.name === 'admin');\n    if (\n      !this.getFormControl('everyone_can_create').value &&\n      !selectedRoles?.some((r) => r?.name === admin.name)\n    ) {\n      selectedRoles?.push(admin);\n    }\n    if (selectedRoles !== undefined) {\n      this.formsService\n        .updateRoles(\n          formId,\n          selectedRoles.map((r: any) => r?.id),\n        )\n        .subscribe();\n    }\n  }\n\n  languageChange(event: any) {\n    this.defaultLanguage = this.languages.find(\n      (l) => l.code.split('-')[0] === event.value.split('-'[0]),\n    );\n    this.selectedLang = this.defaultLanguage;\n    const availableLangs = this.form.controls['enabled_languages'].value.available;\n    const active = this.defaultLanguage ? [this.defaultLanguage] : [];\n    if (availableLangs.length) {\n      availableLangs.forEach((langCode: string) => {\n        active.push(\n          this.languages.find((lang) => lang.code.split('-')[0] === langCode.split('-')[0])!,\n        );\n      });\n    }\n    this.activeLanguages = active;\n  }\n\n  public save() {\n    this.submitted = true;\n    const defaultLang: any[] = this.configTask.selectedLanguage;\n    if (this.validateAttributeOptionTranslations()) {\n      this.form.patchValue({\n        base_language: defaultLang,\n      });\n\n      const selectedRoles = this.configTask.selectedRoles.options?.map((r: any) =>\n        this.roles.find((role) => role.name === r),\n      );\n\n      const request = Object.assign(\n        {},\n        {\n          ...this.form.value,\n          name: this.form.value.name.trim(),\n          description: this.form.value.description.trim(),\n          everyone_can_create: !selectedRoles?.length,\n        },\n        this.configTask.getConfigOptions(),\n      );\n      this.surveysService.saveSurvey(request, this.surveyId).subscribe({\n        next: (response) => {\n          this.updateForm(response.result);\n          this.saveRoles(response.result.id, selectedRoles);\n          this.router.navigate(['settings/surveys']);\n        },\n        error: ({ error }) => {\n          this.submitted = false;\n          if (error.errors.status === 422) {\n            this.form.controls['name'].setErrors({ invalidCharacters: true });\n            this.notification.showError('Please remove invalid characters (e.g. +, $, ^, =)');\n          } else {\n            this.notification.showError(JSON.stringify(error.name[0]));\n          }\n        },\n      });\n    } else {\n      this.notification\n        .showError(`You need to add translations for all names, and ensure checkboxes and radios do not have duplicates.\n       Check that you have translated the survey-names for all added languages and that your checkbox and radio button values are unique (within each language).`);\n    }\n  }\n\n  public cancel() {\n    if (this.isDesktop) {\n      this.router.navigate(['settings/surveys']);\n    } else {\n      this.location.back();\n    }\n  }\n\n  addTask() {\n    const dialogRef = this.dialog.open(CreateTaskModalComponent, {\n      width: '100%',\n      maxWidth: 576,\n      minWidth: 300,\n      panelClass: 'modal',\n    });\n\n    dialogRef.afterClosed().subscribe({\n      next: (response) => {\n        if (response) {\n          const tasks: SurveyItemTask[] = this.getFormControl('tasks').value;\n          tasks.push(response);\n          this.form.patchValue({ tasks });\n        }\n      },\n    });\n  }\n\n  validateAttributeOptionTranslations() {\n    const availableLangs: any[] = this.getFormControl('enabled_languages').value.available;\n    const tasks: SurveyItemTask[] = this.getFormControl('tasks').value;\n    return availableLangs.every((language) => {\n      return tasks.every((t) => {\n        return t.fields.every((f) => {\n          if (\n            surveyHelper.fieldHasTranslations(f, language) &&\n            surveyHelper.fieldCanHaveOptions(f)\n          ) {\n            return surveyHelper.areOptionsUnique(Object.values(f.translations[language].options));\n          } else {\n            return true;\n          }\n        });\n      });\n    });\n  }\n\n  validateSurveyTranslations() {\n    const availableLangs: any[] = this.getFormControl('enabled_languages').value.available;\n    const translations = this.getFormControl('translations').value;\n\n    return availableLangs.every((language) => {\n      return translations[language]?.name;\n    });\n  }\n\n  public setNewColor(color: string): void {\n    this.form.patchValue({ color });\n  }\n\n  public deleteTask(task: SurveyItemTask) {\n    const tasks: SurveyItemTask[] = this.getFormControl('tasks').value;\n    const index = tasks.indexOf(task);\n    tasks.splice(index, 1);\n    this.form.patchValue({ tasks });\n  }\n\n  public duplicateTask(task: SurveyItemTask) {\n    const tasks: SurveyItemTask[] = this.getFormControl('tasks').value;\n    tasks.push(task);\n    this.form.patchValue({ tasks });\n  }\n\n  public setErrorTaskField(event: boolean) {\n    this.errorTaskField = event;\n  }\n}\n","<app-settings-header\n  [settingsTitle]=\"'app.surveys'\"\n  [newButtonTitle]=\"'settings.new_survey'\"\n  [selectedItem]=\"selectedSurveys\"\n  (isShowActionsChange)=\"showActions($event)\"\n  (deleteCall)=\"deleteSurvey()\"\n>\n  <mzima-client-button\n    fill=\"outline\"\n    color=\"secondary\"\n    class=\"survey-button\"\n    [data-qa]=\"'btn-settings-duplicate'\"\n    [disabled]=\"selectedSurveys.length !== 1\"\n    (buttonClick)=\"duplicateSurvey()\"\n  >\n    <mat-icon icon svgIcon=\"copy\" class=\"button-icon\"></mat-icon>\n    <span class=\"button-name\">{{ 'app.duplicate' | translate }}</span>\n  </mzima-client-button>\n</app-settings-header>\n\n<app-spinner class=\"spinner\" *ngIf=\"isLoading || !surveys.length\"></app-spinner>\n\n<ul role=\"list\" class=\"types-list\" *ngIf=\"surveys.length\" [data-qa]=\"'survey-list'\">\n  <li\n    mat-ripple\n    role=\"listitem\"\n    class=\"type-item\"\n    *ngFor=\"let survey of surveys\"\n    [routerLink]=\"['update', survey.id]\"\n    [ngStyle]=\"{ '--color': survey.color }\"\n    [data-qa]=\"generateDataQa(survey.name)\"\n  >\n    <mat-checkbox\n      *ngIf=\"isShowActions\"\n      class=\"type-item__checkbox\"\n      (click)=\"$event.stopPropagation()\"\n      (change)=\"selectSurveys($event, survey)\"\n    ></mat-checkbox>\n    {{ survey.name }}\n  </li>\n</ul>\n<button\n  mat-button\n  (click)=\"loadMore()\"\n  class=\"load-more\"\n  *ngIf=\"!isLoading && params.current_page < params.last_page\"\n>\n  <mat-icon svgIcon=\"refresh\"></mat-icon>\n  <span>{{ 'app.load_more' | translate }}</span>\n</button>\n\n<div class=\"actions-spacer\" *ngIf=\"!(isDesktop$ | async)! && isShowActions\"></div>\n","import { Component, OnInit } from '@angular/core';\nimport { MatCheckboxChange } from '@angular/material/checkbox';\nimport { TranslateService } from '@ngx-translate/core';\nimport { BreakpointService } from '@services';\nimport { forkJoin, Observable, take } from 'rxjs';\nimport { SurveysService, SurveyItem } from '@mzima-client/sdk';\nimport { ConfirmModalService } from '../../core/services/confirm-modal.service';\nimport { UntilDestroy, untilDestroyed } from '@ngneat/until-destroy';\n\n@UntilDestroy()\n@Component({\n  selector: 'app-surveys',\n  templateUrl: './surveys.component.html',\n  styleUrls: ['./surveys.component.scss'],\n})\nexport class SurveysComponent implements OnInit {\n  public isDesktop$: Observable<boolean>;\n  public surveys: SurveyItem[] = [];\n  public selectedSurveys: SurveyItem[] = [];\n  public isShowActions = false;\n\n  public params = {\n    page: 1,\n    order: 'asc',\n    limit: 0,\n    current_page: 0,\n    last_page: 0,\n    total: 0,\n  };\n  public isLoading = false;\n\n  constructor(\n    private readonly surveysService: SurveysService,\n    private readonly translate: TranslateService,\n    private readonly confirmModalService: ConfirmModalService,\n    private readonly breakpointService: BreakpointService,\n  ) {\n    this.isDesktop$ = this.breakpointService.isDesktop$.pipe(untilDestroyed(this));\n  }\n\n  ngOnInit(): void {\n    this.getSurveys();\n  }\n\n  private getSurveys(isAdd = false): void {\n    this.isLoading = true;\n    this.surveysService\n      .getSurveys('', {\n        page: this.params.page,\n        order: this.params.order,\n        limit: this.params.limit,\n      })\n      .subscribe({\n        next: (res) => {\n          this.surveys = isAdd ? [...this.surveys, ...res.results] : res.results;\n          const { current_page: currentPage, last_page: lastPage, total } = res.meta;\n          this.params = { ...this.params, current_page: currentPage, last_page: lastPage, total };\n          this.isLoading = false;\n        },\n        error: (err) => {\n          console.log(err);\n          this.isLoading = false;\n        },\n      });\n  }\n\n  public duplicateSurvey() {\n    this.isLoading = true;\n    if (this.selectedSurveys.length !== 1) return;\n\n    const survey: SurveyItem = this.selectedSurveys.shift()!;\n    const surveyDuplicate = { ...survey, id: null, name: `${survey.name} - duplicate` };\n    this.surveysService.post(surveyDuplicate).subscribe({\n      next: () => {\n        this.getSurveys();\n      },\n      error: (err) => {\n        console.log(err);\n        this.isLoading = false;\n      },\n    });\n  }\n\n  async deleteSurvey() {\n    const confirmed = await this.confirmModalService.open({\n      title:\n        this.selectedSurveys.length > 1\n          ? 'Are you sure you want to delete selected surveys?'\n          : this.translate.instant('notify.survey.destroy_confirm'),\n      description: `\n        <p>${\n          this.selectedSurveys.length > 1\n            ? 'Deleting these surveys will remove it from database. This action cannot be undone.'\n            : this.translate.instant('notify.survey.destroy_confirm_desc')\n        }</p>\n      `,\n\n      confirmButtonText: this.translate.instant('app.yes_delete'),\n      cancelButtonText: this.translate.instant('app.no_go_back'),\n    });\n\n    if (!confirmed) return;\n    this.isLoading = true;\n    forkJoin(\n      this.selectedSurveys.map((survey) => {\n        this.surveysService.removeFromFilters(survey.id);\n        return this.surveysService.deleteSurvey(survey.id);\n      }),\n    )\n      .pipe(take(1))\n      .subscribe({\n        next: () => {\n          this.getSurveys();\n          this.selectedSurveys = [];\n        },\n        error: (e) => {\n          console.log(e);\n          this.isLoading = false;\n        },\n      });\n  }\n\n  public selectSurveys({ checked }: MatCheckboxChange, survey: SurveyItem) {\n    if (checked) {\n      this.selectedSurveys.push(survey);\n    } else {\n      this.selectedSurveys = this.selectedSurveys.filter((s) => s.id !== survey.id);\n    }\n  }\n\n  public showActions(event: boolean) {\n    this.isShowActions = event;\n  }\n\n  public loadMore(): void {\n    if (this.params.current_page < this.params.last_page) {\n      this.params.page += 1;\n      this.getSurveys(true);\n    }\n  }\n\n  public generateDataQa(name: string): string {\n    return name.replace(/ /g, '-').toLowerCase();\n  }\n}\n","import { NgModule } from '@angular/core';\nimport { RouterModule, Routes } from '@angular/router';\nimport { SurveyItemComponent } from './survey-item/survey-item.component';\n\nimport { SurveysComponent } from './surveys.component';\n\nconst routes: Routes = [\n  { path: '', component: SurveysComponent },\n  { path: 'create', component: SurveyItemComponent, data: { breadcrumb: 'Create survey' } },\n  { path: 'update/:id', component: SurveyItemComponent, data: { breadcrumb: 'Update survey' } },\n];\n\n@NgModule({\n  imports: [RouterModule.forChild(routes)],\n  exports: [RouterModule],\n})\nexport class SurveysRoutingModule {}\n","import { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { FormsModule, ReactiveFormsModule } from '@angular/forms';\nimport { MatButtonModule } from '@angular/material/button';\nimport { MatCheckboxModule } from '@angular/material/checkbox';\nimport { MatRippleModule } from '@angular/material/core';\nimport { MatDialogModule } from '@angular/material/dialog';\nimport { MatExpansionModule } from '@angular/material/expansion';\nimport { MatIconModule } from '@angular/material/icon';\nimport { MatInputModule } from '@angular/material/input';\nimport { MatSelectModule } from '@angular/material/select';\nimport { MatSlideToggleModule } from '@angular/material/slide-toggle';\nimport { MatTreeModule } from '@angular/material/tree';\nimport { MatListModule } from '@angular/material/list';\nimport { TranslateModule } from '@ngx-translate/core';\nimport { SortByFieldModule } from '@pipes';\nimport { ColorPickerComponentModule } from '../../shared/components/color-picker/color-picker-component.module';\nimport { GroupCheckboxSelectModule } from '../../shared/components/group-checkbox-select/group-checkbox-select.module';\nimport { MultilevelSelectModule } from '../../shared/components/multilevel-select/multilevel-select.module';\nimport { SettingsHeaderModule } from '../../shared/components/settings-header/settings-header.module';\nimport { DirectiveModule, SpinnerModule } from '@shared';\n\nimport { SurveysRoutingModule } from './surveys-routing.module';\nimport { SurveysComponent } from './surveys.component';\nimport { SurveyItemComponent } from './survey-item/survey-item.component';\nimport { SurveyTaskComponent } from './survey-task/survey-task.component';\nimport { MultilevelSelectionComponent } from './multilevel-selection/multilevel-selection.component';\nimport { MatTabsModule } from '@angular/material/tabs';\nimport { DragDropModule } from '@angular/cdk/drag-drop';\nimport { CreateTaskModalComponent } from './create-task-modal/create-task-modal.component';\nimport { CreateFieldModalComponent } from './create-field-modal/create-field-modal.component';\nimport { ShareMenuComponent } from './share-menu/share-menu.component';\nimport { QuillModule } from 'ngx-quill';\nimport { MzimaUiModule } from '@mzima-client/mzima-ui';\n\n@NgModule({\n  declarations: [\n    SurveysComponent,\n    SurveyItemComponent,\n    SurveyTaskComponent,\n    CreateTaskModalComponent,\n    CreateFieldModalComponent,\n    ShareMenuComponent,\n    MultilevelSelectionComponent,\n  ],\n  imports: [\n    CommonModule,\n    MatTabsModule,\n    DragDropModule,\n    SurveysRoutingModule,\n    MatExpansionModule,\n    QuillModule.forRoot(),\n    MatButtonModule,\n    MatIconModule,\n    TranslateModule,\n    MatDialogModule,\n    MatInputModule,\n    FormsModule,\n    MultilevelSelectModule,\n    MatSlideToggleModule,\n    SpinnerModule,\n    MatRippleModule,\n    ReactiveFormsModule,\n    SettingsHeaderModule,\n    MatSelectModule,\n    GroupCheckboxSelectModule,\n    ColorPickerComponentModule,\n    DirectiveModule,\n    MatCheckboxModule,\n    MatTreeModule,\n    MatListModule,\n    MzimaUiModule,\n    SortByFieldModule,\n  ],\n})\nexport class SurveysModule {}\n"],"x_google_ignoreList":[5,6]}